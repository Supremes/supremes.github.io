<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git 学习笔记</title>
      <link href="/posts/3c3cdb74.html"/>
      <url>/posts/3c3cdb74.html</url>
      
        <content type="html"><![CDATA[<h1 id="git-rm-cache"><a href="#git-rm-cache" class="headerlink" title="git rm --cache &lt;filename&gt;"></a><code>git rm --cache &lt;filename&gt;</code></h1><blockquote><p> 让 git 停止跟踪某个文件，但是不删除本地的文件</p></blockquote><p>常用语某些“亡羊补牢”的场景，把不该提交的配置文件提到到了 Git，现在需要从仓库中删除，但本地还需要使用，通常配合 <code>.gitignore</code> 使用。</p><h1 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a><code>.gitignore</code></h1><p>只对 <code>未被追踪 untracked</code> 的文件有效，一旦文件之前被 commit 过，git 便会无视该文件的配置，因此需要配合上述 <code>git rm --cahce</code> 使用。</p><h1 id="git-restore"><a href="#git-restore" class="headerlink" title="git restore &lt;filename&gt;"></a><code>git restore &lt;filename&gt;</code></h1><p>旧版命令：<code>git checkout -- &lt;文件名&gt;</code></p><p>放弃 <code>工作区</code> 的修改，用 <code>暂存区</code> 覆盖 <code>工作区</code>。</p><ul><li>如果 <code>工作区</code> 没有改动，便会直接撤销工作区的改动</li><li>如果 <code>工作区</code> 有改动，便会覆盖</li></ul><h1 id="git-restore-staged"><a href="#git-restore-staged" class="headerlink" title="git restore --staged &lt;filename&gt;"></a><code>git restore --staged &lt;filename&gt;</code></h1><p>旧命令: &#96;git reset HEAD <filename>&#96;&#96;</p><p>将文件从 <code>暂存区</code> 切换到 <code>工作区</code> , 即在执行完 <code>git add</code> 命令后，用来撤回。</p><h1 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a><code>git stash</code></h1>]]></content>
      
      
      <categories>
          
          <category> 工具效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java</title>
      <link href="/posts/5363d109.html"/>
      <url>/posts/5363d109.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-8-新特性"><a href="#Java-8-新特性" class="headerlink" title="Java 8 新特性"></a>Java 8 新特性</h1><h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testLambda</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;sex&quot;</span>, <span class="string">&quot;hobby&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with method reference -- static method</span></span><br><span class="line">    names.forEach(System.out::println);</span><br><span class="line">    names.forEach(name -&gt; System.out.println(name));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with method reference -- instance method</span></span><br><span class="line">    names.sort(String::compareTo);</span><br><span class="line">    names.sort((a, b) -&gt; a.compareTo(b));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with method reference -- constructor method</span></span><br><span class="line">    Supplier&lt;Map&lt;String, String&gt;&gt; mm = () -&gt; <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Supplier&lt;Map&lt;String, String&gt;&gt; supplier = HashMap::<span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><p>Lamda 的基本语法有三步构成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数列表) -&gt; &#123;方法体&#125;</span><br></pre></td></tr></table></figure><ul><li>参数列表：<code>可省略类型</code>，编译器会自动推断</li><li>右侧：Lamda 体，若只有一行代码，可以省略 <code>花括号{}和 return 关键字</code></li></ul><h3 id="函数式接口-Functional-Interface"><a href="#函数式接口-Functional-Interface" class="headerlink" title="函数式接口 - Functional Interface"></a>函数式接口 - Functional Interface</h3><p>Lambda 表达式不能凭空存在，它必须依附于<strong>函数式接口</strong>。</p><blockquote><ul><li>Lambda 表达式<strong>必须</strong>依托于一个<strong>确定的接口</strong>（JDK 自带的如 <code>Runnable</code>, <code>Predicate</code> 或者你自定义的接口）。</li><li>这个接口充当了 Lambda 的“身份证明”。没有这个接口，Java 编译器就不知道如何存储和调用这段代码。</li></ul></blockquote><ul><li><strong>定义</strong>：只包含<strong>一个抽象方法</strong>的接口。</li><li><strong>注解</strong>：通常使用 <code>@FunctionalInterface</code> 标记（非强制，但推荐）。</li><li><strong>常见接口</strong>：<code>Runnable</code>, <code>Comparator</code>, 以及 Java 8 新增的 <code>java.util.function</code> 包下的 <code>Predicate</code>, <code>Consumer</code>, <code>Function</code>, <code>Supplier</code>。</li></ul><h4 id="四种系统预定义函数式接口-示例代码"><a href="#四种系统预定义函数式接口-示例代码" class="headerlink" title="四种系统预定义函数式接口 - 示例代码"></a>四种系统预定义函数式接口 - <a href="https://github.com/Supremes/blog_demo_application/blob/master/src/main/java/org/dododo/StreamDemo.java">示例代码</a></h4><h5 id="1-Consumer-消费者"><a href="#1-Consumer-消费者" class="headerlink" title="1. Consumer (消费者)"></a>1. Consumer (消费者)</h5><blockquote><p><strong>口诀：只吃不吐（有去无回）</strong></p></blockquote><ul><li><strong>作用</strong>：接收一个参数，进行处理，<strong>不返回任何值</strong>。</li><li><strong>抽象方法</strong>：<code>void accept(T t)</code></li><li><strong>适用场景</strong>：打印日志、写入数据库、发送消息等“副作用”操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：接收一个 String，把它打印出来（没有返回值）</span></span><br><span class="line">Consumer&lt;String&gt; printer = s -&gt; System.out.println(<span class="string">&quot;Processing: &quot;</span> + s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用：</span></span><br><span class="line">printer.accept(<span class="string">&quot;Hello World&quot;</span>); </span><br><span class="line"><span class="comment">// 输出: Processing: Hello World</span></span><br></pre></td></tr></table></figure><h5 id="2-Supplier-供给者"><a href="#2-Supplier-供给者" class="headerlink" title="2. Supplier (供给者)"></a>2. Supplier (供给者)</h5><blockquote><p><strong>口诀：无中生有（只吐不吃）</strong></p></blockquote><ul><li><strong>作用</strong>：不接收任何参数，<strong>返回一个结果</strong>。</li><li><strong>抽象方法</strong>：<code>T get()</code></li><li><strong>适用场景</strong>：生成随机数、获取当前时间、懒加载对象、工厂模式。</li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：不接受参数，返回一个随机整数</span></span><br><span class="line">Supplier&lt;Integer&gt; randomizer = () -&gt; (<span class="type">int</span>)(Math.random() * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用：</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> randomizer.get();</span><br><span class="line">System.out.println(num);</span><br></pre></td></tr></table></figure><hr><h5 id="3-Function-函数-转换者"><a href="#3-Function-函数-转换者" class="headerlink" title="3. Function (函数&#x2F;转换者)"></a>3. Function (函数&#x2F;转换者)</h5><blockquote><p><strong>口诀：有去有回（加工处理）</strong></p></blockquote><ul><li><strong>作用</strong>：接收一个参数，经过处理后，<strong>返回一个结果</strong>。这是最经典的数学函数概念 $y &#x3D; f(x)$。</li><li><strong>抽象方法</strong>：<code>R apply(T t)</code> (T 是输入类型，R 是输出类型)</li><li><strong>适用场景</strong>：类型转换（String 转 Integer）、对象提取（User 对象转 UserID）、数据处理。</li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：接收一个 String，返回它的长度 Integer</span></span><br><span class="line"><span class="comment">// Function&lt;输入类型, 输出类型&gt;</span></span><br><span class="line">Function&lt;String, Integer&gt; lengthMapper = s -&gt; s.length();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用：</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> lengthMapper.apply(<span class="string">&quot;Java8&quot;</span>);</span><br><span class="line">System.out.println(len); <span class="comment">// 输出: 5</span></span><br></pre></td></tr></table></figure><hr><h5 id="4-Predicate-断言-裁判"><a href="#4-Predicate-断言-裁判" class="headerlink" title="4. Predicate (断言&#x2F;裁判)"></a>4. Predicate (断言&#x2F;裁判)</h5><blockquote><p><strong>口诀：非黑即白（真假判断）</strong></p></blockquote><ul><li><strong>作用</strong>：接收一个参数，<strong>返回一个布尔值 (boolean)</strong>。</li><li><strong>抽象方法</strong>：<code>boolean test(T t)</code></li><li><strong>适用场景</strong>：数据过滤（filter）、条件判断、权限检查。</li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：接收一个 String，判断它的长度是否大于 5</span></span><br><span class="line">Predicate&lt;String&gt; isLongText = s -&gt; s.length() &gt; <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用：</span></span><br><span class="line">System.out.println(isLongText.test(<span class="string">&quot;Java&quot;</span>));   <span class="comment">// false</span></span><br><span class="line">System.out.println(isLongText.test(<span class="string">&quot;Java8_Lambda&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><hr><h5 id="总结对比表-Cheat-Sheet"><a href="#总结对比表-Cheat-Sheet" class="headerlink" title="总结对比表 (Cheat Sheet)"></a>总结对比表 (Cheat Sheet)</h5><p>针对 <code>Consumer</code>, <code>Function</code>, <code>Predicate</code> 提供了 “Bi” (Binary，二元) 版本：</p><ol><li><strong>BiConsumer&lt;T, U&gt;</strong>：接收两个参数，无返回值。<ul><li><em>比如：把 Key 和 Value 放入 Map。</em></li></ul></li><li><strong>BiFunction&lt;T, U, R&gt;</strong>：接收两个参数 (T, U)，返回一个结果 (R)。<ul><li><em>比如：两个整数相加 <code>(a, b) -&gt; a + b</code>。</em></li></ul></li><li><strong>BiPredicate&lt;T, U&gt;</strong>：接收两个参数，返回 boolean。<ul><li><em>比如：判断两个字符串是否相等。</em><br><em>(注：Supplier 不需要 Bi 版本，因为它本身就不接受参数)</em></li></ul></li></ol><table><thead><tr><th><strong>接口名</strong></th><th><strong>输入参数</strong></th><th><strong>返回值</strong></th><th><strong>方法名</strong></th><th><strong>核心逻辑</strong></th><th><strong>典型应用</strong></th></tr></thead><tbody><tr><td><strong>Consumer<T></strong></td><td>T</td><td>void</td><td><code>accept(t)</code></td><td><strong>消费</strong>数据</td><td><code>forEach</code> 打印、保存</td></tr><tr><td><strong>Supplier<T></strong></td><td>无</td><td>T</td><td><code>get()</code></td><td><strong>提供</strong>数据</td><td><code>generate</code> 生成、工厂方法</td></tr><tr><td><strong>Function&lt;T, R&gt;</strong></td><td>T</td><td>R</td><td><code>apply(t)</code></td><td><strong>转换</strong>数据</td><td><code>map</code> 转换、提取字段</td></tr><tr><td><strong>Predicate<T></strong></td><td>T</td><td>boolean</td><td><code>test(t)</code></td><td><strong>判断</strong>数据</td><td><code>filter</code> 过滤、验证</td></tr></tbody></table><h2 id="Method-Reference-方法引用"><a href="#Method-Reference-方法引用" class="headerlink" title="Method Reference - 方法引用"></a>Method Reference - 方法引用</h2><blockquote><p> 方法引用是 Lambda 表达式的<strong>语法糖</strong>（Syntactic Sugar）。如果你的 Lambda 表达式仅仅是<strong>调用一个已经存在的方法</strong>，那么你可以直接使用方法引用来替代 Lambda。</p></blockquote><h4 id="语法格式-1"><a href="#语法格式-1" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名或对象名::方法名</span><br></pre></td></tr></table></figure><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lamba</span></span><br><span class="line">Function&lt;String, Integer&gt; func = input -&gt; Integer.parseInt(input)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法引用</span></span><br><span class="line">Function&lt;String, Integer&gt; ref = Integer::parseInt;</span><br></pre></td></tr></table></figure><ul><li><strong>Lambda</strong> 是为了让我们可以把函数当作参数传递，摆脱繁琐的匿名内部类。</li><li><strong>方法引用</strong> 是在 Lambda 的基础上，如果逻辑只是“调用一个已有的方法”，则进一步简化代码。</li></ul><h2 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h2><p><code>Supplier</code> 接口的应用场景通常涉及需要延迟计算、动态生成值、或者在需要提供某种默认值的情况。以下是一些可能的应用场景：</p><ol><li><p><strong>延迟计算：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Double&gt; randomSupplier = Math::random;</span><br><span class="line"><span class="comment">// 这里并不会立即生成随机数，而是在调用get()时才生成</span></span><br><span class="line"><span class="type">double</span> <span class="variable">randomValue</span> <span class="operator">=</span> randomSupplier.get();</span><br></pre></td></tr></table></figure></li><li><p><strong>提供默认值：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;String&gt; defaultStringSupplier = () -&gt; <span class="string">&quot;Default Value&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> getValueFromSomeSource(); <span class="comment">// 某个方法获取值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (value != <span class="literal">null</span>) ? value : defaultStringSupplier.get();</span><br></pre></td></tr></table></figure></li><li><p><strong>动态生成对象：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;List&lt;String&gt;&gt; listSupplier = ArrayList::<span class="keyword">new</span>;</span><br><span class="line">List&lt;String&gt; list = listSupplier.get();</span><br></pre></td></tr></table></figure></li><li><p><strong>懒加载：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LazyInitializedObject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Supplier&lt;ExpensiveObject&gt; expensiveObjectSupplier = </span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            <span class="type">ExpensiveObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExpensiveObject</span>();</span><br><span class="line">            <span class="comment">// 进行一些初始化或者其他操作</span></span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ExpensiveObject <span class="title function_">getExpensiveObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> expensiveObjectSupplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这些例子都展示了如何使用 <code>Supplier</code> 接口来提供一种方法，使得某些值或操作的计算被推迟，直到真正需要这些值的时候再进行计算。这种延迟计算的特性可以提高性能，尤其是在处理昂贵或者资源密集型的操作时。</p><h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><p>Stream API 引入了一种新的抽象，用于对集合进行流式操作。它提供了一种声明性的方式来操作数据，支持类似 SQL 的查询语言，使得代码更为清晰和简洁。Stream 操作可以分为中间操作和终端操作。</p><p>中间操作可以是链式的，形成一条流水线，例如过滤、映射、排序等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; filteredNames = names.stream()</span><br><span class="line">                                  .filter(name -&gt; name.startsWith(<span class="string">&quot;A&quot;</span>))</span><br><span class="line">                                  .map(String::toUpperCase)</span><br><span class="line">                                  .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>终端操作会触发流水线的执行，例如收集、计数、聚合等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> names.stream().count();</span><br></pre></td></tr></table></figure><p>Stream API 使得我们能够以一种更函数式的方式来处理数据，从而提高代码的可读性和可维护性。</p><p>Lambda 表达式和 Stream API 通常一起使用，以实现更简洁、高效的集合操作。它们是 Java 向函数式编程的转变迈出的重要一步，为开发者提供了更多灵活性和表达力。</p><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><ol><li><p><strong>默认方法（Default Methods）：</strong></p><ul><li>接口中可以包含默认方法，允许在接口中提供具体实现，而不影响实现该接口的现有类。这为接口的演进提供了更大的灵活性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Default implementation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>函数式接口：</strong></p><ul><li>函数式接口是只包含一个抽象方法的接口。Java 8 通过 <code>@FunctionalInterface</code> 注解来支持函数式接口的定义，以便更好地支持 Lambda 表达式。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyFunctionalInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p><strong>新的日期和时间 API：</strong></p><ul><li><code>java.time</code> 包提供了全新的日期和时间 API，支持更方便的日期和时间操作，解决了旧的 <code>java.util.Date</code> 和 <code>java.util.Calendar</code> 类的问题。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.now();</span><br></pre></td></tr></table></figure></li><li><p><strong>CompletableFuture：</strong></p><ul><li><code>CompletableFuture</code> 是一个支持异步编程的工具，可以轻松处理异步操作和构建异步应用程序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">                                                   .thenApply(s -&gt; s + <span class="string">&quot; World&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>方法引用（Method References）：</strong></p><ul><li>方法引用是一种简化 Lambda 表达式的语法，它提供了一种直接引用已有方法（静态方法、实例方法或构造方法）的方式。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure></li></ol><p>这些特性使得 Java 8 在代码编写、集合操作、并发编程等方面变得更加强大和灵活。学习这些特性可以提高代码的效率、可读性，并使代码更具现代化。</p><h2 id="Java-17-新特性"><a href="#Java-17-新特性" class="headerlink" title="Java 17 新特性"></a>Java 17 新特性</h2><h3 id="1-文本块-Text-Blocks"><a href="#1-文本块-Text-Blocks" class="headerlink" title="1. 文本块 (Text Blocks)"></a>1. 文本块 (Text Blocks)</h3><blockquote><p><strong>解决痛点</strong>：在 Java 代码中拼接 JSON、SQL 或 HTML 字符串简直是噩梦（需要大量的 <code>+</code> 号和转义字符 <code>\&quot;</code>）。</p></blockquote><ul><li><strong>Java 13&#x2F;15 引入</strong></li><li>使用三个双引号 <code>&quot;&quot;&quot;</code> 包裹。</li></ul><p><strong>Java 8 写法：</strong></p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String json = &quot;&#123;\n&quot; +</span><br><span class="line">              &quot;  \&quot;name\&quot;: \&quot;Java\&quot;,\n&quot; +</span><br><span class="line">              &quot;  \&quot;age\&quot;: 17\n&quot; +</span><br><span class="line">              &quot;&#125;&quot;;</span><br></pre></td></tr></table></figure><p><strong>Java 17 写法：</strong></p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String json = &quot;&quot;&quot;</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;name&quot;: &quot;Java&quot;,</span><br><span class="line">                &quot;age&quot;: 17</span><br><span class="line">              &#125;</span><br><span class="line">              &quot;&quot;&quot;;</span><br><span class="line">// 所见即所得，自动处理缩进，无需手动转义引号</span><br></pre></td></tr></table></figure><hr><h3 id="2-Record-类-Records"><a href="#2-Record-类-Records" class="headerlink" title="2. Record 类 (Records)"></a>2. Record 类 (Records)</h3><blockquote><p><strong>解决痛点</strong>：为了写一个简单的 DTO (数据传输对象)，需要写构造器、Getter、<code>equals()</code>、<code>hashCode()</code>、<code>toString()</code>，或者依赖 Lombok。</p></blockquote><ul><li><strong>Java 14&#x2F;16 引入</strong></li><li><strong>Record</strong> 是一种特殊的类，它是<strong>不可变 (Immutable)</strong> 的，专门用于承载数据。</li></ul><p><strong>Java 8 写法 (需要 Lombok 或手动写一大堆)：</strong></p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Point &#123;</span><br><span class="line">    private final int x;</span><br><span class="line">    private final int y;</span><br><span class="line"></span><br><span class="line">    public Point(int x, int y) &#123; </span><br><span class="line">        this.x = x; </span><br><span class="line">        this.y = y; </span><br><span class="line">    &#125;</span><br><span class="line">    // 还要写 getter, equals, hashCode, toString...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java 17 写法：</strong></p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 一行代码搞定！</span><br><span class="line">// 自动生成：构造器、x() 和 y() 访问方法（注意不叫 getX）、equals、hashCode、toString</span><br><span class="line">public record Point(int x, int y) &#123;&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>特性</strong></th><th><strong>Lombok @Data</strong></th><th><strong>Java 17 Record</strong></th></tr></thead><tbody><tr><td><strong>本质</strong></td><td>代码生成工具 (Annotation Processor)</td><td>Java 语言特性 (Class 的变体)</td></tr><tr><td><strong>可变性</strong></td><td><strong>Mutable</strong> (有 Setters)</td><td><strong>Immutable</strong> (无 Setters, 全 final)</td></tr><tr><td><strong>继承</strong></td><td>可以继承&#x2F;被继承</td><td><strong>不可继承</strong> (隐式 final)</td></tr><tr><td><strong>访问器命名</strong></td><td><code>getName()</code></td><td><code>name()</code></td></tr><tr><td><strong>无参构造器</strong></td><td>默认有 (或通过 <code>@NoArgsConstructor</code>)</td><td><strong>默认无</strong> (只有全参构造器)</td></tr><tr><td><strong>框架支持</strong></td><td>100% 支持 (JavaBean 规范)</td><td>需要较新框架支持 (Jackson 2.12+, Spring 5.3+)</td></tr><tr><td><strong>最佳用途</strong></td><td><strong>JPA Entity (实体类)</strong></td><td><strong>DTO, VO, Config, Map Key</strong></td></tr></tbody></table><hr><h3 id="3-Switch-表达式-Switch-Expressions"><a href="#3-Switch-表达式-Switch-Expressions" class="headerlink" title="3. Switch 表达式 (Switch Expressions)"></a>3. Switch 表达式 (Switch Expressions)</h3><blockquote><p><strong>解决痛点</strong>：旧的 switch 语法繁琐，容易漏写 <code>break</code> 导致 bug，且不能直接作为返回值赋值给变量。</p></blockquote><ul><li><strong>Java 12&#x2F;14 引入</strong></li><li>支持 <code>-&gt;</code> 箭头语法，无需 <code>break</code>。</li></ul><p><strong>Java 8 写法：</strong></p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String day = &quot;MONDAY&quot;;</span><br><span class="line">int num;</span><br><span class="line">switch (day) &#123;</span><br><span class="line">    case &quot;MONDAY&quot;:</span><br><span class="line">    case &quot;FRIDAY&quot;:</span><br><span class="line">    case &quot;SUNDAY&quot;:</span><br><span class="line">        num = 6;</span><br><span class="line">        break;</span><br><span class="line">    case &quot;TUESDAY&quot;:</span><br><span class="line">        num = 7;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        num = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java 17 写法：</strong></p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 直接返回值，逻辑清晰，无 break</span><br><span class="line">int num = switch (day) &#123;</span><br><span class="line">    case &quot;MONDAY&quot;, &quot;FRIDAY&quot;, &quot;SUNDAY&quot; -&gt; 6;</span><br><span class="line">    case &quot;TUESDAY&quot; -&gt; 7;</span><br><span class="line">    default -&gt; 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="4-instanceof-模式匹配-Pattern-Matching-for-instanceof"><a href="#4-instanceof-模式匹配-Pattern-Matching-for-instanceof" class="headerlink" title="4. instanceof 模式匹配 (Pattern Matching for instanceof)"></a>4. instanceof 模式匹配 (Pattern Matching for instanceof)</h3><blockquote><p><strong>解决痛点</strong>：每次判断完 <code>instanceof</code>，还得强制类型转换一次，非常啰嗦。</p></blockquote><ul><li><strong>Java 14&#x2F;16 引入</strong></li></ul><p><strong>Java 8 写法：</strong></p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = &quot;Hello&quot;;</span><br><span class="line">if (obj instanceof String) &#123;</span><br><span class="line">    String s = (String) obj; // 必须强转</span><br><span class="line">    System.out.println(s.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java 17 写法：</strong></p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = &quot;Hello&quot;;</span><br><span class="line">// 如果是 String，直接转为变量 s，大括号内直接用</span><br><span class="line">if (obj instanceof String s) &#123;</span><br><span class="line">    System.out.println(s.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="其他重要更新-一句话带过"><a href="#其他重要更新-一句话带过" class="headerlink" title="其他重要更新 (一句话带过)"></a>其他重要更新 (一句话带过)</h3><ol><li><p><strong>var 关键字 (Java 10)</strong>：局部变量类型推断。</p><ul><li><code>var list = new ArrayList&lt;String&gt;();</code> （编译器自动推断 list 是 ArrayList 类型）。</li></ul></li><li><p><strong>密封类 Sealed Classes (Java 15&#x2F;17)</strong>：</p><ul><li>允许你控制<strong>谁可以继承我</strong>。</li><li><code>public sealed class Shape permits Circle, Square {}</code></li><li>这对于编写严谨的领域模型或框架非常有用。</li></ul></li><li><p><strong>更有用的 NullPointerException (Java 14)</strong>：</p><ul><li>以前只报 NPE，不告诉你是哪个对象空了。</li><li>现在会提示：<code>Cannot invoke &quot;String.length()&quot; because &quot;name&quot; is null</code>。</li></ul></li><li><p><strong>Stream.toList() (Java 16)</strong>：</p><ul><li>以前：<code>.collect(Collectors.toList())</code></li><li>现在：<code>.toList()</code> (注意：这个返回的是不可变 List)。</li></ul></li></ol><hr><h3 id="总结：为什么要升-Java-17？"><a href="#总结：为什么要升-Java-17？" class="headerlink" title="总结：为什么要升 Java 17？"></a>总结：为什么要升 Java 17？</h3><table><thead><tr><th><strong>特性</strong></th><th><strong>影响</strong></th></tr></thead><tbody><tr><td><strong>Record</strong></td><td><strong>干掉 DTO 样板代码</strong>，甚至可能不再需要 Lombok 的 <code>@Data</code>。</td></tr><tr><td><strong>Text Blocks</strong></td><td><strong>SQL&#x2F;JSON 拼接神器</strong>，代码可读性提升 10 倍。</td></tr><tr><td><strong>Switch 表达式</strong></td><td>逻辑更紧凑，减少 Bug。</td></tr><tr><td><strong>性能</strong></td><td>G1 垃圾回收器优化，以及 <strong>ZGC</strong> (低延迟 GC) 的成熟，应用吞吐量更高。</td></tr><tr><td><strong>Spring Boot 3</strong></td><td><strong>强制要求</strong> Java 17+。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC并发编程</title>
      <link href="/posts/eb9166f8.html"/>
      <url>/posts/eb9166f8.html</url>
      
        <content type="html"><![CDATA[<p>好的，阅读 JUC（Java Util Concurrent）源码是一项非常棒的学习任务，它能让你深入理解 Java 并发编程的精髓，以及 JVM 和操作系统层面的一些知识。JUC 包是 Java 并发编程的基石，包含了线程池、锁、原子操作、并发集合等核心组件。</p><p>下面为你列一个 JUC 源码学习的大纲，并提供一些学习建议：</p><hr><h3 id="JUC-源码学习大纲"><a href="#JUC-源码学习大纲" class="headerlink" title="JUC 源码学习大纲"></a>JUC 源码学习大纲</h3><p><strong>第一阶段：基础知识回顾与工具准备</strong></p><ol><li><strong>并发基础理论：</strong><ul><li><strong>可见性、原子性、有序性：</strong> 深入理解这三大特性及其在并发中的重要性。</li><li><strong>JMM (Java Memory Model)：</strong> 了解 Java 内存模型如何保证并发的正确性。</li><li><strong>Happens-Before 原则：</strong> 理解它如何定义操作之间的顺序。</li><li><strong>锁的原理：</strong> 了解悲观锁、乐观锁，以及自旋锁等概念。</li><li><strong>AQS (AbstractQueuedSynchronizer) 概述：</strong> 对 AQS 有一个初步的认识，它是 JUC 许多高级同步器的基石。</li><li><strong>CAS (Compare-And-Swap) 原理：</strong> 理解其三步操作和 ABA 问题。</li></ul></li><li><strong>Lombok 与 <code>@SneakyThrows</code>：</strong><ul><li>Lombok 在 JUC 源码中不常用，但如果你在其他项目中大量使用 Lombok，可以了解其原理。</li><li><code>@SneakyThrows</code>：理解其作用、优缺点及何时使用。</li></ul></li><li><strong>工具准备：</strong><ul><li><strong>IntelliJ IDEA：</strong> 最推荐的 IDE，其源码导航和调试功能非常强大。</li><li><strong>JAD 或 JD-GUI：</strong> 反编译工具，用于查看字节码（如果需要）。</li><li><strong>VisualVM 或 JProfiler：</strong> 性能分析工具，用于观察线程状态、锁竞争等（可选）。</li><li><strong>画图工具：</strong> 如 draw. Io, XMind, Excalidraw 等，用于绘制类图、状态转换图。</li></ul></li></ol><p><strong>第二阶段：核心原子操作与 CAS 深入</strong></p><ol><li><code>java.util.concurrent.atomic</code> 包：<ul><li><code>AtomicInteger</code>：<ul><li><strong>源码分析：</strong> 关注其核心方法 <code>compareAndSet()</code>。</li><li><strong>底层机制：</strong> 了解它如何利用 <code>Unsafe</code> 类的 CAS 操作（<code>compareAndSwapInt</code>）。</li><li><strong><code>volatile</code> 关键字：</strong> 理解它在这里的作用（保证可见性）。</li></ul></li><li><code>AtomicLong</code> &#x2F; <code>AtomicBoolean</code> &#x2F; <code>AtomicReference</code>：<ul><li>与 <code>AtomicInteger</code> 类似，重点理解 <code>AtomicReference</code> 如何实现对象引用的原子更新。</li></ul></li><li><code>AtomicStampedReference</code> &#x2F; <code>AtomicMarkableReference</code>：<ul><li><strong>源码分析：</strong> 重点理解它们如何通过版本号（或标记）解决 CAS 的 ABA 问题。</li><li><strong>使用场景：</strong> 何时需要考虑 ABA 问题。</li></ul></li><li><code>AtomicIntegerFieldUpdater</code> &#x2F; <code>AtomicLongFieldUpdater</code> &#x2F; <code>AtomicReferenceFieldUpdater</code>：<ul><li><strong>源码分析：</strong> 了解其工作原理（通过反射实现对指定对象的特定字段的原子更新）。</li><li><strong>使用限制：</strong> 为什么字段必须是 <code>volatile</code> 且不能是 <code>static</code> 或 <code>final</code>。</li></ul></li><li><code>LongAdder</code> &#x2F; <code>DoubleAdder</code> &#x2F; <code>LongAccumulator</code> &#x2F; <code>DoubleAccumulator</code> (Java 8+):<ul><li><strong>源码分析：</strong> 理解它们如何通过分段（cells）技术，将热点 CAS 竞争分散，提高高并发下的性能。</li><li><strong>与 <code>AtomicLong</code> 的对比：</strong> 性能优势和适用场景。</li></ul></li></ul></li></ol><p><strong>第三阶段：锁的实现基石 - AQS (AbstractQueuedSynchronizer)</strong></p><ol><li><p><strong>AQS 核心原理：</strong></p><ul><li><strong>内部状态（<code>state</code>）：</strong> 如何通过 <code>volatile int state</code> 表示同步状态。</li><li><strong>FIFO 双向队列：</strong> 理解等待线程如何封装成 <code>Node</code> 节点，并排队等待锁。</li><li>独占模式与共享模式：<ul><li><p>独占模式：</p><p> 如 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock</span><br></pre></td></tr></table></figure><p>。</p><ul><li><code>acquire()</code> &#x2F; <code>release()</code>：如何获取和释放锁。</li><li><code>tryAcquire()</code> &#x2F; <code>tryRelease()</code>：尝试获取&#x2F;释放，由子类实现。</li></ul></li><li><p>共享模式：</p><p> 如 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Semaphore</span><br></pre></td></tr></table></figure><p>、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch</span><br></pre></td></tr></table></figure><p>。</p><ul><li><code>acquireShared()</code> &#x2F; <code>releaseShared()</code>：如何获取和释放共享锁。</li><li><code>tryAcquireShared()</code> &#x2F; <code>tryReleaseShared()</code>：尝试获取&#x2F;释放，由子类实现。</li></ul></li></ul></li><li>条件变量 (<code>ConditionObject</code>)：<ul><li>理解 AQS 内部的条件队列，以及 <code>await()</code> &#x2F; <code>signal()</code> &#x2F; <code>signalAll()</code> 的实现。</li></ul></li></ul></li><li><p><strong>AQS 典型实现类：</strong></p><ul><li><code>ReentrantLock</code>：<ul><li><strong>源码分析：</strong> 重点看 <code>Sync</code> 抽象类 (<code>NonfairSync</code> 和 <code>FairSync</code>) 的实现。</li><li><strong>公平锁与非公平锁：</strong> 它们的区别和实现方式（AQS <code>tryAcquire</code> 的差异）。</li><li><strong>可重入性：</strong> 如何通过 <code>state</code> 计数和当前持有线程来管理。</li></ul></li><li><code>Semaphore</code> (信号量)：<ul><li><strong>源码分析：</strong> 理解它如何基于 AQS 的共享模式实现许可证计数。</li><li><strong><code>acquire()</code> &#x2F; <code>release()</code>：</strong> 它们如何与 AQS 的 <code>acquireShared</code> &#x2F; <code>releaseShared</code> 交互。</li></ul></li><li><code>CountDownLatch</code> (倒计时门闩)：<ul><li><strong>源码分析：</strong> 理解其 <code>count</code> 如何基于 AQS 的共享模式实现计数和等待。</li><li><strong><code>await()</code> &#x2F; <code>countDown()</code>：</strong> 它们如何与 AQS 的 <code>acquireShared</code> &#x2F; <code>releaseShared</code> 交互。</li></ul></li><li><code>CyclicBarrier</code> (循环屏障)：<ul><li><strong>源码分析：</strong> 它的实现相对复杂，结合了 ReentrantLock 和 Condition。</li><li><strong>与 <code>CountDownLatch</code> 的区别：</strong> 可重用性和等待所有线程到达。</li></ul></li><li><code>ReentrantReadWriteLock</code> (读写锁)：<ul><li><strong>源码分析：</strong> 核心是 <code>Sync</code> 类，如何利用一个 <code>state</code> 变量同时表示读锁和写锁（高 16 位和低 16 位）。</li><li><strong>读写分离：</strong> 读锁共享，写锁独占的实现细节。</li><li><strong>锁降级：</strong> 什么是锁降级，如何实现。</li></ul></li></ul></li></ol><p><strong>第四阶段：线程池 (Executor 框架)</strong></p><ol><li><strong><code>Executor</code> 接口层级：</strong><ul><li><code>Executor</code> -&gt; <code>ExecutorService</code> -&gt; <code>AbstractExecutorService</code> -&gt; <code>ThreadPoolExecutor</code>。</li><li><strong><code>Callable</code> 和 <code>Future</code>：</strong> 回顾它们与 <code>ExecutorService</code> 的关系。</li></ul></li><li><strong><code>ThreadPoolExecutor</code>：</strong><ul><li><strong>源码分析：</strong> JUC 中最复杂的类之一。</li><li><strong>核心参数：</strong> <code>corePoolSize</code>, <code>maximumPoolSize</code>, <code>keepAliveTime</code>, <code>TimeUnit</code>, <code>workQueue</code>, <code>ThreadFactory</code>, <code>RejectedExecutionHandler</code>。深入理解每个参数的作用。</li><li><strong>线程池状态：</strong> <code>RUNNING</code>, <code>SHUTDOWN</code>, <code>STOP</code>, <code>TIDYING</code>, <code>TERMINATED</code>。理解它们的转换。</li><li>任务提交流程 (<code>execute()</code> 方法)：<ul><li>如何根据核心线程数、阻塞队列、最大线程数来决定任务的处理方式（直接执行、入队、新建线程）。</li></ul></li><li>工作线程 (<code>Worker</code> 类)：<ul><li>如何复用线程，如何从队列中获取任务。</li><li>线程池的生命周期管理。</li></ul></li><li><strong>拒绝策略 (<code>RejectedExecutionHandler</code>)：</strong> 理解四种默认策略和自定义策略。</li><li><strong>常用的工厂方法 (<code>Executors</code>)：</strong> 理解 <code>newFixedThreadPool</code>, <code>newSingleThreadExecutor</code>, <code>newCachedThreadPool</code>, <code>newScheduledThreadPool</code> 的底层实现。</li></ul></li></ol><p><strong>第五阶段：并发集合</strong></p><ol><li><strong><code>ConcurrentHashMap</code>：</strong><ul><li><strong>源码分析：</strong> Java 7 (分段锁) 和 Java 8 (CAS + synchronized + 数组 + 链表&#x2F;红黑树) 的实现差异。重点关注 Java 8。</li><li>Java 8 实现：<ul><li><strong><code>Node</code> 数组 + 链表&#x2F;红黑树：</strong> 数据结构。</li><li><strong><code>volatile</code> + CAS：</strong> 如何保证读写可见性和原子性。</li><li><strong><code>synchronized</code>：</strong> 内部何时使用 <code>synchronized</code> (如 <code>put</code> 时的链表&#x2F;红黑树操作，<code>resize</code> 时的扩容)。</li><li><strong>扩容机制 (<code>transfer()</code> &#x2F; <code>helpTransfer()</code>):</strong> 多线程下的扩容如何实现。</li></ul></li><li><strong>与 <code>Hashtable</code> 和 <code>Collections.synchronizedMap</code> 的对比。</strong></li></ul></li><li><strong><code>ConcurrentLinkedQueue</code> (非阻塞队列)：</strong><ul><li><strong>源码分析：</strong> 重点理解其非阻塞的入队 (<code>offer()</code>) 和出队 (<code>poll()</code>) 操作如何基于 CAS 实现。</li><li><strong><code>head</code> 和 <code>tail</code> 指针：</strong> 如何维护。</li><li><strong>使用场景：</strong> 为什么它比基于锁的队列在高并发下性能更好。</li></ul></li><li><strong><code>BlockingQueue</code> 接口：</strong><ul><li><strong>理解其阻塞特性：</strong> <code>put()</code> 和 <code>take()</code> 方法。</li><li>典型实现类：<ul><li><strong><code>ArrayBlockingQueue</code>：</strong> 基于数组，有界，ReentrantLock + Condition 实现。</li><li><strong><code>LinkedBlockingQueue</code>：</strong> 基于链表，可选有界，两个 ReentrantLock + 两个 Condition 实现。</li><li><strong><code>SynchronousQueue</code>：</strong> 不存储元素的队列，直接将生产者和消费者配对。</li><li><strong><code>PriorityBlockingQueue</code>：</strong> 支持优先级的无界阻塞队列。</li><li><strong><code>DelayQueue</code>：</strong> 延迟队列。</li></ul></li></ul></li></ol><p><strong>第六阶段：CompletableFuture (Java 8)</strong></p><ol><li><code>CompletionStage</code> 接口：<ul><li><strong>理解其设计思想：</strong> 异步计算阶段，链式调用，非阻塞回调。</li><li><strong>核心方法分类：</strong> 转换、组合、异常处理等。</li></ul></li><li><code>CompletableFuture</code>：<ul><li><strong>源码分析：</strong> 理解它如何作为 <code>Future</code> 和 <code>CompletionStage</code> 的实现。</li><li><strong>异步工厂方法：</strong> <code>supplyAsync()</code>, <code>runAsync()</code>, <code>completedFuture()</code>, <code>failedFuture()</code>。</li><li><strong>回调方法：</strong> <code>thenApply()</code>, <code>thenAccept()</code>, <code>thenRun()</code>, <code>whenComplete()</code>。</li><li><strong>组合方法：</strong> <code>thenCompose()</code>, <code>thenCombine()</code>, <code>allOf()</code>, <code>anyOf()</code>。</li><li><strong>异常处理：</strong> <code>exceptionally()</code>, <code>handle()</code>。</li><li><strong>执行器 (Executor)：</strong> 理解其异步方法如何使用默认线程池或指定线程池。</li><li><strong>内部 <code>Completion</code> 链：</strong> 理解其回调如何通过内部 <code>Completion</code> 链表实现任务的级联执行。</li></ul></li></ol><hr><h3 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h3><ol><li><strong>从宏观到微观：</strong><ul><li>首先理解整个 JUC 模块的架构和每个组件的职责。</li><li>然后选择一个模块（如 <code>atomic</code> 包）深入，接着是 <code>AQS</code>，再到其实现类。</li><li>不要一开始就钻入细节，否则容易迷失。</li></ul></li><li><strong>带着问题去阅读：</strong><ul><li>这个类解决了什么问题？</li><li>它是如何保证线程安全的？</li><li>它是如何利用 CAS 或锁的？</li><li>它的核心数据结构是什么？</li><li>它的关键方法是如何实现的？</li><li>是否存在性能瓶颈，以及如何优化？</li></ul></li><li><strong>调试是最好的老师：</strong><ul><li>不要只看代码，要多使用 IntelliJ IDEA 的调试器。</li><li>设置断点，单步执行，观察变量（特别是 <code>state</code> 值、队列结构）的变化，这对于理解 AQS 等复杂机制至关重要。</li></ul></li><li><strong>画图辅助理解：</strong><ul><li>对于复杂的类（如 AQS、ConcurrentHashMap、ThreadPoolExecutor），尝试绘制它们的内部数据结构图（队列、数组、Node）和状态转换图。</li><li>UML 类图功能在 IntelliJ IDEA Ultimate 中非常有用。</li></ul></li><li><strong>对照官方文档和相关博客：</strong><ul><li>Java Doc 是最好的参考资料，它描述了每个类和方法的行为。</li><li>网上有很多优秀的 JUC 源码分析文章和视频，可以作为补充材料，但要带着批判性思维去阅读，以官方源码为准。</li></ul></li><li><strong>逐步实践：</strong><ul><li>阅读完一个模块后，尝试编写一些简单的示例代码来验证你的理解。</li><li>尝试重现一些并发问题，然后观察 JUC 组件如何解决它们。</li></ul></li><li><strong>循序渐进，持之以恒：</strong><ul><li>JUC 源码内容庞大且复杂，不要期望一口吃成胖子。</li><li>每天投入一定的时间，坚持下去，你会逐渐掌握其中的奥秘。</li></ul></li></ol><p>祝你学习顺利！这是一个非常有价值的挑战！</p><h1 id="CompletableFuture-异步编程首选"><a href="#CompletableFuture-异步编程首选" class="headerlink" title="CompletableFuture - 异步编程首选"></a>CompletableFuture - 异步编程首选</h1><ul><li>支持链式调用</li><li>支持非阻塞回调</li></ul><h1 id="Atomic-包"><a href="#Atomic-包" class="headerlink" title="Atomic 包"></a>Atomic 包</h1><p>提供了一系列原子操作的类，在高并发环境下实现无锁（Lock-free）的线程安全操作。</p><h3 id="atomic-包的核心思想：CAS-Compare-And-Swap"><a href="#atomic-包的核心思想：CAS-Compare-And-Swap" class="headerlink" title="atomic 包的核心思想：CAS (Compare-And-Swap)"></a><code>atomic</code> 包的核心思想：CAS (Compare-And-Swap)</h3><p><code>atomic</code> 包中的所有原子操作类都是基于 <strong>CAS（Compare-And-Swap）</strong> 这种硬件指令实现的。</p><p><strong>CAS 操作包含三个操作数：</strong></p><ol><li><strong>V (Value)</strong>：要更新的变量的内存位置。</li><li><strong>A (Expected)</strong>：期望的旧值。</li><li><strong>B (New)</strong>：要设置的新值。</li></ol><p><strong>CAS 的操作逻辑：</strong> 如果内存位置 V 的值等于期望的旧值 A，那么就将 V 的值更新为新值 B。否则，不做任何操作。无论更新成功还是失败，CAS 操作都会返回 V 的当前值（或者布尔值表示是否成功）。</p><p><strong>CAS 的缺点 (ABA 问题)：</strong> 如果一个值从 A 变成了 B，然后又变回了 A。当执行 CAS 操作时，发现当前值是 A，就会成功更新。但实际上，这个值已经被其他线程修改过了。</p><h3 id="ABA-问题解决方案："><a href="#ABA-问题解决方案：" class="headerlink" title="ABA 问题解决方案："></a><strong>ABA 问题解决方案</strong>：</h3><ul><li><p>使用 <code>AtomicMarkableReference</code>: 带版本号的原子引用。它不仅比较引用是否相同，还会比较版本号是否相同。这可以有效解决 ABA 问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> T reference;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> mark;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Pair</span><span class="params">(T reference, <span class="type">boolean</span> mark)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.reference = reference;</span><br><span class="line">        <span class="built_in">this</span>.mark = mark;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; Pair&lt;T&gt; <span class="title function_">of</span><span class="params">(T reference, <span class="type">boolean</span> mark)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>(reference, mark);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>AtomicStampedReference</code>: 引入 int 类型 stamp 变量，记录值的标记状态，适合更加复杂的场景</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> T reference;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> stamp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Pair</span><span class="params">(T reference, <span class="type">int</span> stamp)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.reference = reference;</span><br><span class="line">            <span class="built_in">this</span>.stamp = stamp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &lt;T&gt; Pair&lt;T&gt; <span class="title function_">of</span><span class="params">(T reference, <span class="type">int</span> stamp)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>(reference, stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="累加器（Accumulators）和加法器（Adders）"><a href="#累加器（Accumulators）和加法器（Adders）" class="headerlink" title="累加器（Accumulators）和加法器（Adders）"></a>累加器（Accumulators）和加法器（Adders）</h3><p>解决在大量线程更新同一个 <code>AtomicLong</code> 或 <code>AtomicInteger</code> 时，CAS 操作冲突严重导致性能下降的问题（热点问题）。</p><ul><li><strong><code>LongAdder</code></strong>: 专为高并发的 <code>long</code> 型计数设计。</li><li><strong><code>DoubleAdder</code></strong>: 专为高并发的 <code>double</code> 型计数设计。</li><li><strong><code>LongAccumulator</code></strong>: 泛化的 <code>LongAdder</code>，可以执行任意的二元操作，而不仅仅是加法。</li><li><strong><code>DoubleAccumulator</code></strong>: 泛化的 <code>DoubleAdder</code>。</li></ul><h1 id="Locks-包"><a href="#Locks-包" class="headerlink" title="Locks 包"></a>Locks 包</h1><h3 id="对比-Sychronzied-、Reentrantlock"><a href="#对比-Sychronzied-、Reentrantlock" class="headerlink" title="对比 Sychronzied 、Reentrantlock"></a>对比 Sychronzied 、Reentrantlock</h3><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>AQS 设计中涉及两种队列：</p><ol><li>同步队列：核心部分，管理尝试获取锁但失败的线程。</li><li>条件队列：与条件变量相关，支持 locks. Condition 接口的操作 -  await 和 signal 方法</li></ol><h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p>同步队列中每个节点代表一个等待锁的线程，按照 FIFO 的原则排列组织。</p><table><thead><tr><th>状态值</th><th>常量名</th><th>数值</th><th>应用场景</th></tr></thead><tbody><tr><td>等待唤醒</td><td><code>SIGNAL</code></td><td>-1</td><td>独占锁&#x2F;共享锁的同步队列，确保后继节点被唤醒</td></tr><tr><td>取消竞争</td><td><code>CANCELLED</code></td><td>1</td><td>线程因超时或中断放弃锁竞争</td></tr><tr><td>条件等待</td><td><code>CONDITION</code></td><td>-2</td><td>条件队列（如 <code>Condition.await()</code>）</td></tr><tr><td>传播释放</td><td><code>PROPAGATE</code></td><td>-3</td><td>共享模式下传递释放信号（如 <code>Semaphore</code>）</td></tr><tr><td>初始化&#x2F;未使用</td><td>默认状态</td><td>0</td><td>节点刚加入队列时的初始状态</td></tr></tbody></table><h3 id="条件队列"><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h3><p><strong>Await 方法</strong></p><blockquote><p>调用 Await 方法会释放当前线程持有的锁，并将该线程加入到条件队列中等待被唤醒</p></blockquote><ol><li><strong>必须先持有锁</strong>：调用 <code>await()</code> 前，线程必须已经成功获取了锁（即处于同步状态中），否则会抛出异常。</li><li><strong>释放锁</strong>：在进入等待之前，线程会<strong>完全释放它所持有的锁</strong>（注意是全部的重入次数）。</li><li><strong>构造节点并插入条件队列</strong>：线程会被封装成一个节点（Node），添加到对应的 <strong>条件队列</strong> 中。</li><li><strong>阻塞自己</strong>：线程进入等待状态，直到被其他线程通过 <code>signal()</code> 或 <code>signalAll()</code> 唤醒。</li><li><strong>重新竞争锁</strong>：当被唤醒后，线程需要重新去尝试获取锁（此时进入同步队列），只有成功获取锁之后才能从 <code>await()</code> 返回。</li></ol><p><strong>Signal 方法</strong></p><blockquote><p>调用 signal 方法，将一个等待在条件队列上线程加入到同步队列，让其准备参与锁的竞争</p></blockquote><ul><li><code>signal()</code> 会从条件队列中取出一个等待的节点（通常是头节点），将其<strong>转移到同步队列中</strong>。</li><li>转移完成后，如果同步队列中前驱节点的状态为 <code>SIGNAL</code>，那么这个刚转移过来的节点可能会被唤醒（具体由 AQS 调度决定）。</li><li>只有当这个线程重新获取到锁之后，它才会从 <code>await()</code> 返回继续执行。</li></ul><h1 id="JUC-包中核心组件"><a href="#JUC-包中核心组件" class="headerlink" title="JUC 包中核心组件"></a>JUC 包中核心组件</h1><p>以下是 JUC 包中核心组件的中文解析：</p><hr><h3 id="1-原子类-java-util-concurrent-atomic"><a href="#1-原子类-java-util-concurrent-atomic" class="headerlink" title="1. 原子类 (java.util.concurrent.atomic)"></a>1. 原子类 (<code>java.util.concurrent.atomic</code>)</h3><p>这些类提供了对单个变量进行<strong>线程安全</strong>操作的能力，而无需使用重量级的 <code>synchronized</code> 关键字。它们主要依赖于硬件级别的 <strong>CAS (Compare-And-Swap&#x2F;比较并交换)</strong> 算法来实现高性能。</p><ul><li><strong>常见类：</strong> <code>AtomicInteger</code>, <code>AtomicLong</code>, <code>AtomicReference</code>, <code>LongAdder</code> (高并发下性能优于 AtomicLong)。</li></ul><h3 id="2-锁机制-java-util-concurrent-locks"><a href="#2-锁机制-java-util-concurrent-locks" class="headerlink" title="2. 锁机制 (java.util.concurrent.locks)"></a>2. 锁机制 (<code>java.util.concurrent.locks</code>)</h3><p>提供了比 Java 内置的 <code>synchronized</code> 更加灵活的锁和等待机制。</p><ul><li><strong><code>ReentrantLock</code> (可重入锁)：</strong> 一种互斥锁，功能类似 <code>synchronized</code>，但功能更强大（支持公平锁&#x2F;非公平锁、可中断、可超时）。</li><li><strong><code>ReentrantReadWriteLock</code> (读写锁)：</strong> 允许多个读线程同时访问，但写线程独占。适合“读多写少”的场景。</li><li><strong><code>Condition</code>：</strong> 配合 Lock 使用，类似于 <code>Object</code> 的 <code>wait/notify</code>，可以实现更精细的线程等待与唤醒控制。</li></ul><h3 id="3-并发容器-Concurrent-Collections"><a href="#3-并发容器-Concurrent-Collections" class="headerlink" title="3. 并发容器 (Concurrent Collections)"></a>3. 并发容器 (Concurrent Collections)</h3><p>为多线程环境优化的集合类，解决了标准集合（如 <code>HashMap</code>, <code>ArrayList</code>）线程不安全的问题，性能优于使用 <code>Collections.synchronizedMap</code>。</p><ul><li><strong><code>ConcurrentHashMap</code>：</strong> 并发编程中最常用的 Map。早期版本使用分段锁，JDK 8 之后改为 CAS + <code>synchronized</code>，性能极高。</li><li><strong><code>CopyOnWriteArrayList</code>：</strong> 写入时复制。读操作无锁，写操作时复制新数组。适合“读多写极少”的场景。</li><li><strong><code>BlockingQueue</code> (阻塞队列)：</strong> 线程池的核心组件。当队列空时取元素会阻塞，满时存元素会阻塞（如 <code>ArrayBlockingQueue</code>, <code>LinkedBlockingQueue</code>）。</li></ul><h3 id="4-线程池-执行器框架-java-util-concurrent-Executor"><a href="#4-线程池-执行器框架-java-util-concurrent-Executor" class="headerlink" title="4. 线程池 &#x2F; 执行器框架 (java.util.concurrent.Executor)"></a>4. 线程池 &#x2F; 执行器框架 (<code>java.util.concurrent.Executor</code>)</h3><p>将任务的提交与执行解耦。在生产环境中，我们极少手动 <code>new Thread()</code>，而是使用线程池来管理线程生命周期，复用线程以降低开销。</p><ul><li><strong><code>ThreadPoolExecutor</code>：</strong> 线程池的核心实现类，包含核心线程数、最大线程数、拒绝策略等参数。</li><li><strong><code>Executors</code>：</strong> 创建线程池的工厂类（如 <code>newFixedThreadPool</code>），但通常建议手动创建 <code>ThreadPoolExecutor</code> 以避免 OOM 风险。</li><li><strong><code>Future</code> &amp; <code>Callable</code>：</strong> 相比 <code>Runnable</code>，它们允许线程有返回值并能抛出异常。</li></ul><h3 id="5-同步工具类-Synchronizers"><a href="#5-同步工具类-Synchronizers" class="headerlink" title="5. 同步工具类 (Synchronizers)"></a>5. 同步工具类 (Synchronizers)</h3><p>用于协调多个线程之间的同步控制。</p><ul><li><strong><code>CountDownLatch</code> (倒计时器)：</strong> 让一个或多个线程等待其他线程完成一组操作后再执行（一次性使用）。</li><li><strong><code>CyclicBarrier</code> (循环栅栏)：</strong> 让一组线程到达一个屏障（同步点）时被阻塞，直到最后一个线程到达屏障，大家才继续运行（可循环使用）。</li><li><strong><code>Semaphore</code> (信号量)：</strong> 控制同时访问特定资源的线程数量，常用于限流。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud</title>
      <link href="/posts/750d7523.html"/>
      <url>/posts/750d7523.html</url>
      
        <content type="html"><![CDATA[<p>Spring Cloud 是一个广泛用于构建微服务架构的框架集合，涵盖了服务发现、配置管理、负载均衡、熔断器、API 网关、消息总线等多个方面。以下是一个系统的 <strong>Spring Cloud 学习路线</strong>，适合初学者循序渐进地掌握其核心内容。</p><hr><h2 id="1-基础准备"><a href="#1-基础准备" class="headerlink" title="1. 基础准备"></a><strong>1. 基础准备</strong></h2><p>在学习 Spring Cloud 之前，需要打好以下基础：</p><ul><li><strong>Java 基础</strong>：熟悉 Java 编程语言，包括面向对象编程、集合框架、异常处理等。</li><li><strong>Spring Boot</strong>：Spring Cloud 基于 Spring Boot 构建，需掌握 Spring Boot 的核心概念，如自动配置、依赖注入、RESTful API 开发、Spring Data JPA 等。</li><li><strong>微服务架构</strong>：了解微服务的基本概念、优缺点，以及与传统单体应用的区别。</li><li><strong>HTTP 和 REST</strong>：掌握 HTTP 协议和 RESTful 服务设计原则。</li><li><strong>Maven 或 Gradle</strong>：熟悉项目构建工具，学会管理依赖和构建项目。</li></ul><hr><h2 id="2-Spring-Cloud-核心组件学习"><a href="#2-Spring-Cloud-核心组件学习" class="headerlink" title="2. Spring Cloud 核心组件学习"></a><strong>2. Spring Cloud 核心组件学习</strong></h2><p>Spring Cloud 由多个子项目组成，每个子项目解决微服务架构中的特定问题。以下是核心组件及其推荐的学习顺序：</p><h3 id="2-1-服务注册与发现"><a href="#2-1-服务注册与发现" class="headerlink" title="2.1 服务注册与发现"></a><strong>2.1 服务注册与发现</strong></h3><ul><li><strong>推荐组件</strong>：Eureka（Netflix OSS）或 Spring Cloud Alibaba Nacos  </li><li><strong>学习内容</strong>：<ul><li>理解服务注册与发现的作用。</li><li>搭建 Eureka Server 和 Eureka Client。</li><li>掌握服务注册、服务发现、健康检查等操作。</li><li>探索高可用配置。</li></ul></li><li><strong>实践</strong>：搭建一个 Eureka Server 和多个 Client，观察服务注册过程。</li></ul><h3 id="2-2-客户端负载均衡"><a href="#2-2-客户端负载均衡" class="headerlink" title="2.2 客户端负载均衡"></a><strong>2.2 客户端负载均衡</strong></h3><ul><li><strong>推荐组件</strong>：Ribbon（Netflix OSS）或 Spring Cloud LoadBalancer  </li><li><strong>学习内容</strong>：<ul><li>理解客户端负载均衡的原理。</li><li>集成 Ribbon 与 Eureka，实现服务调用时的负载均衡。</li><li>学习负载均衡策略（如轮询、随机）。</li></ul></li><li><strong>实践</strong>：在服务消费者中用 Ribbon 实现对提供者的负载均衡调用。</li></ul><h3 id="2-3-声明式服务调用"><a href="#2-3-声明式服务调用" class="headerlink" title="2.3 声明式服务调用"></a><strong>2.3 声明式服务调用</strong></h3><ul><li><strong>推荐组件</strong>：OpenFeign  </li><li><strong>学习内容</strong>：<ul><li>了解 OpenFeign 的作用和优势。</li><li>使用 OpenFeign 简化服务间的 HTTP 调用。</li><li>学习配置、拦截器和错误处理。</li></ul></li><li><strong>实践</strong>：用 OpenFeign 替换 RestTemplate 实现服务调用。</li></ul><h3 id="2-4-API-网关"><a href="#2-4-API-网关" class="headerlink" title="2.4 API 网关"></a><strong>2.4 API 网关</strong></h3><ul><li><strong>推荐组件</strong>：Spring Cloud Gateway 或 Zuul（Netflix OSS）  </li><li><strong>学习内容</strong>：<ul><li>理解 API 网关的作用（如路由、过滤）。</li><li>搭建 Spring Cloud Gateway，配置路由规则。</li><li>学习自定义过滤器和限流功能。</li></ul></li><li><strong>实践</strong>：创建一个 API 网关，路由多个微服务请求。</li></ul><h3 id="2-5-配置管理"><a href="#2-5-配置管理" class="headerlink" title="2.5 配置管理"></a><strong>2.5 配置管理</strong></h3><ul><li><strong>推荐组件</strong>：Spring Cloud Config 或 Spring Cloud Alibaba Nacos Config  </li><li><strong>学习内容</strong>：<ul><li>理解集中式配置管理的意义。</li><li>搭建 Config Server 和 Client。</li><li>学习动态刷新和版本管理。</li></ul></li><li><strong>实践</strong>：集中管理微服务配置并实现动态更新。</li></ul><h3 id="2-6-熔断与降级"><a href="#2-6-熔断与降级" class="headerlink" title="2.6 熔断与降级"></a><strong>2.6 熔断与降级</strong></h3><ul><li><strong>推荐组件</strong>：Hystrix（Netflix OSS）或 Resilience 4 j  </li><li><strong>学习内容</strong>：<ul><li>理解熔断器模式的作用。</li><li>集成 Hystrix 或 Resilience 4 j，实现降级和熔断。</li><li>学习 Hystrix Dashboard 监控。</li></ul></li><li><strong>实践</strong>：在服务调用中添加熔断逻辑，模拟故障场景。</li></ul><h3 id="2-7-分布式追踪"><a href="#2-7-分布式追踪" class="headerlink" title="2.7 分布式追踪"></a><strong>2.7 分布式追踪</strong></h3><ul><li><strong>推荐组件</strong>：Spring Cloud Sleuth + Zipkin  </li><li><strong>学习内容</strong>：<ul><li>理解分布式追踪的意义。</li><li>集成 Sleuth 生成追踪 ID。</li><li>搭建 Zipkin Server 查看调用链。</li></ul></li><li><strong>实践</strong>：在微服务中集成 Sleuth 和 Zipkin，观察调用链路。</li></ul><h3 id="2-8-消息驱动"><a href="#2-8-消息驱动" class="headerlink" title="2.8 消息驱动"></a><strong>2.8 消息驱动</strong></h3><ul><li><strong>推荐组件</strong>：Spring Cloud Stream 或 Spring Cloud Bus  </li><li><strong>学习内容</strong>：<ul><li>了解消息驱动的好处。</li><li>使用 Spring Cloud Stream 集成 RabbitMQ 或 Kafka。</li><li>学习 Spring Cloud Bus 实现配置广播。</li></ul></li><li><strong>实践</strong>：用 Spring Cloud Stream 实现异步通信。</li></ul><hr><h2 id="3-进阶主题"><a href="#3-进阶主题" class="headerlink" title="3. 进阶主题"></a><strong>3. 进阶主题</strong></h2><p>掌握核心组件后，可以深入以下主题：</p><ul><li><strong>服务安全</strong>：集成 Spring Security 和 OAuth 2 实现认证授权。</li><li><strong>容器化与部署</strong>：学习 Docker 和 Kubernetes，部署微服务。</li><li><strong>Spring Cloud Alibaba</strong>：探索 Nacos、Sentinel 等组件。</li><li><strong>微服务监控</strong>：使用 Prometheus 和 Grafana 监控服务。</li></ul><hr><h2 id="4-实践项目"><a href="#4-实践项目" class="headerlink" title="4. 实践项目"></a><strong>4. 实践项目</strong></h2><p>理论结合实践是关键，建议：</p><ul><li><strong>搭建完整项目</strong>：包含用户服务、订单服务等，集成核心组件。</li><li><strong>模拟故障</strong>：引入故障，测试熔断、追踪等机制。</li><li><strong>云部署</strong>：部署到 AWS 或阿里云，体验云原生应用。</li></ul><hr><h2 id="5-学习资源推荐"><a href="#5-学习资源推荐" class="headerlink" title="5. 学习资源推荐"></a><strong>5. 学习资源推荐</strong></h2><ul><li><strong>官方文档</strong>：Spring Cloud 官方文档。</li><li><strong>书籍</strong>：《Spring Cloud 微服务实战》。</li><li><strong>在线课程</strong>：Udemy、Coursera 的 Spring Cloud 课程。</li><li><strong>社区</strong>：Spring 官方博客、Stack Overflow。</li></ul><hr><h2 id="6-学习建议"><a href="#6-学习建议" class="headerlink" title="6. 学习建议"></a><strong>6. 学习建议</strong></h2><ul><li><strong>循序渐进</strong>：从 Spring Boot 开始，逐步学习各组件。</li><li><strong>多实践</strong>：通过代码加深理解。</li><li><strong>关注版本</strong>：确保 Spring Cloud 和 Spring Boot 版本兼容。</li></ul><p>通过这条路线，你可以系统掌握 Spring Cloud，构建健壮的微服务架构！</p><h2 id="Spring-Cloud-知识点"><a href="#Spring-Cloud-知识点" class="headerlink" title="Spring Cloud 知识点:"></a>Spring Cloud 知识点:</h2><ol><li><p><strong>服务注册与发现：</strong></p><ul><li><strong>Eureka：</strong> Spring Cloud Eureka 是一个用于服务注册和发现的服务器，实现了 Netflix 的 Eureka。</li><li><strong>Consul：</strong> Consul 是一个分布式服务发现和配置管理工具，Spring Cloud 可以通过 Consul 来实现服务注册与发现。</li></ul></li><li><p><strong>负载均衡：</strong></p><ul><li><strong>Ribbon：</strong> Spring Cloud Ribbon 是一个基于 HTTP 和 TCP 客户端的负载均衡器。</li><li><strong>LoadBalancer：</strong> Spring Cloud 提供了@LoadBalanced 注解，用于集成负载均衡功能。</li></ul></li><li><p><strong>配置管理：</strong></p><ul><li><strong>Config：</strong> Spring Cloud Config 用于集中管理应用程序的配置，支持从 Git 等外部源加载配置。</li><li><strong>Bus：</strong> Spring Cloud Bus 用于在分布式系统中传播事件，通常用于实时刷新配置。</li></ul></li><li><p><strong>熔断器：</strong></p><ul><li><strong>Hystrix：</strong> Spring Cloud Hystrix 是一种用于处理延迟和容错的库，它提供了断路器模式的实现。</li></ul></li><li><p><strong>服务网关：</strong></p><ul><li><strong>Zuul：</strong> Spring Cloud Zuul 是一个 API 网关，可以用于路由、过滤、加载均衡等。</li></ul></li><li><p><strong>分布式消息总线：</strong></p><ul><li><strong>Spring Cloud Stream：</strong> 用于构建消息驱动的微服务，提供了对多种消息中间件的支持。</li></ul></li><li><p><strong>分布式追踪：</strong></p><ul><li><strong>Zipkin：</strong> 用于分布式追踪的系统，可以用于解决微服务架构中的性能问题。</li></ul></li><li><p><strong>服务调用：</strong></p><ul><li><strong>Feign：</strong> Spring Cloud Feign 是一种声明式的 Web 服务客户端，简化了服务调用。</li></ul></li></ol><h2 id="Spring-Cloud-面试题"><a href="#Spring-Cloud-面试题" class="headerlink" title="Spring Cloud 面试题:"></a>Spring Cloud 面试题:</h2><ol><li><p><strong>什么是微服务架构，Spring Cloud 有哪些核心组件用于支持微服务？</strong></p><ul><li><strong>答案：</strong> 微服务架构是一种将应用程序拆分为一组小型、独立的服务的设计风格。Spring Cloud 的核心组件包括 Eureka、Ribbon、Config、Hystrix、Zuul 等。</li></ul></li><li><p><strong>什么是服务注册与发现，Spring Cloud 中的 Eureka 是如何工作的？</strong></p><ul><li><strong>答案：</strong> 服务注册与发现是一种机制，允许服务在运行时注册自己，并允许其他服务查找和发现可用的服务。Eureka 通过服务端和客户端的方式工作，服务注册到 Eureka 服务器，其他服务通过 Eureka 客户端查询可用的服务。</li></ul></li><li><p><strong>如何实现服务之间的负载均衡？</strong></p><ul><li><strong>答案：</strong> 可以使用 Spring Cloud Ribbon 实现客户端负载均衡，也可以通过 Spring Cloud 的@LoadBalanced 注解使 RestTemplate 具备负载均衡能力。</li></ul></li><li><p><strong>Spring Cloud Config 的作用是什么？如何实现动态刷新配置？</strong></p><ul><li><strong>答案：</strong> Spring Cloud Config 用于集中管理应用程序的配置。动态刷新配置可以通过 Spring Cloud Bus 配合消息中间件实现，当配置发生变化时，通过消息总线通知各个微服务。</li></ul></li><li><p><strong>什么是熔断器模式？Spring Cloud 中的 Hystrix 是如何工作的？</strong></p><ul><li><strong>答案：</strong> 熔断器模式是一种用于处理延迟和容错的设计模式。Hystrix 通过在服务调用链中引入熔断器，当服务出现问题时，可以迅速地返回一个降级的响应，避免级联故障。</li></ul></li><li><p><strong>Spring Cloud Zuul 有什么作用？</strong></p><ul><li><strong>答案：</strong> Spring Cloud Zuul 是一个 API 网关，可以用于路由、过滤、加载均衡等。它充当了所有微服务的入口，提供了集中的路由、认证、监控等功能。</li></ul></li><li><p><strong>什么是分布式追踪，Spring Cloud 中的 Zipkin 有什么作用？</strong></p><ul><li><strong>答案：</strong> 分布式追踪用于跟踪微服务架构中的请求流，以便在分布式系统中定位和解决性能问题。Zipkin 是一个用于分布式追踪的系统，可以用于查看请求在微服务之间的传递路径和延迟。</li></ul></li><li><p><strong>Spring Cloud Feign 是什么，有什么优势？</strong></p><ul><li><strong>答案：</strong> Spring Cloud Feign 是一种声明式的 Web 服务客户端，用于简化服务调用。通过使用 Feign，可以像调用本地方法一样调用远程服务，避免了手动处理 HTTP 请求的繁琐工作。</li></ul></li></ol><p>这些问题涵盖了 Spring Cloud 的核心概念和常用组件，帮助了解微服务架构以及如何使用 Spring Cloud 构建和管理微服务。在面试中，深入理解这些知识点并能够结合实际经验进行讨论是非常重要的。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC</title>
      <link href="/posts/2d0b435f.html"/>
      <url>/posts/2d0b435f.html</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC-工作原理"><a href="#SpringMVC-工作原理" class="headerlink" title="SpringMVC 工作原理"></a>SpringMVC 工作原理</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Spring MVC 框架作为 Java Web 应用程序开发中广泛采用的框架，以其分层和松耦合的架构而闻名。这种架构清晰地分离了表示层、持久层和控制层，使得开发人员能够独立地处理各个模块，并将其组合成专业的 Web 应用程序。遵循 MVC 标准开发的 Web 应用程序更易于扩展、更新和管理，因为松耦合的分层结构使得在特定层进行修改变得更加便捷 1。本报告旨在深入探讨 Spring MVC 框架内 HTTP 请求的完整生命周期，从客户端发起请求到最终响应返回，详细阐述其内部的工作原理。</p><h2 id="理解模型-视图-控制器（MVC）模式"><a href="#理解模型-视图-控制器（MVC）模式" class="headerlink" title="理解模型-视图-控制器（MVC）模式"></a>理解模型-视图-控制器（MVC）模式</h2><p>模型-视图-控制器（MVC）是一种广泛应用于软件工程中的架构模式，旨在分离应用程序的不同关注点，从而提高代码的可维护性和可重用性 3。在 MVC 模式中，应用程序被划分为三个核心组件：</p><ul><li><strong>模型（Model）：</strong> 模型负责封装应用程序的数据和业务逻辑 2。它是应用程序的核心，管理着数据的存储、检索和处理 4。模型独立于用户界面，当模型中的数据发生变化时，它会通知视图进行更新 4。</li><li><strong>视图（View）：</strong> 视图负责呈现模型中的数据，并将其转化为用户可以理解的格式，例如 HTML、JSON 等 2。视图是被动组件，它从模型中获取数据并进行显示，不包含任何业务逻辑 4。</li><li><strong>控制器（Controller）：</strong> 控制器充当模型和视图之间的中介 2。它接收用户的输入（通常来自浏览器），并根据输入调用模型来执行相应的业务逻辑 4。处理完成后，控制器会选择合适的视图来显示模型中的数据 4。</li></ul><p>Spring MVC 框架正是基于 MVC 设计模式构建的，它通过一个核心组件——DispatcherServlet（前端控制器）来管理整个请求处理流程 2。DispatcherServlet 接收所有传入的 HTTP 请求，并将其分发给适当的处理器进行处理，从而实现了 MVC 模式在 Web 应用程序中的应用 2。</p><h2 id="核心调度器-DispatcherServlet"><a href="#核心调度器-DispatcherServlet" class="headerlink" title="核心调度器 DispatcherServlet"></a>核心调度器 DispatcherServlet</h2><p>DispatcherServlet 在 Spring MVC 框架中扮演着前端控制器的关键角色，它负责拦截所有进入应用程序的 HTTP 请求 1。作为应用程序的唯一入口点，DispatcherServlet 并不直接处理请求，而是将请求的处理委派给其他组件，从而实现请求的统一管理和调度 5。</p><p>DispatcherServlet 的初始化和生命周期管理由 Web 服务器（如 Tomcat）负责。在基于 XML 的配置中，DispatcherServlet 通常在 <code>web.xml</code> 文件中声明和映射 1。对于基于 Java 的配置，则可以通过 <code>WebConfiguration</code> 类进行配置 1。为了确保在服务器启动时 DispatcherServlet 被初始化，通常会配置 <code>&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</code> 5。DispatcherServlet 拥有自己的 <code>WebApplicationContext</code>，它是根应用程序上下文的子上下文，这种层级结构有助于清晰地分离 Web 相关的 Bean 和应用程序范围内的 Bean 5。通过在 <code>web.xml</code> 中将 DispatcherServlet 的 servlet 映射配置为 <code>&quot;/&quot;</code>，可以使得所有发往应用程序的请求都由该 DispatcherServlet 处理 1。</p><h2 id="请求导航：请求处理流程"><a href="#请求导航：请求处理流程" class="headerlink" title="请求导航：请求处理流程"></a>请求导航：请求处理流程</h2><p>Spring MVC 框架处理 HTTP 请求的过程可以细分为以下几个关键步骤 1：</p><ol><li><strong>客户端请求：</strong> 用户在浏览器中输入 Web URL，发起对特定页面的请求 1。</li><li><strong>DispatcherServlet 拦截：</strong> 所有的客户端请求首先被前端控制器 DispatcherServlet 拦截 1。这一步标志着 Spring MVC 框架开始介入请求的处理过程 1。</li><li><strong>HandlerMapping：</strong> DispatcherServlet 使用 HandlerMapping 组件来查找与当前请求 URL 相匹配的控制器（Handler） 1。HandlerMapping 就像一个路由器，它根据请求的特征（如 URL）将请求导向负责处理它的特定控制器 1。</li><li><strong>控制器调用：</strong> 一旦找到合适的控制器，DispatcherServlet 就将请求分发给该控制器进行处理 1。</li><li><strong>控制器处理：</strong> 控制器接收到请求后，会执行相应的业务逻辑，与模型（负责业务逻辑和数据）进行交互，并准备好要展示给视图的数据 1。这是应用程序中处理特定请求的核心逻辑所在 1。</li><li><strong>ModelAndView 返回：</strong> 控制器处理完请求后，通常会返回一个 ModelAndView 对象。该对象包含了模型数据（需要展示的数据）以及视图的逻辑名称 1。ModelAndView 对象充当了数据和视图展示方式的载体 1。</li><li><strong>视图解析：</strong> DispatcherServlet 接收到 ModelAndView 对象后，会使用 ViewResolver 组件根据视图的逻辑名称来查找实际的视图实现（例如，一个 JSP 文件） 2。ViewResolver 的作用在于将抽象的视图名称与具体的视图技术连接起来，提供了框架的灵活性 4。</li><li><strong>视图渲染：</strong> DispatcherServlet 将模型数据传递给解析得到的视图进行渲染 1。视图使用模型中的数据生成最终的 HTML 响应，该响应将被发送回客户端 1。</li><li><strong>响应返回客户端：</strong> 最终，渲染后的视图作为 HTTP 响应返回给用户的浏览器，用户在浏览器中看到请求的结果 1。</li></ol><p><strong>Spring MVC 请求处理流程</strong></p><table><thead><tr><th><strong>步骤</strong></th><th><strong>涉及组件</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>1</td><td>客户端</td><td>用户发起 HTTP 请求。</td></tr><tr><td>2</td><td>DispatcherServlet</td><td>拦截所有进入应用程序的请求。</td></tr><tr><td>3</td><td>HandlerMapping</td><td>确定处理该请求的控制器。</td></tr><tr><td>4</td><td>控制器</td><td>接收并处理请求。</td></tr><tr><td>5</td><td>控制器</td><td>与模型交互，准备数据。</td></tr><tr><td>6</td><td>控制器</td><td>返回包含模型数据和视图逻辑名称的 ModelAndView 对象。</td></tr><tr><td>7</td><td>ViewResolver</td><td>将视图逻辑名称解析为实际的视图对象。</td></tr><tr><td>8</td><td>视图</td><td>使用模型数据渲染响应。</td></tr><tr><td>9</td><td>DispatcherServlet</td><td>将渲染后的响应返回给客户端。</td></tr></tbody></table><h2 id="将请求映射到处理器：HandlerMapping-的作用"><a href="#将请求映射到处理器：HandlerMapping-的作用" class="headerlink" title="将请求映射到处理器：HandlerMapping 的作用"></a>将请求映射到处理器：HandlerMapping 的作用</h2><p>HandlerMapping 接口定义了将请求映射到处理器对象的契约 13。Spring MVC 提供了多种 HandlerMapping 接口的实现，大致可以分为继承自 <code>AbstractHandlerMethodMapping</code> 和 <code>AbstractUrlHandlerMapping</code> 的两类 16。</p><p><code>RequestMappingHandlerMapping</code> 是最常用的实现，它将 <code>@Controller</code> 类中带有 <code>@RequestMapping</code> 注解的方法映射为请求处理器 13。在应用程序初始化阶段，<code>RequestMappingHandlerMapping</code> 会扫描带有 <code>@Controller</code> 和 <code>@RequestMapping</code> 注解的类，并根据这些注解构建请求映射 2。它使用 <code>RequestMappingInfo</code> 对象来表示映射关系，该对象封装了请求匹配的各种条件，如路径、请求头、参数、HTTP 方法和媒体类型 16。<code>getMappingForMethod</code> 方法负责根据处理器方法上的 <code>@RequestMapping</code> 注解创建 <code>RequestMappingInfo</code> 对象 16。<code>@RequestMapping</code> 注解提供了一种灵活且声明式的方式，可以根据多种条件将特定的 HTTP 请求映射到控制器方法 2。</p><p><code>BeanNameUrlHandlerMapping</code> 是默认的 <code>HandlerMapping</code> 实现，它将 URL 路径映射到与 URL 路径同名的 Bean（Bean 的名称以 “&#x2F;“ 开头） 13。它支持直接名称匹配和使用 “*” 进行的模式匹配 13。这种方式提供了一种基于约定的映射方法，Bean 的名称直接对应于 URL 路径 13。</p><p><code>SimpleUrlHandlerMapping</code> 允许通过 Spring 配置中的 <code>Properties</code> 对象或 <code>Map</code> 显式地配置 URL 到处理器的映射（处理器可以是 Bean 实例或 Bean 名称） 13。这种方式提供了一种更具声明性的方式在配置文件中定义映射规则，为复杂的路由场景提供了灵活性 13。</p><p><code>@RequestMapping</code> 以及其他派生注解（如 <code>@GetMapping</code>、<code>@PostMapping</code> 等）简化了在控制器类中定义请求映射的过程 2。这些注解使得代码更易读和维护 2。</p><p>HandlerMapping 最终会返回一个 <code>HandlerExecutionChain</code> 对象，该对象包含了找到的处理器以及一个有序的拦截器列表 14。<code>HandlerExecutionChain</code> 允许在主要处理器执行前后执行拦截器，从而实现横切关注点的处理 14。可以使用 <code>order</code> 属性来设置不同 HandlerMapping 实现的优先级 13。</p><p><strong>常见的 HandlerMapping 实现</strong></p><table><thead><tr><th><strong>HandlerMapping 实现</strong></th><th><strong>描述</strong></th><th><strong>主要注解&#x2F;配置</strong></th></tr></thead><tbody><tr><td><code>RequestMappingHandlerMapping</code></td><td>将请求映射到带有 <code>@RequestMapping</code> 注解的控制器方法。</td><td><code>@Controller</code>, <code>@RequestMapping</code>, <code>@GetMapping</code>, <code>@PostMapping</code> 等。</td></tr><tr><td><code>BeanNameUrlHandlerMapping</code></td><td>将 URL 映射到名称以 “&#x2F;“ 开头的同名 Bean。</td><td>Bean 的名称作为 URL 路径。</td></tr><tr><td><code>SimpleUrlHandlerMapping</code></td><td>通过配置显式地将 URL 映射到处理器 Bean 或 Bean 名称。</td><td>Spring 配置文件中的属性或 Map。</td></tr></tbody></table><h2 id="执行业务逻辑：控制器处理"><a href="#执行业务逻辑：控制器处理" class="headerlink" title="执行业务逻辑：控制器处理"></a>执行业务逻辑：控制器处理</h2><p>DispatcherServlet 在确定了合适的控制器后，会将请求分发给该控制器进行处理 1。控制器中的方法会根据请求的 HTTP 方法（如 GET、POST 等）执行相应的业务逻辑 1。控制器通常会定义处理特定 HTTP 方法的方法，确保应用程序能够对不同类型的请求做出适当的响应 1。</p><p>在控制器方法执行过程中，Spring MVC 提供了灵活的参数解析和数据绑定机制 10。Spring MVC 允许使用任何对象作为命令或表单对象，而无需实现框架特定的接口 25。<code>@RequestParam</code> 注解用于将查询参数或表单数据映射到方法参数，尤其适用于基本数据类型 28。使用 <code>@RequestParam</code> 可以简化在控制器方法签名中直接访问请求参数的过程 28。数据绑定机制能够根据参数名称和类型自动将请求数据转换为 Java 对象 28。Spring 的数据绑定机制简化了将 HTTP 请求数据转换为可用的 Java 对象的过程，减少了样板代码 28。<code>@ModelAttribute</code> 注解可用于将请求参数绑定到方法参数或方法返回值，并将其作为命名的模型属性暴露给视图 21。<code>@ModelAttribute</code> 有助于实现双向数据绑定，方便表单数据与模型对象之间的映射 21。<code>DataBinder</code> 类支持构造器绑定和属性绑定，用于使用请求数据填充对象 27。较新版本的 Spring 中引入的构造器绑定提供了一种更安全的方式，通过调用构造函数并传入请求数据来绑定预期的参数 29。数据绑定过程中发生的类型不匹配会被视为验证错误，从而允许在应用程序层面进行处理 25。Spring 灵活的数据绑定能够优雅地处理常见的错误，使得开发者可以向用户提供有用的反馈 25。较新版本的 Spring 还支持直接在控制器方法参数上使用 <code>@Constraint</code> 注解进行方法验证，不再需要在类级别使用 <code>@Validated</code> 27。内置的方法验证简化了控制器方法中输入参数的验证过程，提高了代码的清晰度并减少了手动编写验证逻辑的需求 27。</p><h2 id="传递数据和视图信息：ModelAndView"><a href="#传递数据和视图信息：ModelAndView" class="headerlink" title="传递数据和视图信息：ModelAndView"></a>传递数据和视图信息：ModelAndView</h2><p>ModelAndView 对象是一个容器，它同时持有模型数据和要渲染的视图的名称 1。控制器在处理完请求后，通常会创建并返回 ModelAndView 对象 1。模型数据以键值对的形式存储在 Map 中，键是属性名称，值是要在视图中显示的数据 1。视图名称是一个逻辑标识符，ViewResolver 会将其解析为实际的视图技术 1。</p><p>控制器使用 ModelAndView 对象来同时返回模型数据和视图的逻辑名称 1。ModelAndView 对象可以通过构造函数传入视图名称，然后添加模型属性，也可以先创建一个空的 ModelAndView 对象，再分别设置模型属性和视图名称 17。它为控制器提供了一种便捷的方式来传递响应所需的数据以及指示应该使用哪个视图来呈现响应 1。</p><p>除了使用 ModelAndView，还有其他方式可以将模型数据传递给视图，例如将 <code>Model</code> 或 <code>ModelMap</code> 作为方法参数 17。<code>Model</code> 和 <code>ModelMap</code> 是用于向视图传递数据的接口&#x2F;类，它们由 Spring 直接注入到控制器方法中 17。当使用 <code>Model</code> 或 <code>ModelMap</code> 时，控制器方法通常只返回视图的逻辑名称作为字符串 17。Spring 提供了多种向视图传递数据的方式，开发者可以根据控制器的需求和偏好选择最合适的方法 17。</p><h2 id="解析视图：ViewResolver-的功能"><a href="#解析视图：ViewResolver-的功能" class="headerlink" title="解析视图：ViewResolver 的功能"></a>解析视图：ViewResolver 的功能</h2><p>ViewResolver 接口负责将控制器返回的视图逻辑名称映射到实际的 View 对象 2。它使得在浏览器中渲染模型数据成为可能，而无需将实现绑定到特定的视图技术 21。ViewResolver 接口定义了 <code>resolveViewName(String viewName, Locale locale)</code> 方法 23。</p><p><code>InternalResourceViewResolver</code> 用于将视图名称解析为内部资源，如位于 <code>WEB-INF</code> 目录下的 JSP 文件 21。它通过配置前缀（例如 <code>/WEB-INF/views/</code>）和后缀（例如 <code>.jsp</code>）来定位视图文件 22。此解析器常用于使用 JSP 作为视图技术的传统 Java Web 应用程序 21。</p><p><code>XmlViewResolver</code> 使用在 XML 文件中定义的视图 Bean 定义来解析视图名称 21。它允许配置具有特定类（例如 <code>JstlView</code>）和 URL 的视图 Bean 21。这种方式提供了一种配置驱动的视图解析方法，允许在同一应用程序中使用不同的视图技术 21。</p><p><code>ResourceBundleViewResolver</code> 使用属性文件来解析视图名称，视图配置在属性文件中以键值对的形式定义 21。此解析器适用于以更外部化的方式管理视图配置，可能有助于国际化或特定于环境的设置 21。</p><p>还有其他常用的解析器，如用于 Velocity 模板的 <code>VelocityViewResolver</code> 和用于 FreeMarker 模板的 <code>FreeMarkerViewResolver</code> 7。Spring MVC 支持与各种流行的模板引擎集成，为开发者提供了广泛的视图层选择 7。</p><p>Spring MVC 支持配置多个视图解析器，并使用 <code>setOrder()</code> 方法设置它们的优先级 21。通过配置具有特定顺序的多个视图解析器，Spring 可以尝试不同的解析器，直到找到匹配的视图，从而允许在同一应用程序中基于视图名称模式使用不同的视图技术 21。</p><p><strong>常见的 ViewResolver 实现</strong></p><table><thead><tr><th><strong>ViewResolver 实现</strong></th><th><strong>描述</strong></th><th><strong>典型配置</strong></th></tr></thead><tbody><tr><td><code>InternalResourceViewResolver</code></td><td>将视图名称解析为内部资源（如 JSP 文件）。</td><td>配置前缀（如 <code>/WEB-INF/views/</code>）和后缀（如 <code>.jsp</code>）。</td></tr><tr><td><code>XmlViewResolver</code></td><td>使用在 XML 文件中定义的视图 Bean 来解析视图名称。</td><td>配置包含视图 Bean 定义的 XML 文件路径。</td></tr><tr><td><code>ResourceBundleViewResolver</code></td><td>使用属性文件中的配置来解析视图名称。</td><td>配置属性文件的基本名称。</td></tr><tr><td><code>VelocityViewResolver</code></td><td>将视图名称解析为 Velocity 模板。</td><td>配置 Velocity 模板的路径和后缀。</td></tr><tr><td><code>FreeMarkerViewResolver</code></td><td>将视图名称解析为 FreeMarker 模板。</td><td>配置 FreeMarker 模板的路径和后缀。</td></tr></tbody></table><h2 id="渲染响应：视图组件"><a href="#渲染响应：视图组件" class="headerlink" title="渲染响应：视图组件"></a>渲染响应：视图组件</h2><p>选定的视图负责渲染模型数据，生成最终的响应 1。视图接收模型数据（通过 <code>Model</code>、<code>ModelMap</code> 或 <code>ModelAndView</code> 添加的属性），并将其与视图模板合并 1。不同的视图技术（JSP、Thymeleaf、FreeMarker 等）有各自的语法和机制来访问模板中的模型数据 1。例如，在 JSP 中，通常使用表达式语言（EL），如 <code>${attributeName}</code> 17。渲染过程最终会生成 HTML（或其他内容类型），并作为响应发送回客户端的浏览器 1。</p><p>Spring MVC 支持多种视图技术及其集成 1。JSP（JavaServer Pages）是一种传统的视图技术，Spring MVC 对其提供了良好的支持 1。Thymeleaf 是一种现代的服务器端 Java 模板引擎，它提供了自然的模板 5。FreeMarker 和 Velocity 是其他可以与 Spring MVC 集成的模板引擎 7。此外，Spring MVC 还支持将视图渲染为 JSON 或 XML 格式，用于构建 RESTful API 4。Spring MVC 在视图层面的灵活性使其能够适应各种 Web 应用程序和 API 的构建需求 4。</p><h2 id="拦截请求：使用-HandlerInterceptor"><a href="#拦截请求：使用-HandlerInterceptor" class="headerlink" title="拦截请求：使用 HandlerInterceptor"></a>拦截请求：使用 HandlerInterceptor</h2><p>HandlerInterceptor 接口允许在请求到达处理器之前（<code>preHandle</code>）、处理器执行之后但在视图渲染之前（<code>postHandle</code>）、以及整个请求完成之后（<code>afterCompletion</code>）对请求进行拦截和处理 13。</p><ul><li><code>preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</code> 方法在处理器执行之前被调用；返回 <code>true</code> 以继续处理，返回 <code>false</code> 则停止处理 19。此方法常用于执行身份验证、授权检查和日志记录等操作，这些操作需要在主要的请求处理逻辑之前完成 19。</li><li><code>postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</code> 方法在处理器成功执行之后但在视图渲染之前被调用；可以修改 ModelAndView 对象 19。这允许根据处理器执行的结果修改模型或视图，例如添加通用属性或更改视图名称 19。</li><li><code>afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</code> 方法在整个请求处理完成之后被调用，无论处理成功与否；常用于执行清理任务和记录日志 19。即使在请求处理过程中发生错误，此方法也能确保必要的清理操作或最终的日志记录语句得到执行 19。</li></ul><p>HandlerInterceptor 的常见用例包括记录请求详细信息和响应时间 19、实现身份验证和授权检查以保护应用程序资源 19、通过记录请求开始和结束时间来执行性能监控 19 以及修改请求或响应头 19。</p><p>HandlerInterceptor 需要在 Spring MVC 框架中注册才能在请求处理生命周期中被调用 19。通常通过实现 <code>WebMvcConfigurer</code> 接口并覆盖 <code>addInterceptors</code> 方法来配置 HandlerInterceptor 19。</p><p><strong>HandlerInterceptor 方法</strong></p><table><thead><tr><th><strong>方法名称</strong></th><th><strong>调用时机</strong></th><th><strong>主要目的</strong></th><th><strong>返回值&#x2F;参数</strong></th></tr></thead><tbody><tr><td><code>preHandle</code></td><td>在处理器执行之前</td><td>执行预处理，如身份验证、授权、日志记录等；可以决定是否继续处理请求。</td><td><code>boolean</code> (true 继续，false 停止)；<code>HttpServletRequest</code>, <code>HttpServletResponse</code>, <code>Object handler</code></td></tr><tr><td><code>postHandle</code></td><td>在处理器执行之后，视图渲染之前</td><td>修改 ModelAndView 对象，添加额外的模型属性或修改视图名称。</td><td><code>void</code>；<code>HttpServletRequest</code>, <code>HttpServletResponse</code>, <code>Object handler</code>, <code>ModelAndView modelAndView</code></td></tr><tr><td><code>afterCompletion</code></td><td>在整个请求处理完成之后</td><td>执行清理任务，如释放资源、记录请求完成时间、处理异常等。</td><td><code>void</code>；<code>HttpServletRequest</code>, <code>HttpServletResponse</code>, <code>Object handler</code>, <code>Exception ex</code> (可选)</td></tr></tbody></table><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Spring MVC 框架的工作原理围绕着中央调度器 DispatcherServlet 展开，它与 HandlerMapping、Controller、ModelAndView、ViewResolver 和 View 等组件协同工作，共同处理客户端发起的 Web 请求。DispatcherServlet 接收所有请求，HandlerMapping 负责将请求映射到合适的控制器，控制器处理业务逻辑并返回包含模型数据和视图名称的 ModelAndView 对象，ViewResolver 将视图名称解析为实际的视图，最后视图使用模型数据渲染响应并返回给客户端。HandlerInterceptor 则提供了在请求处理的不同阶段进行拦截和处理的能力。</p><p>使用 Spring MVC 框架具有诸多优势。首先，MVC 模式实现了清晰的关注点分离 2。其次，组件之间的松耦合使得应用程序更易于维护和测试 1。框架提供了高度的灵活性和可扩展性，这得益于其可配置的组件和接口 1。Spring MVC 支持各种视图技术 2，并提供了强大的数据绑定和验证机制 25。通过 HandlerInterceptor，可以方便地实现面向切面的功能 19。此外，Spring MVC 还与 Spring 框架的其他功能（如依赖注入和 AOP）无缝集成 3，并有助于快速应用程序开发 2。这些特性使得 Spring MVC 成为构建健壮、可维护和可扩展的 Java Web 应用程序的首选框架之一。</p><h1 id="Spring-MVC-面试题"><a href="#Spring-MVC-面试题" class="headerlink" title="Spring MVC 面试题:"></a>Spring MVC 面试题:</h1><p><strong>什么是 Spring MVC 框架？</strong></p><ul><li><strong>答案：</strong> Spring MVC 是基于模型-视图-控制器（MVC）设计模式的 Web 框架，用于构建 Web 应用程序。</li></ul><p><strong>Spring MVC 的工作原理是什么？</strong></p><ul><li><strong>答案：</strong> 客户端请求由前端控制器（DispatcherServlet）处理，然后通过处理器映射器（HandlerMapping）找到相应的控制器，控制器处理请求并返回模型和视图。</li></ul><p><strong>Spring MVC 中的控制器是如何工作的？</strong></p><ul><li><strong>答案：</strong> 控制器接收并处理客户端请求，然后返回一个包含模型数据的逻辑视图名称。</li></ul><p><strong>Spring MVC 的核心组件有哪些？</strong></p><ul><li><strong>答案：</strong> 包括 DispatcherServlet、Controller、HandlerMapping、ViewResolver 等。</li></ul><p><strong>解释一下 Spring MVC 中的 DispatcherServlet。</strong></p><ul><li><strong>答案：</strong> DispatcherServlet 是 Spring MVC 的前端控制器，负责接收并分发客户端的请求。</li></ul><p><strong>Spring MVC 中的 Model、View、Controller 是什么？</strong></p><ul><li><strong>答案：</strong> Model 用于封装数据，View 负责展示数据，Controller 处理用户请求并返回适当的模型和视图。</li></ul><p> <strong>如何处理表单提交和参数绑定？</strong></p><ul><li><strong>答案：</strong> 使用@ModelAttribute 注解进行参数绑定，使用<a href="form:form">form:form</a>标签处理表单提交。</li></ul><p><strong>Spring MVC 中的拦截器是什么，有什么作用？</strong></p><ul><li><strong>答案：</strong> 拦截器用于在请求处理前或处理后执行一些额外的逻辑，例如身份验证、日志记录等。</li></ul><p><strong>什么是 RESTful Web 服务，Spring MVC 如何支持 RESTful 风格？</strong></p><ul><li><strong>答案：</strong> RESTful 是一种 Web 服务设计风格，Spring MVC 通过注解（@RequestMapping）和 HTTP 方法来支持 RESTful 风格。</li></ul><p><strong>Spring MVC 中的@ModelAttribute 和@SessionAttributes 有什么区别？</strong><br>    - <strong>答案：</strong> @ModelAttribute 用于绑定请求参数到模型中，@SessionAttributes 用于将模型中的属性暂时存储在会话中。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 过滤器</title>
      <link href="/posts/fed01c2.html"/>
      <url>/posts/fed01c2.html</url>
      
        <content type="html"><![CDATA[<h2 id="Filter-和-Interceptor"><a href="#Filter-和-Interceptor" class="headerlink" title="Filter 和 Interceptor"></a>Filter 和 Interceptor</h2><h3 id="Filter-过滤器"><a href="#Filter-过滤器" class="headerlink" title="Filter 过滤器"></a>Filter 过滤器</h3><ul><li>Servlet 容器维度的，拦截 Servlet 的请求。</li><li>通过 <code>Filter</code> 接口实现的</li></ul><p>Servlet 容器： Tomcat、Jetty。遵循 Java Servlet 规范，通常包括 HTTP 服务器，处理 web 请求和响应。</p><h3 id="Interceptor-拦截器"><a href="#Interceptor-拦截器" class="headerlink" title="Interceptor 拦截器"></a>Interceptor 拦截器</h3><ul><li>Spring 容器维度的，对 Spring MVC 的请求进行拦截。</li><li>通过实现 <code>HandlerInterceptor</code> 接口实现的，并通过 Spring 的配置进行注册。</li></ul><h4 id="PS："><a href="#PS：" class="headerlink" title="PS："></a>PS：</h4><p>Spring 框架嵌入到 Servlet 容器中，利用 spring 容器管理应用程序中的其他组件:</p><ul><li><strong>Spring Beans：</strong> 在 Spring 框架中，你可以定义和配置各种 Bean，包括业务逻辑组件、数据访问组件、服务等。这些 Bean 的生命周期、依赖关系等都由 Spring 容器管理。</li><li><strong>Service 层和业务逻辑：</strong> 你可以使用 Spring 来管理业务逻辑层的组件，使其成为 Spring 容器管理的 Bean。这些业务逻辑组件通常包括服务层的实现，处理业务逻辑、事务管理等。</li><li><strong>数据访问组件：</strong> Spring 框架提供了对数据访问的支持，包括整合 Hibernate、MyBatis 等持久化框架。你可以将数据访问组件配置为 Spring Bean，并由 Spring 容器进行管理。</li><li><strong>事务管理：</strong> Spring 容器可以管理应用程序中的事务，确保事务的一致性和隔离性。通过将事务管理配置为 Spring Bean，可以轻松地进行声明性事务管理。</li><li><strong>AOP（面向切面编程）：</strong> Spring 框架提供 AOP 的支持，你可以将切面配置为 Spring Bean，以实现横切关注点的模块化管理。</li><li><strong>配置信息：</strong> Spring 容器可以管理应用程序的配置信息，通过将配置文件解析为 Spring Bean，实现配置的集中化管理。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/posts/b7e144d1.html"/>
      <url>/posts/b7e144d1.html</url>
      
        <content type="html"><![CDATA[<h2 id="刷题方案"><a href="#刷题方案" class="headerlink" title="刷题方案"></a>刷题方案</h2><p>作为一个以 <strong>Java 后台开发</strong> 为职业目标的初学者，你的刷题策略不能仅仅是“解出题目”，更需要体现出你对 Java 语言特性的理解以及良好的工程素养。</p><p>以下是为你定制的最佳刷题方案和语言建议：</p><hr><h3 id="一、-核心问题：选什么语言？"><a href="#一、-核心问题：选什么语言？" class="headerlink" title="一、 核心问题：选什么语言？"></a>一、 核心问题：选什么语言？</h3><p><strong>结论：毫无疑问，必须用 Java。</strong></p><p>虽然 Python 代码更短，C++ 运行更快，但对于面试 <strong>Java 后台</strong> 岗位，使用 Java 刷题有巨大的战略优势：</p><ol><li><strong>证明熟练度：</strong> 面试官会考察你对 Java API 的熟悉程度（例如 <code>ArrayList</code> vs <code>LinkedList</code>，<code>HashMap</code> 的使用，<code>PriorityQueue</code> 的自定义排序等）。</li><li><strong>避免认知割裂：</strong> 你的项目是 Java 写的，八股文背的是 JVM 和 JUC，如果算法用 Python 写，面试时需要在两种思维模式间切换，容易出错。</li><li><strong>源码追问：</strong> 面试官经常会在你写完算法后，指着你用到的某个类问底层实现（比如：“你这里用了 <code>HashMap</code>，能讲讲它的扩容机制吗？”）。如果你用 Java 写，这种过渡非常自然。</li></ol><hr><h3 id="二、-最佳刷题路线图-分阶段执行"><a href="#二、-最佳刷题路线图-分阶段执行" class="headerlink" title="二、 最佳刷题路线图 (分阶段执行)"></a>二、 最佳刷题路线图 (分阶段执行)</h3><p>不要一上来就从 LeetCode 第 1 题开始做，那是效率最低的方法。建议按照 <strong>“知识点分类 + 高频题优先”</strong> 的策略。</p><h4 id="第一阶段：夯实地基-2-3-周"><a href="#第一阶段：夯实地基-2-3-周" class="headerlink" title="第一阶段：夯实地基 (2-3 周)"></a>第一阶段：夯实地基 (2-3 周)</h4><p>目标： 熟悉 Java 常用集合类的 API，掌握基本数据结构。</p><p>重点： 数组 (Array)、链表 (Linked List)、哈希表 (HashMap)。</p><ul><li><strong>必做动作：</strong> 不要在 IDE (IntelliJ IDEA) 里写代码，尝试在网页编辑器里写，习惯没有代码补全的环境。</li><li><strong>Java 关键点：</strong><ul><li>熟练掌握 <code>String</code> 和 <code>StringBuilder</code> 的转换。</li><li>熟练掌握 <code>List</code> 转 <code>Array</code>，<code>Array</code> 转 <code>List</code>。</li><li>理解 <code>==</code> 和 <code>.equals()</code> 在处理对象时的区别。</li></ul></li></ul><h4 id="第二阶段：专题突破-1-2-个月"><a href="#第二阶段：专题突破-1-2-个月" class="headerlink" title="第二阶段：专题突破 (1-2 个月)"></a>第二阶段：专题突破 (1-2 个月)</h4><p>目标： 掌握面试中最常见的算法模式（Pattern）。</p><p>策略： 按标签刷题。不要今天做一道数组，明天做一道动态规划。</p><p>推荐顺序及经典题（括号内为 LeetCode 题号）：</p><ol><li><p><strong>双指针 (Two Pointers):</strong> 解决数组、链表问题。</p><ul><li><em>例题：</em> 两数之和 (1), 移动零 (283), 环形链表 (141)。</li></ul></li><li><p><strong>二分查找 (Binary Search):</strong> 简单但细节多。</p><ul><li><em>例题：</em> 二分查找 (704), 搜索插入位置 (35)。</li></ul></li><li><p><strong>树与递归 (Tree &amp; DFS&#x2F;BFS):</strong> <strong>重中之重</strong>，后台开发处理层级数据最常用。</p><ul><li>*例题：*二叉树的最大深度 (104), 翻转二叉树 (226), 层序遍历 (102)。</li></ul></li><li><p><strong>哈希表 (Hash Table):</strong> 空间换时间的核心。</p><ul><li><em>例题：</em> 有效的字母异位词 (242), 多数元素 (169)。</li></ul></li></ol><h4 id="第三阶段：高频冲刺-面试前-1-个月"><a href="#第三阶段：高频冲刺-面试前-1-个月" class="headerlink" title="第三阶段：高频冲刺 (面试前 1 个月)"></a>第三阶段：高频冲刺 (面试前 1 个月)</h4><p>目标： 针对国内大厂面试风格进行突击。</p><p>工具： CodeTop (企业题库)。</p><ul><li>国内面试不像国外那么随机，热题重复率极高。</li><li>去 CodeTop 查看“字节跳动”、“阿里”、“美团”等公司最近半年的高频题。</li><li><strong>重点攻克：</strong> 前 100 高频题，必须烂熟于心（能手写 bug-free）。</li></ul><hr><h3 id="三、-避坑指南-刷题心法"><a href="#三、-避坑指南-刷题心法" class="headerlink" title="三、 避坑指南 &amp; 刷题心法"></a>三、 避坑指南 &amp; 刷题心法</h3><h4 id="1-“五分钟法则”"><a href="#1-“五分钟法则”" class="headerlink" title="1. “五分钟法则”"></a>1. “五分钟法则”</h4><p>如果一道题你 <strong>5 分钟</strong> 没有任何思路，<strong>直接看题解</strong>。</p><ul><li>初学者最忌讳在一道题上死磕 2 小时，这会极大地打击自信心，且效率极低。你的目的是“学习模式”，而不是“发明算法”。</li></ul><h4 id="2-理解-记忆-不要死记代码"><a href="#2-理解-记忆-不要死记代码" class="headerlink" title="2. 理解 &gt; 记忆 (不要死记代码)"></a>2. 理解 &gt; 记忆 (不要死记代码)</h4><ul><li><strong>错误做法：</strong> 背诵代码的每一行。</li><li><strong>正确做法：</strong> 记住解题的**“骨架”**。例如，写 BFS (广度优先搜索) 时，脑子里应该立刻浮现出 <code>Queue</code> 和 <code>while(!queue.isEmpty())</code> 的结构。</li></ul><h4 id="3-利用-Java-特性“取巧”"><a href="#3-利用-Java-特性“取巧”" class="headerlink" title="3. 利用 Java 特性“取巧”"></a>3. 利用 Java 特性“取巧”</h4><p>面试时，合理利用 Java 标准库可以节省大量时间：</p><ul><li><strong>排序：</strong> <code>Arrays.sort()</code> 或 <code>Collections.sort()</code>。</li><li><strong>栈：</strong> 不要用 <code>Stack</code> 类（它是遗留类，性能差），要用 <code>Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();</code>。</li><li><strong>大顶堆&#x2F;小顶堆：</strong> <code>PriorityQueue</code>，例如 <code>new PriorityQueue&lt;&gt;((a, b) -&gt; b - a)</code> 实现大顶堆。</li></ul><h4 id="4-坚持“三遍刷题法”"><a href="#4-坚持“三遍刷题法”" class="headerlink" title="4. 坚持“三遍刷题法”"></a>4. 坚持“三遍刷题法”</h4><ul><li>**第一遍：**看题解，理解思路，照着敲出来。</li><li><strong>第二遍：</strong>（次日）不看题解，凭记忆和理解独立写出来。</li><li><strong>第三遍：</strong>（一周后）复习，如果还能写出来，说明真正掌握了。</li></ul><hr><h3 id="四、-Java-后台面试必会的“数据结构映射”"><a href="#四、-Java-后台面试必会的“数据结构映射”" class="headerlink" title="四、 Java 后台面试必会的“数据结构映射”"></a>四、 Java 后台面试必会的“数据结构映射”</h3><p>在 Java 后台面试中，算法题往往对应着实际场景，请务必建立以下联系：</p><table><thead><tr><th><strong>算法&#x2F;数据结构</strong></th><th><strong>Java 实现类</strong></th><th><strong>后台开发实际场景</strong></th></tr></thead><tbody><tr><td><strong>动态数组</strong></td><td><code>ArrayList</code></td><td>绝大多数列表数据的存储</td></tr><tr><td><strong>链表</strong></td><td><code>LinkedList</code></td><td>频繁增删的场景 (如 LRU 缓存设计)</td></tr><tr><td><strong>哈希映射</strong></td><td><code>HashMap</code> &#x2F; <code>ConcurrentHashMap</code></td><td>缓存、快速查找、Spring Bean 容器</td></tr><tr><td><strong>树 (Tree)</strong></td><td><code>TreeMap</code> (红黑树)</td><td>数据库索引 (B+树)、有序数据存储</td></tr><tr><td><strong>堆 (Heap)</strong></td><td><code>PriorityQueue</code></td><td>任务调度系统、延时队列</td></tr></tbody></table><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>作为 Java 后台初学者，你的战略应该是：</p><ol><li><strong>锁定 Java 语言</strong>。</li><li><strong>前期</strong>按<strong>标签</strong>刷（数组 -&gt; 链表 -&gt; 树 -&gt; 搜索）。</li><li><strong>后期</strong>按<strong>CodeTop 高频榜</strong>刷。</li><li>遇到难题<strong>不要死磕</strong>，看懂答案并<strong>重复练习</strong>。</li></ol><h2 id="Java-刷题常用-API-速查表"><a href="#Java-刷题常用-API-速查表" class="headerlink" title="Java 刷题常用 API 速查表"></a>Java 刷题常用 API 速查表</h2><p>这份 <strong>“Java 刷题常用 API 速查表”</strong> 是专为 LeetCode 算法题定制的。</p><p>在实际的 Java 后台开发中，我们可能会用到复杂的 Stream 流或第三方工具库（如 Guava&#x2F;Apache Commons），但在<strong>刷题和机试</strong>中，尽量只使用 JDK 原生提供的、最基础、最高效的方法。</p><p>以下是按<strong>数据结构</strong>分类的核心 API 讲解：</p><hr><h3 id="1-数组与字符串-Array-String"><a href="#1-数组与字符串-Array-String" class="headerlink" title="1. 数组与字符串 (Array &amp; String)"></a>1. 数组与字符串 (Array &amp; String)</h3><p>这是最基础的部分，注意 Java 中 String 是<strong>不可变</strong>的，频繁修改必须用 <code>StringBuilder</code>。</p><h4 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 (Array)"></a>数组 (Array)</h4><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 声明与初始化</span><br><span class="line">int[] arr = new int[10];           // 默认初始化为0</span><br><span class="line">int[] nums = &#123;1, 2, 3&#125;;            // 直接赋值</span><br><span class="line">int len = arr.length;              // 注意：没有括号()</span><br><span class="line"></span><br><span class="line">// 排序 (Dual-Pivot Quicksort)</span><br><span class="line">Arrays.sort(arr);                  // O(NlogN)</span><br><span class="line"></span><br><span class="line">// 填充</span><br><span class="line">Arrays.fill(arr, -1);              // 将数组全部初始化为 -1</span><br><span class="line"></span><br><span class="line">// 转列表 (面试常考)</span><br><span class="line">// 注意：如果是 int[] 这种基本类型数组，Arrays.asList() 会出问题，建议手动循环或用流</span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">for (int num : arr) list.add(num); </span><br></pre></td></tr></table></figure><h4 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串 (String)"></a>字符串 (String)</h4><p><em>面试坑点：不要在循环里用 <code>+</code> 拼接字符串，性能极差。</em></p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;Hello World&quot;;</span><br><span class="line"></span><br><span class="line">// 获取信息</span><br><span class="line">char c = s.charAt(2);              // 获取第2个字符</span><br><span class="line">int len = s.length();              // 注意：这里有括号()</span><br><span class="line">int idx = s.indexOf(&quot;World&quot;);      // 查找子串位置，找不到返回 -1</span><br><span class="line"></span><br><span class="line">// 转换</span><br><span class="line">char[] chars = s.toCharArray();    // 转成字符数组（很常用，因为String不能直接改）</span><br><span class="line">String sub = s.substring(1, 4);    // 截取索引 1 到 3 的子串 (左闭右开 [1, 4))</span><br><span class="line">String[] parts = s.split(&quot; &quot;);     // 按空格分割</span><br><span class="line"></span><br><span class="line">// StringBuilder (修改字符串必用)</span><br><span class="line">StringBuilder sb = new StringBuilder();</span><br><span class="line">sb.append(&quot;a&quot;);</span><br><span class="line">sb.append(10);</span><br><span class="line">sb.reverse();                      // 反转字符串 (解决回文题神器)</span><br><span class="line">String res = sb.toString();        // 变回 String</span><br></pre></td></tr></table></figure><hr><h3 id="2-动态列表-ArrayList"><a href="#2-动态列表-ArrayList" class="headerlink" title="2. 动态列表 (ArrayList)"></a>2. 动态列表 (ArrayList)</h3><p>比数组更灵活，面试中 90% 的情况用它代替数组。</p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 推荐使用接口 List 接收</span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); </span><br><span class="line"></span><br><span class="line">// 增删改查</span><br><span class="line">list.add(10);                      // 加到末尾</span><br><span class="line">list.add(0, 5);                    // 插到开头 (效率低，O(N))</span><br><span class="line">int val = list.get(2);             // 获取索引2的元素</span><br><span class="line">list.set(2, 99);                   // 修改索引2的值为99</span><br><span class="line">list.remove(list.size() - 1);      // 删除最后一个元素</span><br><span class="line"></span><br><span class="line">// 常用工具</span><br><span class="line">int size = list.size();</span><br><span class="line">boolean hasVal = list.contains(10); // O(N) 线性查找</span><br><span class="line">Collections.sort(list);            // 排序 (TimSort)</span><br><span class="line">Collections.reverse(list);         // 反转</span><br></pre></td></tr></table></figure><hr><h3 id="3-哈希表-HashMap-HashSet"><a href="#3-哈希表-HashMap-HashSet" class="headerlink" title="3. 哈希表 (HashMap &#x2F; HashSet)"></a>3. 哈希表 (HashMap &#x2F; HashSet)</h3><p><strong>刷题神器</strong>，用来降低时间复杂度（通常将 O(N^2) 降为 O(N)）。</p><h4 id="HashMap-键值对"><a href="#HashMap-键值对" class="headerlink" title="HashMap (键值对)"></a>HashMap (键值对)</h4><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 基础操作</span><br><span class="line">map.put(&quot;apple&quot;, 1);</span><br><span class="line">int val = map.get(&quot;apple&quot;);</span><br><span class="line">boolean hasKey = map.containsKey(&quot;apple&quot;); // O(1)</span><br><span class="line"></span><br><span class="line">// ★ 高频技巧：统计频率 (Word Count)</span><br><span class="line">// 如果 key 存在则 +1，不存在则设为 0 再 +1</span><br><span class="line">map.put(key, map.getOrDefault(key, 0) + 1);</span><br><span class="line"></span><br><span class="line">// 遍历 (面试尽量用 entrySet，效率最高)</span><br><span class="line">for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    String k = entry.getKey();</span><br><span class="line">    Integer v = entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HashSet-去重集合"><a href="#HashSet-去重集合" class="headerlink" title="HashSet (去重集合)"></a>HashSet (去重集合)</h4><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">set.add(1);</span><br><span class="line">boolean exists = set.contains(1);  // O(1)</span><br></pre></td></tr></table></figure><hr><h3 id="4-栈与队列-Stack-Queue"><a href="#4-栈与队列-Stack-Queue" class="headerlink" title="4. 栈与队列 (Stack &amp; Queue)"></a>4. 栈与队列 (Stack &amp; Queue)</h3><p><strong>重要修正：</strong> 永远不要用 <code>Stack</code> 类（它是 Java 1.0 的遗留类，带锁，性能差）。<strong>请统一使用 <code>Deque</code> (双端队列) 接口。</strong></p><h4 id="栈-Last-In-First-Out"><a href="#栈-Last-In-First-Out" class="headerlink" title="栈 (Last-In-First-Out)"></a>栈 (Last-In-First-Out)</h4><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 使用 ArrayDeque 实现栈</span><br><span class="line">Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">stack.push(1);      // 压栈 (等同于 addFirst)</span><br><span class="line">int top = stack.pop();    // 弹栈 (等同于 removeFirst)，栈空会抛异常</span><br><span class="line">int peek = stack.peek();  //以此查看栈顶元素但不删除</span><br><span class="line">boolean isEmpty = stack.isEmpty();</span><br></pre></td></tr></table></figure><h4 id="队列-First-In-First-Out"><a href="#队列-First-In-First-Out" class="headerlink" title="队列 (First-In-First-Out)"></a>队列 (First-In-First-Out)</h4><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 使用 ArrayDeque 或 LinkedList 实现队列</span><br><span class="line">Queue&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;(); </span><br><span class="line">// 或者 Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); (如果需要中间插入)</span><br><span class="line"></span><br><span class="line">queue.offer(1);     // 入队 (推荐用 offer 而不是 add，满了返回 false 不抛异常)</span><br><span class="line">int head = queue.poll();  // 出队 (推荐用 poll 而不是 remove，空了返回 null)</span><br><span class="line">int peek = queue.peek();  // 查看队头</span><br></pre></td></tr></table></figure><hr><h3 id="5-优先队列-PriorityQueue-Heap"><a href="#5-优先队列-PriorityQueue-Heap" class="headerlink" title="5. 优先队列 (PriorityQueue &#x2F; Heap)"></a>5. 优先队列 (PriorityQueue &#x2F; Heap)</h3><p>用于解决 <strong>Top K 问题</strong> 或 <strong>第 K 大&#x2F;小元素</strong>。底层是二叉堆。</p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 默认是：小顶堆 (Min Heap)，队头是最小值</span><br><span class="line">PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// ★ 面试必背：大顶堆 (Max Heap) 写法</span><br><span class="line">// 使用 Lambda 表达式自定义比较器：(b - a) 表示降序</span><br><span class="line">PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line"></span><br><span class="line">// 操作</span><br><span class="line">maxHeap.offer(10);</span><br><span class="line">maxHeap.offer(5);</span><br><span class="line">int max = maxHeap.poll(); // 弹出 10</span><br></pre></td></tr></table></figure><hr><h3 id="6-数学与数字处理"><a href="#6-数学与数字处理" class="headerlink" title="6. 数学与数字处理"></a>6. 数学与数字处理</h3><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 比较大小</span><br><span class="line">Math.max(a, b);</span><br><span class="line">Math.min(a, b);</span><br><span class="line"></span><br><span class="line">// 绝对值</span><br><span class="line">Math.abs(-10);</span><br><span class="line"></span><br><span class="line">// ★ 边界值 (防止溢出常用)</span><br><span class="line">int maxInt = Integer.MAX_VALUE; // 2^31 - 1</span><br><span class="line">int minInt = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">// 字符转数字</span><br><span class="line">int digit = &#x27;5&#x27; - &#x27;0&#x27;; // 结果是整数 5</span><br></pre></td></tr></table></figure><hr><h3 id="7-刷题-面试中的注意事项"><a href="#7-刷题-面试中的注意事项" class="headerlink" title="7. 刷题&#x2F;面试中的注意事项"></a>7. 刷题&#x2F;面试中的注意事项</h3><ol><li><p>自动拆装箱 (Autoboxing) 的坑：</p><p> 在 Integer 和 int 之间比较时，特别小心 null。</p><p> Java</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer a = null;</span><br><span class="line">// if (a == 1) ... // 抛出 NullPointerException</span><br></pre></td></tr></table></figure></li><li><p>对象比较：</p><p> 比较对象（包括 String, Integer 等包装类）的值是否相等，永远用 .equals()，不要用 &#x3D;&#x3D;。</p><p> 例外：LeetCode 中 Integer 缓存池 (-128 到 127) 虽用 &#x3D;&#x3D; 有效，但面试写 &#x3D;&#x3D; 会被认为基础不牢。</p></li><li><p>大数处理：</p><p> 如果题目涉及超过 long 范围的数字（如大数相加），需使用 BigInteger 或直接用字符串模拟。</p></li></ol><hr><h3 id="总结-你的下一步"><a href="#总结-你的下一步" class="headerlink" title="总结 &amp; 你的下一步"></a>总结 &amp; 你的下一步</h3><p>建议你把这篇内容<strong>收藏</strong>或<strong>复制到你的笔记软件</strong>里。</p><p>下一步实战建议：</p><p>为了让你快速上手，你想让我给你出一道最经典的 Java 入门算法题（比如“有效的括号”），并用上面提到的 Deque 栈结构写一个标准范例给你看吗？这样你能直接看到这些 API 是如何组合使用的。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 日志系统</title>
      <link href="/posts/356a30bc.html"/>
      <url>/posts/356a30bc.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h1><p><img src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/MySQL_RedoLog.webp" alt="img"></p><p>这张图被一条中间的虚线分为左右两部分，代表了计算机系统中两种截然不同的存储介质属性。</p><h2 id="1-左侧区域：IN-MEMORY-内存区域-Volatile-易失性"><a href="#1-左侧区域：IN-MEMORY-内存区域-Volatile-易失性" class="headerlink" title="1. 左侧区域：IN-MEMORY (内存区域) - Volatile (易失性)"></a>1. 左侧区域：IN-MEMORY (内存区域) - Volatile (易失性)</h2><ul><li><p><strong>特点：</strong></p><ul><li><strong>速度极快：</strong> CPU 对内存的读写速度远远高于磁盘。为了高性能，数据库必须尽可能在内存中处理数据。</li><li><strong>易失性 (Volatile)：</strong> 这是最大的弱点。一旦断电、系统崩溃或进程被强制终止，内存中的所有数据瞬间消失。图中的气泡对话框形象地说明了这一点：“Fast access, but data lost on power failure.”（访问快，但断电丢数据）。</li></ul></li><li><p><strong>关键组件：</strong></p><ul><li><strong>BUFFER POOL (缓冲池)：</strong><ul><li>这是 InnoDB 在内存中最大的保留区域。它缓存了从磁盘读取的数据页 (Data Pages)。</li><li>当我们要修改数据时，不是直接去改磁盘文件，而是先在 Buffer Pool 中找到对应的数据页进行修改。</li><li><strong>Dirty Page (脏页)：</strong> 图中高亮的橙色方块。当一个数据页在内存中被修改了，但还没有写回到磁盘的数据文件中时，它就和磁盘上的版本不一致了，我们称之为“脏页”。</li></ul></li><li><strong>LOG BUFFER (日志缓冲)：</strong><ul><li>这是一个相对较小的内存区域，专门用来暂存即将写入磁盘的 Redo Log 记录。</li><li>每当 Buffer Pool 中的数据发生修改，InnoDB 就会生成一条对应的、非常紧凑的日志记录（比如：“第10号数据页偏移量500的位置，值从A改成了B”），先暂存在这里。</li></ul></li></ul></li></ul><h2 id="2-右侧区域：ON-DISK-磁盘区域-Persistent-持久性"><a href="#2-右侧区域：ON-DISK-磁盘区域-Persistent-持久性" class="headerlink" title="2. 右侧区域：ON-DISK (磁盘区域) - Persistent (持久性)"></a>2. 右侧区域：ON-DISK (磁盘区域) - Persistent (持久性)</h2><ul><li><p><strong>特点：</strong></p><ul><li><p><strong>速度慢：</strong> 相比内存，磁盘 I&#x2F;O 是非常昂贵的操作，速度很慢。</p></li><li><p><strong>持久性 (Persistent)：</strong> 优点是数据安全。写入磁盘后，即使断电，数据也不会丢失。</p></li></ul></li><li><p><strong>关键组件：</strong></p><ul><li><p><strong>REDO LOG FILES (重做日志文件)：</strong></p><ul><li><p>这是保证数据安全的核心。它们是物理磁盘上的文件（通常命名为 <code>ib_logfile0</code>, <code>ib_logfile1</code> 等）。</p></li><li><p>特点是<strong>顺序写入 (Sequential Write)</strong>。就像写日记一样，一直往文件末尾追加内容。对于机械硬盘来说，顺序写的速度远快于随机写。</p></li></ul></li><li><p><strong>DATA FILES (数据文件)：</strong></p><ul><li><p>这是表数据最终的归宿（通常是 <code>.ibd</code> 文件）。</p></li><li><p>写入这些文件通常是<strong>随机写入 (Random Write)</strong>，因为不同的数据页分布在文件的不同位置。</p></li></ul></li></ul></li></ul><hr><h2 id="流程详解：正常事务操作-Normal-Operation"><a href="#流程详解：正常事务操作-Normal-Operation" class="headerlink" title="流程详解：正常事务操作 (Normal Operation)"></a>流程详解：正常事务操作 (Normal Operation)</h2><p>这个流程的目标是：<strong>既要利用内存的高速，又要保证数据的安全。</strong></p><p><strong>步骤 1. UPDATE&#x2F;INSERT Data (事务开始)</strong></p><ul><li><p>客户端发起一个更新请求。</p></li><li><p>InnoDB 首先在 <strong>Buffer Pool</strong> 中查找需要修改的数据页。如果不在，就先从磁盘读入。</p></li><li><p>在内存中直接修改该数据页。此时，该页变成了 <strong>Dirty Page (脏页)</strong>。</p></li></ul><p><strong>步骤 2. COMMIT Transaction (提交事务)</strong></p><ul><li><p>客户端修改完数据后，发起 <code>COMMIT</code> 命令，告诉数据库：“我完成了，请把这些修改永久保存。”</p></li><li><p>此时，关于这次修改的日志记录已经被放入了 <strong>Log Buffer</strong> 中等待。</p></li></ul><p><strong>步骤 3. WAL: WRITE-AHEAD LOGGING (预写式日志) —— 最关键的一步！</strong></p><ul><li><p><strong>这是跨越“易失”和“持久”边界的关键动作。</strong></p></li><li><p>在事务被认为是“提交成功”之前，InnoDB 必须遵循 WAL 原则：<strong>日志先行</strong>。</p></li><li><p>系统会将 Log Buffer 中的日志记录，强制写入到磁盘上的 <strong>Redo Log Files</strong> 中，并执行 <code>fsync()</code> 操作（确保数据真的落到物理磁盘介质上，而不是停留在操作系统的文件缓存里）。</p></li><li><p><strong>图中文字强调：</strong> “Must reach disk BEFORE transaction is confirmed.”（在确认事务之前，日志必须到达磁盘）。</p></li><li><p><em>注：一旦这一步完成，哪怕数据文件还没更新，事务也被认为是安全的了。图里虽然没画步骤4，但此时数据库会向客户端返回“Commit OK”。</em></p></li></ul><p><strong>步骤 5. ASYNC CHECKPOINT (异步检查点&#x2F;刷脏页)</strong></p><ul><li><p>这是一个后台的、异步的过程，<strong>不影响客户端的响应速度</strong>。</p></li><li><p>Buffer Pool 中的“脏页”不能永远待在内存里，内存有限，且不安全。</p></li><li><p>InnoDB 的后台线程会选择合适的时机（比如系统空闲时，或 Redo Log 快写满时），慢慢地将这些脏页刷新到磁盘上的 <strong>Data Files</strong> 中。我们将这个过程称为“刷脏”或 Checkpoint。</p></li><li><p>图中虚线箭头和文字 “Lazy write of data pages”（数据的延迟写入）准确地描述了这个过程。</p></li></ul><hr><h2 id="流程详解：崩溃恢复-Crash-Recovery-Process"><a href="#流程详解：崩溃恢复-Crash-Recovery-Process" class="headerlink" title="流程详解：崩溃恢复 (Crash Recovery Process)"></a>流程详解：崩溃恢复 (Crash Recovery Process)</h2><p>这个流程的目标是：<strong>当发生意外时，把还没来得及写入数据文件的修改找回来。</strong></p><p><strong>场景假设：</strong> 假设在上面的流程中，<strong>步骤 3 刚刚完成</strong>（Redo Log 已经落盘），但是<strong>步骤 5 还没有发生</strong>（脏页还在内存里，没写到数据文件），突然机房断电了。</p><p><strong>后果：</strong> 内存中的 Dirty Page 瞬间消失。磁盘上的 Data Files 里存的还是旧数据。</p><p><strong>恢复过程 (图的底部区域)：</strong></p><ol><li><p><strong>SYSTEM CRASH &#x2F; POWER OUTAGE (系统崩溃&#x2F;断电)</strong>。</p></li><li><p><strong>RESTART (重启)</strong>：MySQL 服务器重新启动。</p></li><li><p><strong>Read from Last Checkpoint (从上次检查点读取)</strong>：</p><ul><li><p>InnoDB 启动时会检查状态，发现上次是非正常关闭。</p></li><li><p>它会去读取磁盘上的 <strong>REDO LOG FILES</strong>。它需要找到一个“检查点 (Checkpoint)”，这个点之前的数据保证都已经写入数据文件了。</p></li></ul></li><li><p><strong>REPLAY LOGS (重放日志)</strong>：</p><ul><li><p>InnoDB 从检查点开始，往后读取所有的 Redo Log 记录。</p></li><li><p>它按照日志记录的内容，在内存的 <strong>Buffer Pool</strong> 中重新执行一遍修改操作。</p></li></ul></li><li><p><strong>Restore Dirty Pages to Memory (恢复脏页到内存)</strong>：</p><ul><li><p>通过重放日志，崩溃前那一刻内存中的 <strong>Dirty Page</strong> 就被完美还原了。</p></li><li><p>此时，数据库恢复到了崩溃前的一致状态，可以对外提供服务了。随后，后台线程会再次尝试执行步骤 5，把这些恢复出来的脏页写入数据文件。</p></li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这张图完美地展示了 MySQL InnoDB 的设计哲学：</p><ul><li><p>利用 <strong>内存 (Buffer Pool)</strong> 来保证<strong>高性能</strong>（读写都在内存）。</p></li><li><p>利用 <strong>Redo Log (WAL机制)</strong> 来保证<strong>持久性</strong>（关键时刻利用顺序写快速落盘日志）。</p></li><li><p>利用 <strong>异步刷脏 (Checkpoint)</strong> 来平衡性能和数据最终的一致性。</p></li></ul><h1 id="Bin-Log"><a href="#Bin-Log" class="headerlink" title="Bin Log"></a>Bin Log</h1><ul><li>Server 层也有自己的日志，称为 binlog（归档日志）。</li><li>binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。<br><img src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/MySQL_BinLog.webp" alt="img"></li></ul><h2 id="工作流程图详解"><a href="#工作流程图详解" class="headerlink" title="工作流程图详解"></a>工作流程图详解</h2><p>这张图片直观地展示了 <strong>MySQL Binlog (Binary Log，二进制日志)</strong> 的工作原理，以及它是如何支撑 <strong>主从复制 (Replication)</strong> 的。</p><p>我们可以把这张图的流程拆解为三个主要部分：<strong>主库（Master）的记录</strong>、<strong>数据的传输</strong>、<strong>从库（Slave&#x2F;Replica）的重放</strong>。</p><p>以下是详细的步骤解释：</p><h3 id="1-主库端-Master-Server-：记录变更"><a href="#1-主库端-Master-Server-：记录变更" class="headerlink" title="1. 主库端 (Master Server)：记录变更"></a>1. 主库端 (Master Server)：记录变更</h3><p>这是流程的起点，对应图中左侧或上方的部分。</p><ul><li><p>写入操作 (Write Operations):</p><p>  当客户端应用（Client Application）向数据库发送 修改数据 的请求（如 INSERT, UPDATE, DELETE）时，这些操作首先在主库的存储引擎中执行。</p><ul><li><em>注意：<code>SELECT</code> 等读取操作不会被记录，因为它们不改变数据。</em></li></ul></li><li><p>写入 Binlog 文件 (Binary Log File):</p><p>  在数据被提交（Commit）到底层存储之前（或同时），MySQL 会将这次数据变更的详细信息顺序写入到磁盘上的 Binlog 文件 中。</p><ul><li><strong>Binlog 的内容：</strong> 它可以记录具体的 SQL 语句（Statement 格式），也可以记录行数据的变化（Row 格式），或者两者的混合（Mixed 格式）。</li></ul></li></ul><h3 id="2-复制与传输过程：三个关键线程"><a href="#2-复制与传输过程：三个关键线程" class="headerlink" title="2. 复制与传输过程：三个关键线程"></a>2. 复制与传输过程：三个关键线程</h3><p>这是连接主库和从库的核心机制，也是图中的核心逻辑。为了把数据同步过去，MySQL 使用了三个专门的线程：</p><h4 id="A-Binlog-Dump-Thread-主库端"><a href="#A-Binlog-Dump-Thread-主库端" class="headerlink" title="A. Binlog Dump Thread (主库端)"></a>A. Binlog Dump Thread (主库端)</h4><ul><li><p>当从库连接到主库并请求同步时，主库会创建一个 <strong>Binlog Dump 线程</strong>。</p></li><li><p>它的任务是读取主库的 Binlog 文件，并将内容通过网络发送给从库。</p></li></ul><h4 id="B-I-O-Thread-从库端"><a href="#B-I-O-Thread-从库端" class="headerlink" title="B. I&#x2F;O Thread (从库端)"></a>B. I&#x2F;O Thread (从库端)</h4><ul><li><p>从库启动后，会创建一个 <strong>I&#x2F;O 线程</strong>。</p></li><li><p>它的任务是“搬运工”：它连接到主库，接收 Dump 线程发来的 Binlog 数据块。</p></li><li><p><strong>关键点：</strong> I&#x2F;O 线程收到数据后，<strong>不会直接写入从库的数据库</strong>，而是将其写入到从库磁盘上的一个临时中转文件，叫做 <strong>Relay Log (中继日志)</strong>。</p></li></ul><h4 id="C-SQL-Thread-从库端"><a href="#C-SQL-Thread-从库端" class="headerlink" title="C. SQL Thread (从库端)"></a>C. SQL Thread (从库端)</h4><ul><li><p>这是从库的第二个关键线程。</p></li><li><p>它的任务是“执行者”：它实时检测 Relay Log 中有没有新内容。</p></li><li><p>一旦发现新内容，它就读取这些日志，并将其解析为具体的数据库操作，然后在从库的数据库中<strong>重新执行 (Replay)</strong> 一遍。</p></li></ul><h3 id="3-从库端-Replica-Server-：最终一致性"><a href="#3-从库端-Replica-Server-：最终一致性" class="headerlink" title="3. 从库端 (Replica Server)：最终一致性"></a>3. 从库端 (Replica Server)：最终一致性</h3><p>对应图中右侧或下方的部分。</p><ul><li><p>Relay Log (中继日志):</p><p>  这是一个缓冲地带。它的存在使得“获取日志”和“执行日志”解耦了。即使从库执行 SQL 比较慢（SQL Thread 阻塞），I&#x2F;O 线程依然可以快速地把主库的日志拉取回来存在本地，保证数据不丢失。</p></li><li><p>数据同步完成:</p><p>  当 SQL 线程执行完 Relay Log 中的操作后，从库的数据状态就和主库保持了一致。</p></li></ul><hr><h3 id="总结：这张图告诉了我们什么？"><a href="#总结：这张图告诉了我们什么？" class="headerlink" title="总结：这张图告诉了我们什么？"></a>总结：这张图告诉了我们什么？</h3><ol><li><p><strong>异步复制 (Asynchronous):</strong> 主库写完 Binlog 就可以告诉客户端“成功了”，它不需要等从库确认。从库是后来慢慢追上来的。</p></li><li><p><strong>解耦:</strong> 通过 Binlog 和 Relay Log，主库和从库的压力被隔离开了。</p></li><li><p><strong>核心用途:</strong></p><ul><li><p><strong>主从复制:</strong> 实现读写分离（主库写，从库读）或高可用热备。</p></li><li><p><strong>数据恢复:</strong> 如果数据库误删了，可以通过重放 Binlog 把数据恢复到误删前的任意时刻（Point-in-Time Recovery）。</p></li></ul></li></ol><p>你可以把这个过程想象成：</p><p>主库是演讲者（执行写操作），它把演讲内容录在磁带（Binlog）里。从库派了一个快递员（I&#x2F;O 线程）把磁带复刻一份拿回家（Relay Log），然后从库自己在家里放磁带（SQL 线程），跟着录音再做一遍动作。</p><p><strong>需要我为您解释 Binlog 的三种格式（Statement, Row, Mixed）的区别吗？这对性能和数据一致性有很大影响。</strong></p><h1 id="Undo-Log"><a href="#Undo-Log" class="headerlink" title="Undo Log"></a>Undo Log</h1><p>如果说 <strong>Redo Log</strong> 是“发生意外时的救命稻草”，<strong>Bin Log</strong> 是“传给别人的操作手册”，那么 <strong>Undo Log</strong> 就是**“后悔药”**（或者说是电脑上的 <code>Ctrl+Z</code>）。</p><p>它是 MySQL 保证事务 <strong>原子性 (Atomicity)</strong> 和实现 <strong>MVCC (多版本并发控制)</strong> 的核心组件。</p><p>以下是 Undo Log 的详细解析及其与另外两个日志的区别。</p><hr><h2 id="1-什么是-Undo-Log？"><a href="#1-什么是-Undo-Log？" class="headerlink" title="1. 什么是 Undo Log？"></a>1. 什么是 Undo Log？</h2><p>Undo Log（回滚日志）记录的是数据的<strong>逻辑变化</strong>，但它的记录方式是**“反着来的”**。</p><ul><li><p><strong>记录原理：</strong> 只要你修改数据，MySQL 就会在 Undo Log 里记录一条<strong>相反</strong>的操作，以便随时回滚。</p><ul><li><p>你执行 <code>INSERT</code>，它记录 <code>DELETE</code>。</p></li><li><p>你执行 <code>DELETE</code>，它记录 <code>INSERT</code>。</p></li><li><p>你执行 <code>UPDATE</code> 把 <code>age</code> 从 10 改为 20，它记录 <code>UPDATE age = 10</code>。</p></li></ul></li></ul><h4 id="它的两大核心作用："><a href="#它的两大核心作用：" class="headerlink" title="它的两大核心作用："></a><strong>它的两大核心作用：</strong></h4><ol><li><p><strong>事务回滚 (Rollback)：</strong></p><ul><li>当事务执行到一半，用户手动输入 <code>ROLLBACK</code>，或者程序发生错误（如唯一索引冲突），MySQL 就利用 Undo Log 将数据恢复到事务开始前的样子。</li></ul></li><li><p><strong>MVCC (多版本并发控制)：</strong></p><ul><li>当一个事务正在修改某行数据（还没提交），另一个事务来读取这行数据时，为了不加锁且不读到脏数据，MySQL 会利用 Undo Log 构建一个**“历史版本快照”**，让读取者看到修改之前的数据。</li></ul></li></ol><hr><h2 id="2-Undo-Log-的工作流程图解"><a href="#2-Undo-Log-的工作流程图解" class="headerlink" title="2. Undo Log 的工作流程图解"></a>2. Undo Log 的工作流程图解</h2><p>假设我们执行一个事务：<code>UPDATE user SET age = 20 WHERE id = 1;</code> (原 age &#x3D; 10)</p><h4 id="Step-1-准备回滚数据"><a href="#Step-1-准备回滚数据" class="headerlink" title="Step 1: 准备回滚数据"></a><strong>Step 1: 准备回滚数据</strong></h4><p>在真正修改内存中的数据之前，InnoDB 会先生成一条 Undo Log：</p><blockquote><p>“如果要把 id&#x3D;1 的数据回滚，请执行 <code>UPDATE user SET age = 10 WHERE id = 1;</code>”</p></blockquote><h4 id="Step-2-修改内存-写-Redo-Log"><a href="#Step-2-修改内存-写-Redo-Log" class="headerlink" title="Step 2: 修改内存 &amp; 写 Redo Log"></a><strong>Step 2: 修改内存 &amp; 写 Redo Log</strong></h4><p>执行修改，内存中的 age 变为 20。同时写入 Redo Log（记录物理修改）。</p><h4 id="Step-3-此时如果有别的事务来查-MVCC"><a href="#Step-3-此时如果有别的事务来查-MVCC" class="headerlink" title="Step 3: 此时如果有别的事务来查 (MVCC)"></a><strong>Step 3: 此时如果有别的事务来查 (MVCC)</strong></h4><p>事务还没提交。此时事务 B 来查 id&#x3D;1。</p><p>InnoDB 发现这行数据被锁定了（或处于活跃事务中），它不会阻塞，而是顺着回滚指针 (Rollback Pointer) 找到 Undo Log 里的记录。</p><ul><li><p><strong>结果：</strong> 事务 B 读到了 <code>age = 10</code>。</p></li><li><p><strong>意义：</strong> 读写互不阻塞，高并发性能的关键。</p></li></ul><h4 id="Step-4-事务提交-Commit-或-回滚-Rollback"><a href="#Step-4-事务提交-Commit-或-回滚-Rollback" class="headerlink" title="Step 4: 事务提交 (Commit) 或 回滚 (Rollback)"></a><strong>Step 4: 事务提交 (Commit) 或 回滚 (Rollback)</strong></h4><ul><li><p><strong>如果提交：</strong> Undo Log 不会立即删除（因为可能还有长事务需要看旧版本），而是放入“待清理列表 (History List)”，由 Purge 线程后续清理。</p></li><li><p><strong>如果回滚：</strong> 立即执行 Undo Log 里的反向操作，将 age 变回 10。</p></li></ul><hr><h2 id="3-一个刁钻的问题：Undo-Log-本身需要持久化吗？"><a href="#3-一个刁钻的问题：Undo-Log-本身需要持久化吗？" class="headerlink" title="3. 一个刁钻的问题：Undo Log 本身需要持久化吗？"></a>3. 一个刁钻的问题：Undo Log 本身需要持久化吗？</h2><p><strong>需要。</strong></p><p>这听起来有点绕：Undo Log 是用来修数据的，那谁来修 Undo Log 呢？</p><p>答案是 Redo Log。</p><ul><li><p>Undo Log 在 MySQL 中也被视为“数据”的一种（存在于系统表空间或 undo 表空间中）。</p></li><li><p>当你写 Undo Log 时，这个写入操作本身也会产生对应的 Redo Log。</p></li><li><p><strong>场景：</strong> 假设事务执行了一半，MySQL 崩溃了。</p><ol><li><p>重启后，Redo Log 会先恢复数据，<strong>同时也恢复了 Undo Log</strong>。</p></li><li><p>数据库发现有一个事务处于“未提交”状态。</p></li><li><p>利用刚刚恢复出来的 Undo Log，对该事务进行回滚 (Rollback)。</p></li><li><p>数据库恢复一致性。</p></li></ol></li></ul><hr><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li><p><strong>Redo Log</strong> 让你<strong>向前走</strong>（掉电了也能继续往前走完）。</p></li><li><p><strong>Undo Log</strong> 让你<strong>向后退</strong>（做错了可以退回到原点）。</p></li><li><p><strong>Bin Log</strong> 让你<strong>克隆</strong>（把你的经历完整复制给另一个库）。</p></li></ul><p>三者配合：</p><ol><li><p>事务开启。</p></li><li><p>写 <strong>Undo Log</strong> (为了能退回来)。</p></li><li><p>执行内存修改。</p></li><li><p>写 <strong>Redo Log</strong> (为了防断电)。</p></li><li><p>提交时写 <strong>Bin Log</strong> (为了给从库)。</p></li><li><p>事务结束。</p></li></ol><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><table><thead><tr><th><strong>特性</strong></th><th><strong>Redo Log (重做日志)</strong></th><th><strong>Bin Log (归档日志)</strong></th><th><strong>Undo Log (回滚日志)</strong></th></tr></thead><tbody><tr><td><strong>核心关键词</strong></td><td><strong>“恢复”</strong></td><td><strong>“复制”</strong></td><td><strong>“撤销”</strong></td></tr><tr><td><strong>比喻</strong></td><td>记账本的草稿 (防止断电忘事)</td><td>完整的账单明细 (给别人看)</td><td><strong>橡皮擦 &#x2F; Ctrl+Z</strong></td></tr><tr><td><strong>侧重点</strong></td><td>物理偏向 (页修改)</td><td>逻辑偏向 (SQL语义)</td><td><strong>逻辑反向</strong> (逆操作)</td></tr><tr><td><strong>主要作用</strong></td><td>崩溃恢复 (Crash Safe)<br><br>  <br><br>保证 <strong>D</strong> (持久性)</td><td>主从复制、数据恢复<br><br>  <br><br>保证数据一致性</td><td>事务回滚、MVCC<br><br>  <br><br>保证 <strong>A</strong> (原子性) 和 <strong>I</strong> (隔离性)</td></tr><tr><td><strong>写入时机</strong></td><td>事务进行中不断写</td><td>事务提交时一次性写</td><td>事务开始前&#x2F;修改前写</td></tr><tr><td><strong>释放时机</strong></td><td>落盘后覆盖 (循环写)</td><td>不删除 (追加写)</td><td>事务提交后，若无 MVCC 需求则标记删除 (Purge)</td></tr></tbody></table><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="为什么需要“两阶段提交”-2-PC"><a href="#为什么需要“两阶段提交”-2-PC" class="headerlink" title="为什么需要“两阶段提交” (2 PC)?"></a>为什么需要“两阶段提交” (2 PC)?</h2><p><img src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/MySQL_2PC.webp" alt="img"></p><h3 id="背景问题：数据一致性"><a href="#背景问题：数据一致性" class="headerlink" title="背景问题：数据一致性"></a>背景问题：数据一致性</h3><p>如果 MySQL 没有两阶段提交，Redo Log 和 Bin Log 的写入顺序是独立的。假设我们执行一条 <code>UPDATE</code> 语句：</p><ol><li><p><strong>先写 Redo Log，再写 Bin Log：</strong></p><ul><li>如果 Redo Log 写完，Bin Log 还没写完时系统宕机。</li><li><em>恢复后：</em> 主库通过 Redo Log 恢复了数据（A&#x3D;1）；但 Bin Log 没记录，从库同步时数据仍是旧的（A&#x3D;0）。<strong>主从不一致。</strong></li></ul></li><li><p><strong>先写 Bin Log，再写 Redo Log：</strong></p><ul><li>如果 Bin Log 写完，Redo Log 没写完时系统宕机。</li><li><em>恢复后：</em> 主库因 Redo Log 缺失，事务回滚（A&#x3D;0）；但 Bin Log 已经有了记录，从库会同步这条更新（A&#x3D;1）。<strong>主从不一致。</strong></li></ul></li></ol><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p><strong>两阶段提交是为了让 Redo Log 和 Bin Log 在逻辑上保持一致</strong>。要么同时成功，要么同时失败。</p><hr><h3 id="两阶段提交流程详解"><a href="#两阶段提交流程详解" class="headerlink" title="两阶段提交流程详解"></a>两阶段提交流程详解</h3><p>假设执行语句：<code>UPDATE user SET age = age + 1 WHERE id = 1;</code></p><h4 id="流程图解"><a href="#流程图解" class="headerlink" title="流程图解"></a><strong>流程图解</strong></h4><p>代码段</p><div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>    sequenceDiagram    participant Client as 客户端    participant Executor as 执行器 (Server层)    participant InnoDB as InnoDB 引擎    participant DiskRedo as Redo Log (磁盘)    participant DiskBin as Bin Log (磁盘)    Client-&gt;&gt;Executor: 发起 Update 语句    Executor-&gt;&gt;InnoDB: 查找 ID&#x3D;1 的行    InnoDB--&gt;&gt;Executor: 返回行数据 (若不在内存则从磁盘读)        Note over Executor: 1. 执行更新操作    Executor-&gt;&gt;InnoDB: 写入新行数据 (内存更新)    Note over InnoDB, DiskRedo: 2. Prepare 阶段 (准备)    InnoDB-&gt;&gt;DiskRedo: 写入 Redo Log (状态: PREPARE)        Note over Executor, DiskBin: 3. 写 Binlog 阶段    Executor-&gt;&gt;DiskBin: 写入 Bin Log        Note over InnoDB, DiskRedo: 4. Commit 阶段 (提交)    Executor-&gt;&gt;InnoDB: 提交事务 (调用引擎接口)    InnoDB-&gt;&gt;DiskRedo: Redo Log 标记为 (状态: COMMIT)        Executor--&gt;&gt;Client: 返回成功  </pre></div><h4 id="详细步骤解析"><a href="#详细步骤解析" class="headerlink" title="详细步骤解析"></a><strong>详细步骤解析</strong></h4><ol><li><p><strong>执行阶段：</strong></p><ul><li>InnoDB 将内存中的数据更新（此时数据在内存中是脏页）。</li></ul></li><li><p><strong>Prepare 阶段 (第一阶段)：</strong></p><ul><li><p>InnoDB 将本次事务的变更写入 Redo Log，并将 Redo Log 的记录状态标记为 <code>PREPARE</code>。</p></li><li><p>此时，事务并未真正完成，但数据变更已经持久化到了 Redo Log 中。</p></li></ul></li><li><p><strong>写 Bin Log 阶段：</strong></p><ul><li>MySQL Server 层将事务的逻辑操作写入 Bin Log 文件，并确保写入磁盘（依赖 <code>sync_binlog</code> 参数）。</li></ul></li><li><p><strong>Commit 阶段 (第二阶段)：</strong></p><ul><li><p>Server 层调用引擎的提交接口。</p></li><li><p>InnoDB 收到通知后，将 Redo Log 中刚才那条记录的状态由 <code>PREPARE</code> 修改为 <code>COMMIT</code>。</p></li><li><p>至此，事务彻底完成。</p></li></ul></li></ol><hr><h3 id="崩溃恢复逻辑：它是如何保证一致性的？"><a href="#崩溃恢复逻辑：它是如何保证一致性的？" class="headerlink" title="崩溃恢复逻辑：它是如何保证一致性的？"></a>崩溃恢复逻辑：它是如何保证一致性的？</h3><p>如果在上述流程的任意时刻发生宕机（Crash），MySQL 重启后会检查 Redo Log 中的状态：</p><ul><li><p><strong>情况 A：Redo Log 是完整的 <code>COMMIT</code> 状态</strong></p><ul><li><p><strong>处理：</strong> 直接根据 Redo Log 提交事务，恢复数据。</p></li><li><p><strong>结果：</strong> 事务成功。</p></li></ul></li><li><p><strong>情况 B：Redo Log 是 <code>PREPARE</code> 状态，且 Bin Log 完整</strong></p><ul><li><p><em>场景：</em> 步骤 3 完成了（Bin Log 写了），但步骤 4 还没来得及改状态。</p></li><li><p><strong>处理：</strong> MySQL 扫描 Bin Log，发现该事务的 XID（事务 ID）在 Bin Log 中存在且完整。引擎将 Redo Log 状态补齐为 Commit，提交事务。</p></li><li><p><strong>结果：</strong> 事务成功（因为 Bin Log 已经有了，为了主从一致，主库必须提交）。</p></li></ul></li><li><p><strong>情况 C：Redo Log 是 <code>PREPARE</code> 状态，但 Bin Log 不完整&#x2F;缺失</strong></p><ul><li><p><em>场景：</em> 步骤 2 完成了，但在写 Bin Log 时宕机。</p></li><li><p><strong>处理：</strong> 扫描 Bin Log 发现没有对应的 XID。引擎回滚（Rollback）该事务。</p></li><li><p><strong>结果：</strong> 事务失败（主库回滚，从库也没收到 Bin Log，达成一致）。</p></li></ul></li></ul><hr><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li><p><strong>Redo Log</strong> 救主库（物理恢复），<strong>Bin Log</strong> 救从库（逻辑同步）。</p></li><li><p><strong>两阶段提交</strong> 就像是一个“握手协议”：</p><ul><li>先让 Redo Log 做好准备（Prepare）。</li><li>再写 Bin Log（关键点）。</li><li>最后确认 Redo Log（Commit）。</li></ul></li><li><p><strong>判决标准：</strong> 只要 <strong>Bin Log 写成功了</strong>，这个事务就算成功，Redo Log 即使是 Prepare 状态也会被强制提交；否则就回滚。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>八股文</title>
      <link href="/posts/65190.html"/>
      <url>/posts/65190.html</url>
      
        <content type="html"><![CDATA[<h1 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h1><p>所谓的Bit-map就是用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。</p><p>我们可以用一个unsigned int类型的数组或者向量来表示位图，假设我们定义vector a，则 第i位可表示为a[i&#x2F;32]的i%32位（其中，32*N+r &#x3D; i，r为i%32，也就是i&#x2F;32的余数）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Bitmap</span><br><span class="line">&#123;</span><br><span class="line">    private:</span><br><span class="line">    vector&lt;size_t&gt; v;</span><br><span class="line">    public:</span><br><span class="line">    Bitmap(size_t num) : v((num&gt;&gt;5)+1, 0) &#123;&#125;</span><br><span class="line">    //set 1</span><br><span class="line">    void set(size_t num)</span><br><span class="line">    &#123;</span><br><span class="line">        v[num&gt;&gt;5] |= (1&lt;&lt;(num &amp; 31)); // num &amp; 31 equals num % 32</span><br><span class="line">    &#125;</span><br><span class="line">    //set 0</span><br><span class="line">    void clean(size_t num)</span><br><span class="line">    &#123;</span><br><span class="line">        v[num&gt;&gt;5] &amp;= ~(1&lt;&lt;(num &amp; 31));</span><br><span class="line">    &#125;</span><br><span class="line">    //if exist or not</span><br><span class="line">    bool isExist(size_t num)</span><br><span class="line">    &#123;</span><br><span class="line">        bool is = 0;</span><br><span class="line">        size_t r = 1 &lt;&lt; (num &amp; 31); //r represents remainder</span><br><span class="line">        if(r == (v[num&gt;&gt;5] &amp; r))</span><br><span class="line">            is = 1;</span><br><span class="line">        return is;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><ul><li>docker是应用 打包、分发和部署的工具</li></ul><p><strong>Linux内核提供namespace完成隔离，Cgroup完成资源限制。namespace+Cgroup构成了容器的底层技术（rootfs是容器文件系统层技术）。</strong></p><ul><li><strong>多容器通信</strong>：docker network创建虚拟网络</li><li><strong>docker-compose</strong> 把项目的多个服务集合到一起，一键运行</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>部署方便</li><li>部署安全</li><li>隔离性好</li><li>快速回滚</li><li>成本低</li><li>管理成本低</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>隔离性：</li></ul><p>基于hypervisor的虚拟技术，在隔离性上比容器技术更好，因为系统硬件资源完全上虚拟化，当一台虚拟机出现系统级别问题，不会影响到同一宿主机的其他虚拟机。（但是容器就不一样了，容器之间共享同一个操作系统内核及其它组件）</p><ul><li>性能：</li></ul><p>运用不同的技术对应用本身进行了一定程度的封装与隔离，在降低应用和应用之间以及应用和环境之间的耦合性上做了很多努力，但是随之而来的，就会产生更过的网络连接转发和数据交互</p><ul><li>存储方案</li></ul><p>需要外挂网络磁盘或者映射到宿主机上</p><h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h2><p>**单体服务拆分为微服务后，如果微服务之间存在调用依赖，就需要得到目标服务的服务地址，也就是微服务治理的”服务发现“。**要完成服务发现，就需要将服务信息存储到某个载体，载体本身即是微服务治理的”服务注册中心“，而存储到载体的动作即是”服务注册“。</p><h2 id="可观测性"><a href="#可观测性" class="headerlink" title="可观测性"></a>可观测性</h2><p>微服务由于较单体应用有了更多的部署载体，需要对众多服务间的调用关系、状态有清晰的掌控。可观测性就包括了</p><ul><li>调用拓扑关系</li><li>监控（Metrics）</li><li>日志（Logging）</li><li>调用追踪（Trace）</li></ul><h2 id="流量管理"><a href="#流量管理" class="headerlink" title="流量管理"></a>流量管理</h2><ul><li>灰度发布</li><li>A&#x2F;B实验</li></ul><h2 id="鉴权"><a href="#鉴权" class="headerlink" title="鉴权"></a>鉴权</h2><h1 id="C-C-函数调用过程分析"><a href="#C-C-函数调用过程分析" class="headerlink" title="C&#x2F;C++函数调用过程分析"></a><a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601204.html">C&#x2F;C++函数调用过程分析</a></h1><h1 id="英文"><a href="#英文" class="headerlink" title="英文"></a>英文</h1><p>项目难点</p><p>During my tenure, I was in charge of many projects, among which the most challenging for me was the first project. Because I ran into memory leaks and concurrency issues. For the first question, by using performance analysis tools and consulting related materials, I learned that the underlying memory allocation strategy caused the memory leak problem, so I adjusted the strategy and solved the problem smoothly. The second question, I implemented CAS by combining redis and lua scripts, and cooperated with the retry mechanism to ensure that the data written in is in line with expectations.</p><p>为什么加入</p><p>I’d like to join because both citrix and i share the same values, also, i think this position merges my interests with my skill set, so i can contribute to Citrix</p><p>未来展望</p><p>i look forward to continuing to develop my skills and carees. Citrix excite me and i hope that in five years I’ll still be here continuig to hone my skills</p><p>为什么离职</p><p>For the long-term planning, I hope to return to Nanjing for development and settle down with my girlfriend</p><p>如何应对工作中的压力</p><p>i work well under pressure. when i’m under pressure, rather than panic. the first thing i do is prioritize the most important things that need to be done first. then i tackle each task one by one</p><p>优点</p><p>i have strong work ethic and it makes me do better</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis 学习笔记</title>
      <link href="/posts/16018.html"/>
      <url>/posts/16018.html</url>
      
        <content type="html"><![CDATA[<h2 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h2><h3 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">    int len; // buf中已使用的字节数</span><br><span class="line">    int free; // buf中未使用的字节数</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ol><li>包含头尾节点，head tail，以及链表长度计数器len</li><li>无环</li><li>多态：链表节点使用void*来保存节点值，可以支持各种不同类型的值</li></ol><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>属于k-v结构的映射表。</p><ol><li>字典由两个哈希表构成，当字典处于redhash状态，ht[1]才有数据，当rehash完成之后，数据会全部复制到ht[0]</li><li>哈希表使用链地址法来解决冲突</li><li>采用渐进式rehash，并不是一次性，集中式完成，而是分多次、渐进式完成。rehash会与增删改等操作一起进行：</li></ol><h3 id="渐进式hash总结："><a href="#渐进式hash总结：" class="headerlink" title="渐进式hash总结："></a><strong>渐进式hash总结：</strong></h3><p>在扩容和收缩的时候，如果哈希字典中有很多元素，一次性将这些键全部rehash到ht[1]的话，可能会导致服务器在一段时间内停止服务。所以，采用渐进式rehash的方式，详细步骤如下：</p><ol><li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表</li><li>将rehashindex的值设置为0，表示rehash工作正式开始</li><li>在rehash期间，每次对字典执行增删改查操作是，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashindex索引上的所有键值对rehash到ht[1]，当rehash工作完成以后，rehashindex的值+1</li><li>随着字典操作的不断执行，最终会在某一时间段上ht[0]的所有键值对都会被rehash到ht[1]，这时将rehashindex的值设置为-1，表示rehash操作结束</li></ol><p><strong>渐进式rehash采用的是一种分而治之的方式，将rehash的操作分摊在每一个的访问中，避免集中式rehash而带来的庞大计算量。</strong></p><p><strong>需要注意的是在渐进式rehash的过程，如果有增删改查操作时，如果<strong><strong>index</strong></strong>大于**<strong>rehashindex</strong></strong>，访问<strong><strong>ht[0]</strong></strong>，否则访问**<strong>ht[1]。</strong></p><h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><ul><li>是一种有序的数据结构，在每个节点中维持多个指向其他的节点指针，通过维持索引层，从而达到快速访问的目的。</li><li>一定程度来讲，跳表是简化版的红黑树，平均复杂度为logn，差别是空间复杂度会</li></ul><p>应用：有序集合、集群节点中用作内部数据结构</p><h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><p>整数集合是集合键（set）的实现之一，当集合都是整数，且数目不多时，会使用整数集合作为底层的实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset &#123;</span><br><span class="line">    uint32_t encoding;// 表明了整数集合的类型，如int16 int32 int64</span><br><span class="line">    uint32_t length;</span><br><span class="line">    int8_t contents[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：当新增元素超过元素的可表示范围，会将已存储元素进行升级（比如原来是uint32，但是新增元素是uint64,，会把已存储元素都升级为uint64）。优势：</p><ol><li>提供灵活性</li><li>节约内存</li></ol><h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>按照元素占用大小进行设计的数据结构，每个节点会有一个length字段，通过其可以计算出下一个节点的位置。不同于数组，这么做可以节省内存</p><p>应用：列表和哈希，都是其数据量少，且数据占用较小的时候，会使用该数据结构，不然就是链表和字典了。</p><h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><p>Redis是key-value数据库，key的类型只能是String，但是value的数据类型就比较丰富了，主要包括五种：</p><h3 id="String："><a href="#String：" class="headerlink" title="String："></a>String：</h3><ol><li>string类型是二进制安全的</li><li>一个键最大能存储512MB的数据，底层是简单动态字符串（SDS）：内部有个函数checkStringLength会对字符串进行校验，默认就是512MB，可以在配置文件中修改这个值</li></ol><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>是一个键值(key&#x3D;&gt;value)对集合。 Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。底层使用压缩列表和字典</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>底层使用压缩列表和链表实现</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>底层使整数集合和字典实现，key不允许重复</p><h3 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h3><p>有序集合，不允许重复。相对于set，支持按照score排序，key不允许重复，但是score允许重复，底层实现使用到了压缩列表和跳表</p><h2 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h2><p>在redis集群内部，采用slot槽位的逻辑管理方式， 集群内部共有16384(2的14次方)个Slot，集群内每个Redis Instance负责其中一部分的Slot的读写。一个Key到底属于哪个Slot，由分片算法：</p><p>crc16(key) % 16384</p><p>决定。也正是通过此分片算法，将不同的key以相对均匀的方式分配到不同的slot上。</p><h2 id="watch：当执行多键值事务操作时，Redis不仅要求这些键值需要落在同一个Redis实例上，还要求落在同一个slot上。"><a href="#watch：当执行多键值事务操作时，Redis不仅要求这些键值需要落在同一个Redis实例上，还要求落在同一个slot上。" class="headerlink" title="watch：当执行多键值事务操作时，Redis不仅要求这些键值需要落在同一个Redis实例上，还要求落在同一个slot上。"></a>watch：当执行多键值事务操作时，Redis不仅要求这些键值需要落在同一个Redis实例上，还要求落在同一个slot上。</h2><p>官方介绍MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令，事务可以一次执行多个命令，但是必须满足2个条件：</p><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。<br>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。执行和是否成功是2个概念，并不是一个失败报错等，其他就失败。redis对事务是部分支持。如果最开始语法等就有提交错误，就相当于java的编译器都过不了，那么肯定全部不执行。如果在执行过程中报错，已经全部执行了，但是谁报错找谁，其他正常执行放行。各取所需！这里的事务并不是要么全部成功，要么全部失败，全部执行和全部成功（或者都失败）是2个概念。</p><h2 id="hashtag"><a href="#hashtag" class="headerlink" title="hashtag"></a><a href="https://www.cnblogs.com/kismetv/p/9853040.html#t54">hashtag</a></h2><p>Hash Tag原理是：当一个key包含 {} 的时候，不对整个key做hash，而仅对 {}包括的字符串做hash。</p><p>Hash Tag可以让不同的key拥有相同的hash值，从而分配在同一个槽里；这样针对不同key的批量操作(mget&#x2F;mset等)，以及事务、Lua脚本等都可以支持。不过Hash Tag可能会带来数据分配不均的问题，这时需要：(1)调整不同节点中槽的数量，使数据分布尽量均匀；(2)避免对热点数据使用Hash Tag，导致请求分布不均。</p><h2 id="bigkey"><a href="#bigkey" class="headerlink" title="bigkey"></a><a href="https://blog.csdn.net/huxianbo0807/article/details/102912172">bigkey</a></h2><ul><li>涉及到bigkey的操作，网卡会成为瓶颈</li><li>若需要删除bigkey，直接del，被操作的实例可能会直接卡死</li><li>业务上对bigkey取余，将数据分散，避免生成bigkey</li></ul><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><ol><li>一台redis服务的数据，复制到多台redis服务器。前者称为主节点，后者为从节点</li><li>数据的复制是单向的，只能从主节点复制到从节点</li></ol><ul><li>作用：</li></ul><ol><li>数据冗余：实现了数据的热备份，是持久化之外的数据冗余方式</li><li>故障恢复：主节点失效，丛节点提供服务</li><li>负载均衡：实现读写分离，主节点写，丛节点读</li><li>高可用的基础：主从复制是哨兵和集群模式能够实施的基础</li></ol><ul><li>数据同步：</li></ul><ol><li><strong>主从节点连接建立</strong>后，便开始数据同步。</li><li>根据<strong>主从节点当前状态</strong>，分为全量和部分复制</li><li>具体执行方式：从节点朝主节点发送psync命令，开始同步</li></ol><ul><li>命令传播：<br>  主从数据同步完成后，主节点将自己执行的写命令发送给丛节点（该过程是异步的），保证数据的一致性。</li></ul><h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><ol><li>能够自动完成故障发现和转移，从而实现高可用</li><li>由一组哨兵节点和一组（或多组）主从复制节点组成</li></ol><ul><li>心跳机制</li><li>故障转移</li></ul><ol><li>每个 Sentinel 都会定时进行心跳检查，当发现主节点出现心跳检测超时的情况时，此时认为该主节点已经不可用，这种判定称为<strong>主观下线</strong>。</li><li>哨兵节点开始投票，当<strong>超过半数</strong>认为该主节点故障，会将其下线：基于raft算法，选取一个哨兵节点来执行该过程</li></ol><ul><li>选取一个从节点作为主节点，将其他从节点和该节点绑定</li><li>原来的主节点更新为从节点，对其监控，等恢复后，命令其去复制新的主节点</li></ul><h3 id="cluster集群"><a href="#cluster集群" class="headerlink" title="cluster集群"></a>cluster集群</h3><ol><li>由多个主从复制的结构组成</li><li>每个主从复制的结构看做一个节点</li></ol><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>优势：</p><ol><li>RDB 是一个非常紧凑（compact）的二进制文件，体积小，因此在传输速度上比较快，因此适合灾难恢复。</li><li>数据恢复速度比aof快</li></ol><p>劣势：</p><ol><li>rdb出现故障丢的数据会比aof多。你通常会每隔5分钟或者更久做一次完整的保存,万一在 Redis 意外宕机,你可能会丢失几分钟的数据。</li><li>rdb需要fork子进程来保存数据到硬盘，当数据集比较大时， fork比较耗时，从而导致redis主线程在一些毫秒级别内无法响应客户端</li></ol><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>优势：</p><ol><li>数据更完整，秒级丢失（无 fsync、每秒 fsync 、每次写的时候 fsync ）</li><li>兼容性高，是基于redis通讯协议而形成的命令追加方式，无论何种版本的redis都兼容，</li><li>aof文件是明文的，可阅读性较好。</li></ol><p>劣势：</p><ol><li>数据文件大，即使有重写机制（合并命令、删减无用命令），但是同样量级还是比rdb占用大</li><li>数据恢复慢</li><li>aof更吃性能（需要频繁同步命令，虽然会先写到内存中，再同步到磁盘里）</li></ol><h3 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h3><p>混合持久化结合了RDB持久化 和 AOF 持久化的优点, 由于绝大部分都是RDB格式，加载速度快，同时结合AOF，增量的数据以AOF方式保存了，数据更少的丢失。</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="redis分布式锁"><a href="#redis分布式锁" class="headerlink" title="redis分布式锁"></a>redis分布式锁</h3><p>redis实现分布式锁常见的有以很多，官方推荐下面的这种实现（也是我们目前的方式）</p><p>set命令加锁，lua脚本释放锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value NX PX milliseconds</span><br></pre></td></tr></table></figure><ul><li>key: 资源的key,标识一种资源。</li><li>value: 此值必须在所有进程和所有获取锁的请求中都是唯一的。</li><li>NX: 该命令仅在key不存在时才设置。</li><li>PX <em>milliseconds</em>: 过期时间,单位为毫秒。</li></ul><p>这里的value,设置为唯一值，主要是为了释放锁，自己只能释放自己加的锁。注意在某些场景下，也可以不释放锁，因为本身设置了有效期。</p><p>释放锁一般是通过执行下面的lua脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then</span><br><span class="line">    return redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="存在的问题："><a href="#存在的问题：" class="headerlink" title="存在的问题："></a>存在的问题：</h4><p>对于Redis主节点与从节点之间的数据复制是异步复制的，当客户端发送写请求给master节点的时候，客户端会返回OK（这个时候A已经获得锁），然后同步到各个slave节点中。如果此时master还没来得及同步给slave节点时发生宕机，那么master内存中的数据会丢失（这样可能会导致B也能获得锁）。</p><h4 id="redlock"><a href="#redlock" class="headerlink" title="redlock:"></a>redlock:</h4><p>它的基本思路就是为锁准备多个独立的节点，在锁过期时间内只要超过半数获取到锁，就算成功，避免redis主从切换的时候，数据丢失。</p><ul><li>问题：</li></ul><ol><li>宕机重启后，两个客户端拿到同一把锁</li></ol><p>假设5个节点是A, B, C, D, E，客户端1在A, B, C上面拿到锁，D, E没有拿到锁，客户端1拿锁成功。 此时，C挂了重启，C上面锁的数据丢失（假设机器断电，数据还没来得及刷盘）。客户端2去取锁，从C, D, E 3个节点拿到锁，A, B没有拿到（还被客户端1持有），客户端2也超过多数派，也会拿到锁</p><p>解决方案：延迟重启，等待ttl之后再重启。</p><ol start="2"><li>时钟跳跃：是指系统时间发生了跳跃</li></ol><p>时钟跳跃可能延迟重启机制失效，时钟跳跃可能导致机器挂了立马重启，从而出现上面的问题。时钟跳跃可能导致客户端拿到锁之后立马失效，跟服务器挂掉类似。基于自动过期机制，依然没有解决长时间的gc pause等问题带来的锁自动失效，从而带来的安全性问题</p><h3 id="zookeeper分布式锁"><a href="#zookeeper分布式锁" class="headerlink" title="zookeeper分布式锁"></a>zookeeper分布式锁</h3><ul><li><p>使用 ZK 的临时节点和有序节点，每个线程获取锁就是在 ZK 创建一个临时有序的节点，比如在 &#x2F;lock&#x2F; 目录下</p></li><li><p>创建节点成功后，获取 &#x2F;lock 目录下的所有临时节点，再判断当前线程创建的节点是否是所有的节点的序号最小的节点</p></li><li><p>如果当前线程创建的节点是所有节点序号最小的节点，则认为获取锁成功</p></li><li><p>如果当前线程创建的节点不是所有节点序号最小的节点，则对节点序号的前一个节点添加一个事件监听。</p></li></ul><h3 id="redis-zk对比"><a href="#redis-zk对比" class="headerlink" title="redis zk对比"></a>redis zk对比</h3><ul><li>Zookeeper的分布式锁是客户端基于创建临时节点实现的，对于排他锁，每个客户端都尝试创建临时节点，但是只有一个客户端能成功创建，创建成功则相当于获取了锁。对于共享锁，则会按照一定的顺序队列创建带序号的临时节点并尝试获取锁（可以有多个客户端获取共享锁）。Redis的分布式锁则是通过创建一个从未创建过的key并设置其过期时间实现的，创建成功则获得了锁，并且客户端会在一定时间内循环获取锁，比较消耗服务器性能。</li><li>Zookeeper释放锁时，要么正常执行完业务逻辑后，事务主动释放，要么是检测到与客户端的会话失效后释放。Redis释放锁时，要么正常执行完业务逻辑后，事务主动释放，要么是键超时后释放锁。</li><li>对于Redis的主从结构中出现的主服务器宕机情况（单点故障），客户端A已经获取到锁了，但是主服务器还没来得及将键复制到从服务器，并且从服务器晋升为了主服务器，这时客户端B也可以获取锁，锁互斥效果就失效了。可以使用RedLock解决，但是不建议，可以使用Zookeeper。</li><li>Redis性能更高。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TODO</title>
      <link href="/posts/4947.html"/>
      <url>/posts/4947.html</url>
      
        <content type="html"><![CDATA[<h3 id="Pending-Issues"><a href="#Pending-Issues" class="headerlink" title="Pending Issues"></a>Pending Issues</h3><h3 id="Fixed"><a href="#Fixed" class="headerlink" title="Fixed"></a>Fixed</h3><ul><li><input checked="" disabled="" type="checkbox"> 多级目录时，通过目录定位会出问题<ul><li>目录名一致，但是层级关系不一致，不会被视为同一目录，建议不要这样设置</li></ul></li><li><input checked="" disabled="" type="checkbox"> Obsidian 双链转 hexo 链接<ul><li>引用hexo-filter-titlebased-link 库，添加配置项解决该问题</li></ul></li><li><input checked="" disabled="" type="checkbox"> Mermaid 代码块渲染失败，需要引用 JS 语法<ul><li>引用hexo-filter-mermaid-diagrams 库，但是间歇性还是会渲染不出来，推荐还是使用<strong>标签插件 (Tag Plugin)</strong> 语法</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% mermaid %&#125;</span><br><span class="line">&#123;% endmermaid %&#125;</span><br></pre></td></tr></table></figure><ul><li><p><input checked="" disabled="" type="checkbox"> 本地测试经常性报 fontawesome failure</p><blockquote><pre><code>使用隐私模式访问，大概率没问题</code></pre></blockquote></li><li><p><input checked="" disabled="" type="checkbox"> 图片多大太大，导致加载缓慢的问题。参考: <a href="https://gemini.google.com/share/320865e42713">https://gemini.google.com/share/320865e42713</a></p><ul><li><input checked="" disabled="" type="checkbox"> 配置图床(github repo: <a href="%5BSupremes/blog-images%5D(https://github.com/Supremes/blog-images)">blog-images</a>)，并使用CDN - <code>cdn.jsdelivr.net </code> 加速访问</li><li><input checked="" disabled="" type="checkbox"> 压缩图片大小</li></ul></li><li><p><input checked="" disabled="" type="checkbox"> 首页按照更新时间展示文章列表</p><ul><li>更新时间显示有误，导致列表展示乱序：由于是 github action 编译部署，会导致把所有文章统一更新到编译时间，因此选择使用 Obsidian 的 Linter 插件应用更新时间。</li><li>配置更新时间具体到分钟: 更新 date format 即可 - ‘YYYY MM DD HH:MM’</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 学习笔记</title>
      <link href="/posts/8508.html"/>
      <url>/posts/8508.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-架构"><a href="#MySQL-架构" class="headerlink" title="MySQL 架构"></a>MySQL 架构</h1><p><img src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/MySQL1.png" alt="img"></p><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>负责和客户端建立连接、获取权限、维持和管理连接。连接命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h $ip -P $port -u $user -p</span><br></pre></td></tr></table></figure><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><ol><li><strong>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</strong></li></ol><p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p><ol start="2"><li><strong>MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。</strong></li></ol><h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>词法、语法分析，分析你SQL语句中的各个字段，确保没有出错。比如识别SELECT 关键字，识别出表单名t.</p><p>select * from t;</p><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><ol><li>在表里面有多个索引的时候，决定使用哪个索引</li><li>在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;</span><br></pre></td></tr></table></figure><ul><li>既可以先从表 t1 里面取出 c&#x3D;10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。</li><li>也可以先从表 t2 里面取出 d&#x3D;20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。</li></ul><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><ol><li>判断执行权限</li><li>根据表的引擎定义，调用引擎接口去执行</li></ol><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><blockquote><p> 内容详见 - <a  href="/posts/356a30bc.html">MySQL-日志</a></p></blockquote><h2 id="redo-log-重做日志"><a href="#redo-log-重做日志" class="headerlink" title="redo log - 重做日志"></a>redo log - 重做日志</h2><p>采用WAL（Write - Ahead Logging）, 先写日志，后写磁盘。</p><p>详细介绍：</p><ul><li><a href="https://www.cnblogs.com/zlia/p/14508366.html">https://www.cnblogs.com/zlia/p/14508366.html</a></li><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/MySQL%e5%ae%9e%e6%88%9845%e8%ae%b2/02%20%20%e6%97%a5%e5%bf%97%e7%b3%bb%e7%bb%9f%ef%bc%9a%e4%b8%80%e6%9d%a1SQL%e6%9b%b4%e6%96%b0%e8%af%ad%e5%8f%a5%e6%98%af%e5%a6%82%e4%bd%95%e6%89%a7%e8%a1%8c%e7%9a%84%ef%bc%9f.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/MySQL%e5%ae%9e%e6%88%9845%e8%ae%b2/02%20%20%e6%97%a5%e5%bf%97%e7%b3%bb%e7%bb%9f%ef%bc%9a%e4%b8%80%e6%9d%a1SQL%e6%9b%b4%e6%96%b0%e8%af%ad%e5%8f%a5%e6%98%af%e5%a6%82%e4%bd%95%e6%89%a7%e8%a1%8c%e7%9a%84%ef%bc%9f.md</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/MySQL_RedoLog.webp" alt="img"></p><h2 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h2><p>存在于Server层。</p><h2 id="Undo-log"><a href="#Undo-log" class="headerlink" title="Undo log"></a>Undo log</h2><p>存储事务执行过程中数据修改前的<strong>旧值。<strong>目的在</strong>事务回滚</strong>时，能够利用这些旧值。</p><p>假设一个值从 1 被按顺序改成了 2、3、4，在<strong>回滚日志</strong>里面就会有类似下面的记录：</p><p><img src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/MySQL2.png" alt="img"></p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li>redo log是存储引擎特有的，bin log是在Server层实现的，也就是说所有引擎都可以使用。</li><li>redo log是物理日志，举个例子，比如你将某个值由1改成2，又将2改成3，那么最终物理日志呈现的只有3（而没有记录3的由来），只不过不是直接将3写入，可能是采用偏移量之类的操作方式（无奈我看不懂），bin log是逻辑日志，逻辑日志表示记录从1-2-3这样子的一个过程。</li><li>redo log是循环写的，大小是固定的，bin log是追加的方式写的，不会覆盖以前的日志。</li></ul><table><thead><tr><th><strong>特性</strong></th><th><strong>Redo Log (重做日志)</strong></th><th><strong>Bin Log (归档日志)</strong></th><th><strong>Undo Log (回滚日志)</strong></th></tr></thead><tbody><tr><td><strong>核心关键词</strong></td><td><strong>“恢复”</strong></td><td><strong>“复制”</strong></td><td><strong>“撤销”</strong></td></tr><tr><td><strong>比喻</strong></td><td>记账本的草稿 (防止断电忘事)</td><td>完整的账单明细 (给别人看)</td><td><strong>橡皮擦 &#x2F; Ctrl+Z</strong></td></tr><tr><td><strong>侧重点</strong></td><td>物理偏向 (页修改)</td><td>逻辑偏向 (SQL语义)</td><td><strong>逻辑反向</strong> (逆操作)</td></tr><tr><td><strong>主要作用</strong></td><td>崩溃恢复 (Crash Safe)<br><br>  <br><br>保证 <strong>D</strong> (持久性)</td><td>主从复制、数据恢复<br><br>  <br><br>保证数据一致性</td><td>事务回滚、MVCC<br><br>  <br><br>保证 <strong>A</strong> (原子性) 和 <strong>I</strong> (隔离性)</td></tr><tr><td><strong>写入时机</strong></td><td>事务进行中不断写</td><td>事务提交时一次性写</td><td>事务开始前&#x2F;修改前写</td></tr><tr><td><strong>释放时机</strong></td><td>落盘后覆盖 (循环写)</td><td>不删除 (追加写)</td><td>事务提交后，若无 MVCC 需求则标记删除 (Purge)</td></tr></tbody></table><h1 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h1><h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p>ACID，即对应原子性、一致性、隔离性、持久性。通过undo log来保证原子性，能够撤销事务内的所以操作来保证原子性，要么是全部都成功，通过redo log来保证持久性，会根据策略进行刷脏，通过锁+MVCC的方式来保证隔离性，而一致性指的是从一个正确的状态迁移到另外一个正确的状态下，其实就是通过事务中的AID来保证C。</p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>隔离级别越高，性能越低。如下的隔离级别逐次升高。</p><h3 id="读未提交-read-uncommited"><a href="#读未提交-read-uncommited" class="headerlink" title="读未提交 - read uncommited"></a>读未提交 - read uncommited</h3><p>当前事务可以读取到未提交的事务。这种级别会造成脏读、不可重复读、幻读</p><h3 id="读提交-read-commited"><a href="#读提交-read-commited" class="headerlink" title="读提交 - read commited"></a>读提交 - read commited</h3><p>当前事务能够读取已提交事务的修改，这种隔离级别会造成不可重复读、幻读</p><h3 id="可重复读-repeatable-read"><a href="#可重复读-repeatable-read" class="headerlink" title="可重复读 - repeatable read"></a>可重复读 - repeatable read</h3><p>当前事务一开始读的数据是什么样子，那在它提交之前一直都是这样子，即使多次读取。会有幻读问题，但是个人认为它<code>**不会造成幻读**</code>（通过MVCC + 锁的方式）；</p><h3 id="串行化-serializable"><a href="#串行化-serializable" class="headerlink" title="串行化 - serializable"></a>串行化 - serializable</h3><p>对于同一行记录，写操作会加写锁，读操作会加读锁，当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行</p><h2 id="各类读问题"><a href="#各类读问题" class="headerlink" title="各类读问题"></a>各类读问题</h2><h3 id="脏读（Dirty-Read）"><a href="#脏读（Dirty-Read）" class="headerlink" title="脏读（Dirty Read）"></a>脏读（Dirty Read）</h3><ul><li><strong>定义</strong>：脏读是指在一个事务处理过程中读取了另一个未提交事务修改的数据。也就是说，事务A读取了事务B正在修改但尚未提交的数据，之后如果事务B回滚，那么事务A读取的数据就是无效的、“脏”的数据。</li><li><strong>示例</strong>：假设有两个事务，事务A是一个查询操作，事务B是一个更新操作。事务B更新了数据库中某条记录的一个字段值，但还没提交。此时事务A查询这条记录，获取到了事务B修改后的字段值。随后，事务B由于某种原因回滚了，那么事务A之前读取到的字段值就不再有效，这种情况就是脏读。</li><li><strong>产生原因</strong>：主要是因为事务的隔离级别设置较低，允许一个事务读取另一个未提交事务的数据。在数据库并发操作中，如果没有适当的并发控制机制，就容易出现脏读现象。</li></ul><h3 id="不可重复读（Non-repeatable-Read）"><a href="#不可重复读（Non-repeatable-Read）" class="headerlink" title="不可重复读（Non - repeatable Read）"></a>不可重复读（Non - repeatable Read）</h3><ul><li><strong>定义</strong>：不可重复读是指在一个事务内，多次读取同一数据时，由于其他事务对该数据进行了修改或删除操作，导致每次读取的数据不一致。</li><li><strong>示例</strong>：事务A在开始时读取了数据库中某条记录的某个字段值为10。随后，事务B更新了这条记录的该字段值为20并提交。当事务A再次读取这条记录的该字段时，得到的值为20，与第一次读取的值不同，这种情况就是不可重复读。</li><li><strong>产生原因</strong>：这是由于事务的隔离级别没有完全限制其他事务对数据的修改操作。在多事务并发环境下，当一个事务允许其他事务在其执行过程中修改它正在读取的数据时，就可能出现不可重复读的情况。</li></ul><h3 id="幻读（Phantom-Read）"><a href="#幻读（Phantom-Read）" class="headerlink" title="幻读（Phantom Read）"></a>幻读（Phantom Read）</h3><ul><li><strong>定义</strong>：幻读是指在一个事务中，按照某个条件进行数据查询时，第一次查询和第二次查询得到的结果集数量不同。这通常是因为在两次查询之间，另一个事务插入或删除了满足查询条件的记录。</li><li><strong>示例</strong>：事务A查询数据库中年龄大于30岁的员工数量，得到结果为10人。在事务A执行期间，事务B插入了几条年龄大于30岁的新员工记录并提交。当事务A再次查询年龄大于30岁的员工数量时，得到的结果比第一次多，好像出现了“幻觉”一样，这种情况就是幻读。</li><li><strong>产生原因</strong>：主要是因为事务的隔离级别不能阻止其他事务插入或删除符合查询条件的记录。在并发事务环境下，当一个事务在执行过程中，其他事务对数据的插入或删除操作影响了该事务的查询结果集，就会产生幻读。</li></ul><h3 id="事务隔离级别与这三种情况的关系"><a href="#事务隔离级别与这三种情况的关系" class="headerlink" title="事务隔离级别与这三种情况的关系"></a>事务隔离级别与这三种情况的关系</h3><ul><li><strong>读未提交（Read Uncommitted）</strong>：这是最低的事务隔离级别，允许脏读、不可重复读和幻读。在这种隔离级别下，一个事务可以读取另一个未提交事务的数据，所以很容易出现上述三种情况。</li><li><strong>读已提交（Read Committed）</strong>：这种隔离级别可以避免脏读。在一个事务读取数据时，只能读取其他已提交事务的数据，但是仍然可能出现不可重复读和幻读。</li><li><strong>可重复读（Repeatable Read）</strong>：可以避免脏读和不可重复读。在一个事务执行期间，它所读取的数据不会被其他事务修改，但是可能会出现幻读。在一些数据库系统（如MySQL的InnoDB存储引擎）中，通过使用间隙锁等技术可以在一定程度上减少幻读的发生。</li><li><strong>串行化（Serializable）</strong>：这是最高的事务隔离级别，可以避免脏读、不可重复读和幻读。在这种隔离级别下，事务是串行执行的，相当于对并发事务进行了严格的限制，虽然保证了数据的一致性，但会严重影响系统的性能和并发处理能力。</li></ul><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>Multi Version Concurrency Control - 多版本并发控制，一种数据库并发控制的技术，用来实现各种事务隔离级别。</p><h2 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h2><p>读的是数据的历史版本。常用以实现不同事务之间的隔离。</p><p>MVCC 为每个事务提供了一个数据快照，事务在这个快照范围内读取数据。这个快照包含了在事务开始时已经提交的数据版本。通过快照读，事务可以避免受到其他事务在其执行过程中对数据进行修改的影响，从而实现了不同事务之间的隔离</p><p>SELECT 是快照读，如果加锁的话，便是当前读。</p><h2 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h2><p>读的是数据的最新版本。</p><p>常用于对数据实时性要求高的场景，比如<strong>增删改</strong>等用来<strong>更新数据</strong>的场景，都需要读取到数据的最新版本。</p><ul><li>更新数据 - UPDATE 、DELETE、INSERT</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>MVCC 的核心思想是为每个事务提供一个数据快照（snapshot）。当一个事务开始时，它会看到数据库在某个特定时刻的状态，并且在整个事务期间，这个状态对于该事务是相对固定的。这意味着，即使其他事务对数据进行了修改，当前事务看到的仍然是它开始时的数据版本。</li><li>数据库会为每个数据行保存多个版本，这些版本可以通过时间戳或者版本号来区分。每当数据被修改时，不是直接覆盖原来的数据，而是创建一个新的版本。例如，在一个简单的银行账户余额数据表中，当用户 A 进行取款操作修改余额数据时，数据库不会立即删除原来的余额记录，而是创建一个新的余额版本记录，并标记上相应的事务时间戳或者版本号。</li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>提高并发性能：不会因为锁的竞争而导致系统性能下降。每个事务看到的是自己的版本数据，读写操作不会阻塞</li><li>保证数据一致性和隔离性：MVCC 能够提供不同的事务隔离级别，通过合理设置版本号或时间戳的检查规则，可以实现如读已提交（Read Committed）、可重复读（Repeatable Read）等隔离级别。</li></ul><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>InnoDB使用B+树作为索引模型。</p><ul><li>非叶子节点不保存数据</li><li>叶子节点间使用 指针相连，并按照大小顺序排列</li></ul><h2 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h2><p>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为<strong>聚簇索引</strong>（clustered index）。非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为<strong>二级索引</strong>（secondary index）。</p><h2 id="如何选择索引"><a href="#如何选择索引" class="headerlink" title="如何选择索引"></a>如何选择索引</h2><ul><li>基于索引的“区分度”来选择，一个索引上不同的值越多，区分度越高。索引上不同的值的个数，我们称之为“基数”（cardinality），也就是说，这个基数越大，索引的区分度越好。</li></ul><h2 id="如何加索引"><a href="#如何加索引" class="headerlink" title="如何加索引"></a>如何加索引</h2><p>针对超长字符串，可以考虑选择如下其一方式建立索引：</p><ul><li>倒序存储+前缀索引</li><li>添加hash字段，为其建立索引，crc32</li></ul><h2 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h2><p>普通索引，也就是通过二级索引找到对应的主键，在通过主键找到所需要的数据，这个过程就叫做回表，如果直接通过二级索引就能找到数据的话是不需要回表的。</p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>如果查找的列本身就在二级索引上，那么就不要回表了，这样子的索引叫做覆盖索引，通常用来减少回表的次数以提高性能。</p><h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>使用多个字段组合的索引，假设有联合索引（a，b），那么在索引树中它会先根据a的大小进行排序，如果有相同值的a在按照b的大小进行排序。</p><h3 id="最左前缀"><a href="#最左前缀" class="headerlink" title="最左前缀"></a>最左前缀</h3><p>可以是联合索引的最左N个字段，比如说有联合索引（a，b，c），那么等值查询条件是a &#x3D; 1的时候会用到联合索引中的部分索引a，条件是a &#x3D; 1 and b &#x3D; 2的时候会用到联合索引中的部分索引（a，b），同理条件是a &#x3D; 1 and b &#x3D; 2 and c &#x3D; 3，而对于条件是a &#x3D; 1 and c &#x3D; 3的情况下会使用也只能用到联合索引中的部分索引a。</p><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><ol><li><strong>索引下推（Index Condition Pushdown，ICP）概述</strong></li></ol><ul><li><strong>定义</strong>：索引下推是一种数据库查询优化技术，主要应用于数据库引擎（如MySQL的InnoDB存储引擎）在处理联合索引查询时。它的基本思想是将原本需要在服务器层（MySQL Server）进行的部分条件判断下推到存储引擎层（InnoDB），在索引遍历过程中就进行条件过滤，从而减少不必要的数据回表操作，提高查询效率。</li><li><strong>背景</strong>：在没有索引下推之前，当使用联合索引进行查询时，存储引擎通过索引获取到满足部分索引列条件的数据行的主键（以InnoDB为例），然后将这些主键对应的完整数据行回表（回到数据表）读取，最后在服务器层对这些完整的数据行进行其他剩余条件的判断。这种方式可能会导致大量不必要的数据回表操作，浪费系统资源。</li></ul><ol start="2"><li><strong>索引下推的工作原理</strong></li></ol><ul><li><p>假设在一个<code>employees</code>表中有一个联合索引<code>idx_name_age</code>（包含<code>name</code>和<code>age</code>两个列），现在要执行一个查询<code>SELECT * FROM employees WHERE name LIKE &#39;J%&#39; AND age &gt; 30;</code>。</p></li><li><p><strong>传统方式</strong>：</p></li><li><p>存储引擎首先使用联合索引<code>idx_name_age</code>找到<code>name</code>以<code>J</code>开头的所有记录的主键值。</p></li><li><p>然后对这些主键值对应的记录进行回表操作，将完整的数据行读取到服务器层。</p></li><li><p>最后在服务器层判断这些记录的<code>age</code>是否大于30，筛选出满足条件的记录。</p></li><li><p><strong>索引下推方式</strong>：</p></li><li><p>存储引擎在遍历联合索引<code>idx_name_age</code>时，不仅会检查<code>name</code>列是否以<code>J</code>开头，还会同时检查<code>age</code>列是否大于30。只有当<code>name</code>和<code>age</code>条件都满足的索引记录对应的主键才会被用来进行回表操作，读取完整的数据行。这样就避免了许多不满足<code>age &gt; 30</code>条件的记录的回表操作，减少了数据读取量和系统开销。</p></li></ul><ol start="3"><li><strong>索引下推的优势</strong></li></ol><ul><li><strong>减少回表操作次数</strong>：通过在存储引擎层提前过滤掉不符合条件的数据，大大减少了回表操作的频率。回表操作通常涉及磁盘I&#x2F;O或者缓存读取，减少回表操作可以显著提高查询性能，尤其是在处理大量数据和复杂查询时。</li><li><strong>提高查询效率</strong>：由于减少了不必要的数据读取和处理，查询的整体效率得到提升。在高并发的数据库环境中，这种性能提升可以使系统能够更快速地响应大量的查询请求。</li></ul><ol start="4"><li><strong>索引下推的限制和注意事项</strong></li></ol><ul><li><strong>对索引的依赖</strong>：索引下推是基于索引进行操作的，只有在使用联合索引并且有可以下推的条件时才能发挥作用。如果查询条件没有涉及联合索引或者没有合适的下推条件，就无法利用索引下推。</li><li><strong>不同数据库引擎的支持情况</strong>：不是所有的数据库引擎都支持索引下推。目前MySQL的InnoDB存储引擎支持索引下推，但其他数据库引擎可能需要具体查看其文档来确定是否支持以及支持的程度。</li><li><strong>与其他优化技术的结合</strong>：在实际的数据库优化中，索引下推通常需要与其他优化技术（如合理的索引设计、查询语句优化等）结合使用，才能达到最佳的性能提升效果。例如，即使有索引下推，如果索引本身设计不合理（如索引列的顺序不符合查询习惯等），查询效率可能仍然不高。</li></ul><h2 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h2><p>B+树的叶子节点会按照从小到大的顺序排列，如果插入的主键要处于中间位置，那么需要移动后面的数据来腾出位置，而如果在插入之前数据页就已经满了的话，那么就需要将后面的部分数据移动至另外一个数据页上，这个过程就叫做页分裂。</p><h2 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a>页合并</h2><p>当相邻两个数据页由于删除了数据之后，整个的空间变小了，那么就会将两个数据页进行合并，以提高数据页空间的利用率。</p><h2 id="重建二级索引和重建主键索引"><a href="#重建二级索引和重建主键索引" class="headerlink" title="重建二级索引和重建主键索引"></a>重建二级索引和重建主键索引</h2><p>首先重建索引是为了让数据页的空间得到充分利用，也就省去了很多空间的浪费，对于重建二级索引来说是可以先删除掉索引在增加，对于重建主键索引的话如果先删除的话，它会使二级索引失效（由于重建主键索引，重新计算后的指针会发生变化），正确地重建主键索引是：ALTER TABLE T ENGINE &#x3D; INNODB，或者是迁移数据库，不过这种方式只适合离线的业务。</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>给整个数据库实例加 <strong>读锁 -</strong> <code>**Flush tables with read lock**</code>, 其他线程的增删读写会被阻塞，使用 <code>**unlock tables**</code>进行解除。</p><p>为什么使用全局锁而不要使用全库只读（set global readonly &#x3D; true）：一方面是readonly通常会被用来做其他的逻辑，比如说用来判断主备库，随意修改全局变量可能会影响；另外一方面使用全局锁的客户端如果崩溃了的话，MySQL会自动释放锁，整个库可以回到正常更新的状态，而将整个库设置为readonly之后，如果客户端发生异常，则数据库会一直保持readonly状态，导致整个库长时间处于不可写状态。</p><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><p>加表锁 - <code>lock tables t1 read/write</code></p><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><ul><li>二阶段锁协议：在事务中，只有提交(commit)或者回滚(rollback)时才是解锁阶段， 其余时间为加锁阶段。</li><li>发起死锁检测：<strong>innodb_deadlock_detect</strong>设置为on，默认情况下是on，缺点就是会耗费大量的CPU资源（发现死锁后主动回滚某一个事务，让其他事务得以继续执行）。</li></ul><h2 id="元数据锁-metadata-lock-MDL"><a href="#元数据锁-metadata-lock-MDL" class="headerlink" title="元数据锁 - metadata lock - MDL"></a>元数据锁 - metadata lock - MDL</h2><p>属于Server层的锁，表级锁，主要用于隔离DML和DDL操作之间的干扰，比如一个线程在查询数据的时候，另外一个线程肯定不能修改表结构，不然就乱套了，所以DML操作需要申请MDL读锁，而DDL操作需要申请MDL写锁，读读之间共享，读写之间互斥，写写之间互斥。</p><ul><li>DML：数据库操作语言</li><li>DDL：数据库定义语言</li><li>MDL 读锁 - 共享读锁：当一个事务只是读取数据库对象的元数据（如查询表的结构信息）时，会获取共享读锁。这种锁<strong>允许多个事务同时对同一对象的元数据进行读取操作</strong>，但<strong>不允许其他事务对该对象的元数据进行修改操作</strong>。</li><li>MDL 写锁- 排他锁：当一个事务需要修改数据库对象的元数据（如添加列、修改表结构等）时，会获取排他锁。这种锁会<strong>阻止其他事务对该对象的元数据进行读取或修改操作</strong>，直到该事务完成对元数据的修改并释放锁。</li></ul><h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><ul><li>脏页：指内存（缓存池）中的数据页与磁盘上的数据页不一致的情况。数据库表单的增删改等写操作，都会产生脏页。</li></ul><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ul><li><a href="https://zzk.cnblogs.com/s/blogpost?Keywords=blog:zlia%20mysql45&pageindex=1">https://zzk.cnblogs.com/s/blogpost?Keywords=blog%3Azlia%20mysql45&amp;pageindex=1</a></li><li><a href="https://www.cnblogs.com/zlia/p/14571050.html">https://www.cnblogs.com/zlia/p/14571050.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APNS</title>
      <link href="/posts/45153.html"/>
      <url>/posts/45153.html</url>
      
        <content type="html"><![CDATA[<p><strong>APNS</strong>、<strong>iPhone</strong>（设备）和 <strong>后台服务器（Server）</strong> 三者之间的关系和数据流。</p><p>以下是APNS的时序图，展示了设备、APNS和服务器之间的交互流程：<br>使用 code block - mermaid</p><div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>    sequenceDiagram    participant I as iPhone (设备)    participant A as APNS    participant S as Server (后台服务器)    autonumber        %% 设备注册推送并获取设备令牌    I-&gt;&gt;A: 注册推送通知 (registerForRemoteNotifications)    A--&gt;&gt;I: 返回设备令牌 (Device Token)    I-&gt;&gt;S: 发送设备令牌给后台服务器 (via HTTPS)    %% 设备与 APNS 建立长连接    I-&gt;&gt;A: 建立 TCP 长连接 (端口 5223&#x2F;443)    Note right of A: 长连接维持，设备主动发起    %% 推送通知流程    S-&gt;&gt;A: 发送推送请求 (HTTP&#x2F;2, 携带 Device Token)    Note right of S: 短连接，按需发起    A-&gt;&gt;I: 通过长连接推送通知给设备    Note right of I: 系统处理通知 (显示&#x2F;角标等)    %% 断网后重连    I--xA: 网络断开，长连接中断    I-&gt;&gt;A: 网络恢复，主动重连 (携带 Device Token)    Note right of A: APNS 更新连接状态    %% 再次推送    S-&gt;&gt;A: 发送新的推送请求    A-&gt;&gt;I: 通过新连接推送通知  </pre></div><blockquote><p>可以在 <a href="https://mermaid.live/">https://mermaid.live</a> 在线编辑和渲染Mermaid图表</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> APNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI Agent 技术核心概念学习路线</title>
      <link href="/posts/51504.html"/>
      <url>/posts/51504.html</url>
      
        <content type="html"><![CDATA[<h3 id="LLM应用技术核心概念学习路线"><a href="#LLM应用技术核心概念学习路线" class="headerlink" title="LLM应用技术核心概念学习路线"></a><strong>LLM应用技术核心概念学习路线</strong></h3><p>这条路线遵循从“基础构件”到“核心能力”再到“高级模式”的逻辑。</p><hr><h4 id="第一阶段：理解基石——让计算机“懂得”含义（Embedding）"><a href="#第一阶段：理解基石——让计算机“懂得”含义（Embedding）" class="headerlink" title="第一阶段：理解基石——让计算机“懂得”含义（Embedding）"></a><strong>第一阶段：理解基石——让计算机“懂得”含义（Embedding）</strong></h4><ul><li><strong>核心问题</strong>：计算机只认识数字，我们如何让它们理解文字、图片、视频的“意思”？</li><li><strong>什么是 Embedding（嵌入）？</strong> <strong>比喻</strong>：想象一个“语义地图”。每个词（或句子、图片）都是这个地图上的一个点。含义相近的词（如“国王”和“皇帝”）在地图上的位置会非常接近；含义相反的词（如“国王”和“平民”）则相距甚远。 <strong>本质</strong>：Embedding 就是一套算法，将非结构化的数据（文字、图片等）转换成一串有意义的数字向量。这个向量就是数据点在“语义地图”上的<strong>坐标</strong>。 **为什么需要？**只有把数据变成数字坐标，计算机才能进行数学计算，从而比较相似性、进行分类、聚类等操作。<strong>这是后续所有技术的基础。</strong></li></ul><h4 id="第二阶段：实现检索——构建“外部记忆库”（向量数据库）"><a href="#第二阶段：实现检索——构建“外部记忆库”（向量数据库）" class="headerlink" title="第二阶段：实现检索——构建“外部记忆库”（向量数据库）"></a><strong>第二阶段：实现检索——构建“外部记忆库”（向量数据库）</strong></h4><ul><li><strong>核心问题</strong>：有了“语义地图”，但当数据量极其庞大时（比如整个公司知识库），如何快速找到与问题最相关的信息？</li><li><strong>为什么需要向量数据库？</strong> <strong>传统数据库的局限</strong>：它们擅长精确匹配（如“找到id&#x3D;1的用户”），但不擅长模糊查询（如“找到意思最接近‘可持续发展’的文档”）。 <strong>向量数据库的强项</strong>：它就是为“语义地图”量身定制的数据库。它专门做一件事——<strong>近似最近邻搜索</strong>。你给它一个问题的坐标（问题本身的向量），它能以极快的速度在整个海量向量库中，找到坐标最接近的几个点（即语义最相关的文本片段）。 <strong>本质</strong>：向量数据库是LLM的“外部记忆库”或“知识索引系统”，负责高效、精准地检索信息。</li></ul><h4 id="第三阶段：衡量相关性——定义“相似”的标准（Cosine-Similarity）"><a href="#第三阶段：衡量相关性——定义“相似”的标准（Cosine-Similarity）" class="headerlink" title="第三阶段：衡量相关性——定义“相似”的标准（Cosine Similarity）"></a><strong>第三阶段：衡量相关性——定义“相似”的标准（Cosine Similarity）</strong></h4><ul><li><strong>核心问题</strong>：在“语义地图”上，如何数学地定义两个点“相似”？是看它们的直线距离吗？</li><li><strong>Cosine Similarity（余弦相似度）到底在算个啥？</strong> <strong>比喻</strong>：不比“距离”，比“方向”。想象两个从原点出发的箭头。我们不关心箭头的长短（向量的绝对大小，比如文档的长短），只关心两个箭头指向的方向是否一致。 <strong>计算什么</strong>：它计算的是两个向量之间夹角的余弦值。夹角为0度（方向完全一致），余弦值为1，表示完全相似；夹角为90度（方向垂直），余弦值为0，表示不相关。 <strong>为什么在NLP中常用</strong>：因为它更关注语义上的方向性，而忽略文本长度的影响，这更符合我们判断“意思是否相似”的直觉。</li></ul><p><strong>👉 至此，你已经掌握了RAG的“检索”部分的核心技术栈：<code>文本 -&gt; Embedding -&gt; 向量数据库 -&gt; 余弦相似度检索</code>。</strong></p><hr><h4 id="第四阶段：构建应用——给LLM“开小灶”（RAG）"><a href="#第四阶段：构建应用——给LLM“开小灶”（RAG）" class="headerlink" title="第四阶段：构建应用——给LLM“开小灶”（RAG）"></a><strong>第四阶段：构建应用——给LLM“开小灶”（RAG）</strong></h4><ul><li><strong>核心问题</strong>：LLM内部知识老旧、会产生幻觉（胡说八道），如何让它能回答未知的、专业领域的问题？</li><li><strong>RAG（检索增强生成）的本质是什么？</strong> <strong>不只是“喂知识库”</strong>：你的理解非常到位。它的本质是<strong>将LLM的推理能力与外部知识源的动态检索能力相结合</strong>。 <strong>工作流程</strong>： <strong>检索</strong>：当用户提出问题时，<strong>不直接</strong>将问题扔给LLM。而是先用上面的技术栈（Embedding+向量数据库+相似度计算），从外部知识库中“精准地检索”出与问题最相关的几段信息（上下文）。 <strong>增强</strong>：将“<strong>原始问题 + 检索到的精准上下文</strong>”一起打包，作为一个新的、信息更丰富的提示词（Prompt）交给LLM。 <strong>生成</strong>：LLM基于这个包含了“标准答案”线索的Prompt来生成回答。 <strong>核心挑战与你的思考一致</strong>：如何“精准地检索”？如果检索到的信息不相关，LLM的回答就会跑偏。因此，检索器的质量（Embedding模型、向量数据库、排序算法）直接决定了RAG的天花板。 <strong>它解决了</strong>：知识更新问题（改知识库即可）、幻觉问题（答案有据可查）、溯源问题（可以注明答案来源）。</li></ul><hr><h4 id="第五阶段：升级交互——让LLM“学会使用工具”（Function-Calling-ReAct）"><a href="#第五阶段：升级交互——让LLM“学会使用工具”（Function-Calling-ReAct）" class="headerlink" title="第五阶段：升级交互——让LLM“学会使用工具”（Function Calling &amp; ReAct）"></a><strong>第五阶段：升级交互——让LLM“学会使用工具”（Function Calling &amp; ReAct）</strong></h4><ul><li><strong>核心问题</strong>：LLM无法感知实时信息（天气、股价），无法执行具体动作（发邮件、查数据库）。如何让它与外部世界互动？</li><li><strong>Function Calling（函数调用）的工作流程是怎样的？</strong> <strong>比喻</strong>：给LLM一个“工具清单”，上面列出了每个工具的名称、功能和用法说明（这就是所谓的“函数模式”或“工具模式”）。 <strong>工作流程</strong>： <strong>用户请求</strong>：用户提出一个需要工具的请求，如“今天北京天气怎么样？” <strong>LLM分析</strong>：LLM不会直接回答，而是分析请求，然后<strong>从“工具清单”中选择最合适的工具</strong>（如 <code>get_weather(location)</code>）。 <strong>输出调用指令</strong>：LLM<strong>不执行</strong>，而是<strong>返回一个结构化的调用请求</strong>，如 <code>{&quot;name&quot;: &quot;get_weather&quot;, &quot;arguments&quot;: {&quot;location&quot;: &quot;北京&quot;}}</code>。 <strong>程序执行</strong>：你的外部程序收到这个结构化请求，<strong>代为执行</strong>真正的函数调用（比如调用天气API）。 <strong>返回结果</strong>：将执行结果（如<code>{&quot;city&quot;: &quot;北京&quot;, &quot;temperature&quot;: &quot;25°C&quot;}</code>）再交回给LLM。 <strong>LLM组织回答</strong>：LLM将API返回的原始数据组织成自然语言回答用户：“今天北京天气晴朗，气温25摄氏度。” <strong>本质</strong>：一个<strong>决策-执行</strong>的<strong>单次回合</strong>。LLM负责“思考”该用什么工具、传入什么参数，外部系统负责“执行”。</li><li><strong>ReAct（Reasoning and Acting）模式是怎么让交互更进一步的？</strong> <strong>比喻</strong>：Function Calling 是LLM下达一个命令。而ReAct是LLM在<strong>模拟一个人解决复杂问题的完整思考过程</strong>，这个过程可能包含多个“思考-行动-观察”的循环。 <strong>工作流程</strong>：对于复杂问题（如“我们公司今年销售额最高的产品是什么，它的主要客户画像是什么？”）： <strong>Reason（思考）</strong>：LLM会<strong>先产生一段内部推理</strong>，例如：“要回答这个问题，我需要两步。首先，需要查询数据库找到销售额最高的产品ID。然后，再根据这个产品ID去查询客户画像数据。” <strong>Act（行动）</strong>：根据推理，LLM决定下一步行动，比如调用 <code>query_database(sql=&quot;SELECT ...&quot;)</code>函数。这一步类似Function Calling。 <strong>Observe（观察）</strong>：外部系统执行函数，返回结果（如产品ID是<code>P-1001</code>）。这个结果被反馈给LLM。 <strong>循环</strong>：LLM接收到观察结果，<strong>再次进行Reasoning</strong>：“好的，我已经拿到了产品ID是P-1001。接下来，我需要查询客户表…” 然后再次 <strong>Act</strong>，调用另一个函数… <strong>本质</strong>：一个<strong>多步推理的循环框架</strong>。它通过强制LLM展示“思维链”，使其规划能力更强，更能处理需要多步骤工具调用的复杂任务。</li></ul><h3 id="总结：你的学习路径图"><a href="#总结：你的学习路径图" class="headerlink" title="总结：你的学习路径图"></a><strong>总结：你的学习路径图</strong></h3><ol><li><strong>从Embedding开始</strong>：理解一切是如何从“将信息转化为语义空间坐标”开始的。</li><li><strong>学习向量数据库和相似度计算</strong>：理解如何在这个空间里进行高效、精准的检索。这是RAG的基石。</li><li><strong>深入理解RAG</strong>：掌握如何通过检索外部知识来增强LLM，解决其核心痛点。</li><li><strong>学习Function Calling</strong>：理解LLM与外部工具交互的基本单元。</li><li><strong>最终掌握ReAct模式</strong>：理解如何利用LLM的推理能力，串联多个Function Calling来解决复杂问题。</li></ol><p>这条路线清晰地展示了现代LLM应用是如何一步步被构建起来的：<strong>从静态的知识检索（RAG），到动态的工具使用（Function Calling），再到复杂的任务分解与规划（ReAct）</strong>。祝你学习顺利！</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI-Agent </tag>
            
            <tag> LLM </tag>
            
            <tag> RAG </tag>
            
            <tag> Function-Calling </tag>
            
            <tag> ReAct </tag>
            
            <tag> Embedding </tag>
            
            <tag> 向量数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MCP（Model Context Protocol）详解</title>
      <link href="/posts/27915.html"/>
      <url>/posts/27915.html</url>
      
        <content type="html"><![CDATA[<h2 id="What-is-the-MCP"><a href="#What-is-the-MCP" class="headerlink" title="What is the MCP?"></a>What is the MCP?</h2><ul><li>MCP (Model Context Protocol) is an <strong>open-source standard</strong> for connecting AI applications to external systems.</li><li>Using MCP, AI applications like Claude or ChatGPT can connect to <strong>data sources</strong> (e.g. local files, databases), <strong>tools</strong> (e.g. search engines, calculators) and <strong>workflows</strong> (e.g. specialized prompts)—enabling them to access key information and perform tasks.</li><li>Think of MCP like a USB-C port for AI applications. Just as USB-C provides a standardized way to connect electronic devices, MCP provides a standardized way to connect AI applications to external systems.</li></ul><p><img src="https://mintcdn.com/mcp/bEUxYpZqie0DsluH/images/mcp-simple-diagram.png?fit=max&auto=format&n=bEUxYpZqie0DsluH&q=85&s=35268aa0ad50b8c385913810e7604550" alt="img"></p><h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><p>Key participants in the MCP architecture are:</p><ul><li><strong>MCP Host</strong>: The AI application that coordinates and manages one or multiple MCP clients</li><li><strong>MCP Client</strong>: A component that maintains a connection to an MCP server and obtains context from an MCP server for the MCP host to use</li><li><strong>MCP Server</strong>: A program that provides context to MCP clients</li></ul><p><img src="/../Pics/WX20251124-172727@2x.png" alt="img"></p><h4 id="Data-Layer"><a href="#Data-Layer" class="headerlink" title="Data Layer"></a>Data Layer</h4><p>Defines the <a href="https://en.wikipedia.org/wiki/JSON-RPC#Implementations"><strong>JSON-RPC</strong></a> based protocol for client-server communication, including lifecycle management, and core primitives, such as tools, resources, prompts and notifications.</p><p>Core Primitives:</p><ul><li><strong>Tools</strong>: Executable functions that AI applications can invoke to perform actions (e.g., file operations, API calls, database queries)</li><li><strong>Resources</strong>: Data sources that provide contextual information to AI applications (e.g., file contents, database records, API responses)</li><li><strong>Prompts</strong>: Reusable templates that help structure interactions with language models (e.g., system prompts, few-shot examples)</li></ul><h4 id="Transport-Layer"><a href="#Transport-Layer" class="headerlink" title="Transport Layer"></a>Transport Layer</h4><p>Defines the communication mechanisms and channels that enable data exchange between clients and servers, including transport-specific connection establishment, message framing, and authorization.</p><ul><li><strong>STDIO</strong> : Uses standard input&#x2F;output streams for direct process communication between <strong>local processes</strong> on the same machine, providing optimal performance with no network overhead.</li><li><strong>Server-Sent Events (SSE)</strong> : This approach required two separate endpoints:<ol><li>An SSE endpoint (<code>/sse</code>) that established a persistent connection for the client to receive responses</li><li>A separate messages endpoint (<code>/sse/messages</code>) where clients would send request</li></ol></li><li><strong>Streamable HTTP</strong> : Offers a more elegant solution by enabling <strong>bidirectional communication through a single endpoint</strong>.</li></ul><p><img src="https://picx.zhimg.com/50/v2-987260a35809fece3edb804df7691c0a_720w.jpg?source=2c26e567" alt="img"></p><h2 id="Develop-a-MCP-Server"><a href="#Develop-a-MCP-Server" class="headerlink" title="Develop a MCP Server"></a>Develop a MCP Server</h2><ol><li>Integrate MCP SDK</li><li>Develop tools&#x2F;resources&#x2F;prompts as your business needs</li><li>Debug it with MCP Inspector</li></ol>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MCP </tag>
            
            <tag> Model Context Protocol </tag>
            
            <tag> AI </tag>
            
            <tag> Claude </tag>
            
            <tag> 协议标准 </tag>
            
            <tag> 开发指南 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代身份认证与授权技术完全指南 - OAuth、JWT、SAML 等协议详解</title>
      <link href="/posts/64545.html"/>
      <url>/posts/64545.html</url>
      
        <content type="html"><![CDATA[<h1 id="认证和授权完全指南"><a href="#认证和授权完全指南" class="headerlink" title="认证和授权完全指南"></a>认证和授权完全指南</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在现代网络安全体系中，<strong>认证（Authentication）</strong> 和 <strong>授权（Authorization）</strong> 是保障系统安全的两大核心机制：</p><ul><li><strong>认证</strong>：验证用户身份（”你是谁？”）</li><li><strong>授权</strong>：确认访问权限（”你能做什么？”）</li></ul><p>本文将从协议和Token两个维度，系统性阐述认证授权的技术体系。</p><hr><h2 id="一、认证授权协议体系"><a href="#一、认证授权协议体系" class="headerlink" title="一、认证授权协议体系"></a>一、认证授权协议体系</h2><h3 id="1-OAuth-2-0-授权标准协议"><a href="#1-OAuth-2-0-授权标准协议" class="headerlink" title="1. OAuth 2.0 - 授权标准协议"></a>1. OAuth 2.0 - 授权标准协议</h3><p><strong>OAuth 2.0</strong> 是现代互联网授权的基石，专注于<strong>授权</strong>（资源访问权限的委派），而非直接处理用户身份认证。</p><h4 id="核心角色"><a href="#核心角色" class="headerlink" title="核心角色"></a>核心角色</h4><table><thead><tr><th>角色</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>资源所有者（Resource Owner）</td><td>拥有资源的用户</td><td>微信用户</td></tr><tr><td>客户端（Client）</td><td>请求访问资源的应用</td><td>第三方小程序</td></tr><tr><td>授权服务器（Authorization Server）</td><td>颁发Token的服务</td><td>微信授权服务器</td></tr><tr><td>资源服务器（Resource Server）</td><td>存储受保护资源的服务</td><td>微信用户信息API</td></tr></tbody></table><h4 id="四种授权模式"><a href="#四种授权模式" class="headerlink" title="四种授权模式"></a>四种授权模式</h4><ol><li><p><strong>授权码模式（Authorization Code）</strong></p><ul><li><strong>适用场景</strong>：Web应用（服务端安全）</li><li><strong>安全性</strong>：最高，推荐使用</li><li><strong>流程</strong>：用户授权 → 获取授权码 → 后端交换Token</li></ul></li><li><p><strong>隐式模式（Implicit）</strong></p><ul><li><strong>适用场景</strong>：SPA或原生App（客户端不安全）</li><li><strong>注意</strong>：OAuth 2.1已废弃，建议使用PKCE</li></ul></li><li><p><strong>密码模式（Resource Owner Password Credentials）</strong></p><ul><li><strong>适用场景</strong>：高度信任的客户端</li><li><strong>风险</strong>：直接暴露用户密码</li></ul></li><li><p><strong>客户端凭证模式（Client Credentials）</strong></p><ul><li><strong>适用场景</strong>：服务端间通信（无用户参与）</li><li><strong>特点</strong>：机器对机器的授权</li></ul></li></ol><h4 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h4><ul><li>第三方登录（微信、QQ、GitHub登录）</li><li>API访问控制</li><li>移动应用授权</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/OAuth.webp" alt="img"></p><h3 id="2-OpenID-Connect-OIDC-身份认证层"><a href="#2-OpenID-Connect-OIDC-身份认证层" class="headerlink" title="2. OpenID Connect (OIDC) - 身份认证层"></a>2. OpenID Connect (OIDC) - 身份认证层</h3><p><strong>OpenID Connect</strong> 在OAuth 2.0基础上扩展，专门解决<strong>身份认证</strong>问题，是OAuth 2.0 + 身份认证的完整解决方案。</p><h4 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h4><ul><li><strong>ID Token</strong>：JWT格式，包含用户身份信息（如姓名、邮箱、用户ID）</li><li><strong>UserInfo端点</strong>：通过Access Token获取用户详细信息</li><li><strong>标准化声明</strong>：定义了标准的用户属性字段</li></ul><h4 id="OIDC-流程"><a href="#OIDC-流程" class="headerlink" title="OIDC 流程"></a>OIDC 流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 用户访问客户端应用</span><br><span class="line">2. 重定向到OIDC提供商进行认证</span><br><span class="line">3. 用户授权后返回授权码</span><br><span class="line">4. 客户端交换授权码获取Token</span><br><span class="line">5. 返回Access Token + ID Token</span><br><span class="line">6. 通过UserInfo端点获取用户信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/OIDC.webp" alt="img"></p><h4 id="典型应用场景-1"><a href="#典型应用场景-1" class="headerlink" title="典型应用场景"></a>典型应用场景</h4><ul><li><strong>企业SSO</strong>：使用Google Workspace登录企业应用</li><li><strong>消费级SSO</strong>：使用Apple ID登录第三方应用</li><li><strong>跨域认证</strong>：多个子域名系统的统一登录</li></ul><h3 id="3-SAML-2-0-企业级身份联邦"><a href="#3-SAML-2-0-企业级身份联邦" class="headerlink" title="3. SAML 2.0 - 企业级身份联邦"></a>3. SAML 2.0 - 企业级身份联邦</h3><p><strong>SAML 2.0</strong> 是企业级<strong>认证与授权</strong>标准，基于XML实现跨域单点登录，在企业环境中广泛部署。</p><h4 id="核心架构"><a href="#核心架构" class="headerlink" title="核心架构"></a>核心架构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Identity Provider (IdP) ←→ Service Provider (SP)</span><br><span class="line">      ↓                           ↓</span><br><span class="line">   用户认证                    资源访问</span><br></pre></td></tr></table></figure><h4 id="关键组件"><a href="#关键组件" class="headerlink" title="关键组件"></a>关键组件</h4><ul><li><strong>断言（Assertion）</strong>：XML格式的安全声明，包含用户身份和权限信息</li><li><strong>身份提供者（IdP）</strong>：认证用户并生成SAML断言（如企业AD）</li><li><strong>服务提供者（SP）</strong>：依赖IdP的断言提供服务访问（如SaaS应用）</li></ul><h4 id="SAML-SSO-流程"><a href="#SAML-SSO-流程" class="headerlink" title="SAML SSO 流程"></a>SAML SSO 流程</h4><ol><li>用户访问SP应用</li><li>SP重定向到企业IdP</li><li>IdP验证用户身份</li><li>生成SAML断言并返回SP</li><li>SP验证断言并授权访问</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/SAML.webp" alt="img"></p><h4 id="企业应用场景"><a href="#企业应用场景" class="headerlink" title="企业应用场景"></a>企业应用场景</h4><ul><li><strong>Office 365集成</strong>：通过ADFS实现企业SSO</li><li><strong>SaaS应用集成</strong>：Salesforce、ServiceNow等企业应用</li><li><strong>混合云环境</strong>：本地AD与云服务的身份联邦</li></ul><h3 id="4-Kerberos-票据认证协议"><a href="#4-Kerberos-票据认证协议" class="headerlink" title="4. Kerberos - 票据认证协议"></a>4. Kerberos - 票据认证协议</h3><p><strong>Kerberos</strong> 是基于票据的网络认证协议，通过密钥分发中心（KDC）实现安全认证，有效防止中间人攻击。</p><h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><ul><li><strong>KDC（Key Distribution Center）</strong>：密钥分发中心</li><li><strong>TGT（Ticket-Granting Ticket）</strong>：用户首次认证后的长期票据</li><li><strong>服务票据（Service Ticket）</strong>：访问具体服务的临时票据</li></ul><h4 id="Kerberos-认证流程"><a href="#Kerberos-认证流程" class="headerlink" title="Kerberos 认证流程"></a>Kerberos 认证流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Client → AS (Authentication Server): AS_REQ</span><br><span class="line">AS → Client: AS_REP (TGT)</span><br><span class="line">Client → TGS (Ticket-Granting Server): TGS_REQ (TGT)</span><br><span class="line">TGS → Client: TGS_REP (Service Ticket)</span><br><span class="line">Client → Service: AP_REQ (Service Ticket)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/Kerberos.webp" alt="img"></p><h3 id="5-LDAP-目录服务协议"><a href="#5-LDAP-目录服务协议" class="headerlink" title="5. LDAP - 目录服务协议"></a>5. LDAP - 目录服务协议</h3><p><strong>LDAP（Lightweight Directory Access Protocol）</strong> 是访问和维护目录服务的标准协议，主要用于用户和组织信息的查询与管理。</p><h4 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h4><ul><li><strong>目录查询</strong>：用户、组织架构、权限信息查询</li><li><strong>身份验证</strong>：用户名密码验证</li><li><strong>属性管理</strong>：用户属性的增删改查</li></ul><h4 id="常见实现"><a href="#常见实现" class="headerlink" title="常见实现"></a>常见实现</h4><ul><li><strong>Microsoft Active Directory (AD)</strong>：Windows域环境的标准</li><li><strong>OpenLDAP</strong>：开源LDAP实现</li><li><strong>Apache Directory Server</strong>：Java实现的LDAP服务</li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>企业内部用户认证（VPN、邮箱、OA系统）</li><li>组织架构管理</li><li>权限控制和用户属性查询</li></ul><h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><ol><li><strong>安全性差：</strong> LDAP 主要是为受信任的内网设计的。虽然有 LDAPS (SSL)，但在公网暴露 LDAP 端口是非常危险的行为。</li><li><strong>Web 不友好：</strong> LDAP 是基于 TCP 的长连接二进制协议，不是 HTTP。浏览器里的 JavaScript 根本没法直接发 LDAP 请求。</li><li><strong>没有 Token 概念：</strong> LDAP 验证完就是验证完了，它不会给你发一个“令牌”让你去访问其他 API。而 OAuth&#x2F;OIDC 的核心就是那个 Token，可以在微服务之间传递。</li><li><strong>标准化不足：</strong> 虽然 LDAP 是标准，但不同厂商（AD vs OpenLDAP）的 Schema（字段定义）差异很大。OIDC&#x2F;SAML 在这方面屏蔽了底层差异。</li></ol><h4 id="LDAP-vs-SAML-OIDC-OAuth"><a href="#LDAP-vs-SAML-OIDC-OAuth" class="headerlink" title="LDAP vs. SAML &#x2F; OIDC &#x2F; OAuth"></a>LDAP vs. SAML &#x2F; OIDC &#x2F; OAuth</h4><ul><li><p><strong>本质区别：</strong></p><ul><li><strong>LDAP</strong> 是针对<strong>内网</strong>设计的、基于 TCP 的查询协议。它很古老，不适合在互联网上裸奔（容易被抓包，且防火墙不友好）。</li><li><strong>SAML&#x2F;OIDC</strong> 是基于 <strong>HTTP&#x2F;浏览器</strong> 的。它们是为了解决 LDAP 无法跨域、无法上云的问题而诞生的。</li></ul></li><li><p><strong>配合方式：</strong></p><ul><li>用户在浏览器用 OIDC 登录 -&gt; 请求发给 IdP（如 Keycloak） -&gt; Keycloak 通过 LDAP 协议去问后端的 AD：“密码对不对？” -&gt; AD 说“对” -&gt; Keycloak 签发 OIDC Token 给用户。</li></ul></li></ul><h4 id="LDAP-vs-Kerberos"><a href="#LDAP-vs-Kerberos" class="headerlink" title="LDAP vs. Kerberos"></a>LDAP vs. Kerberos</h4><p>这是一对<strong>焦不离孟的好基友</strong>，特别是在 Windows Active Directory (AD) 环境下。</p><ul><li><strong>关系：</strong><ul><li><strong>LDAP</strong> 负责<strong>查信息</strong>（这个人属于哪个组？他的邮箱是多少？）。</li><li><strong>Kerberos</strong> 负责<strong>验证密码</strong>（票据交换，证明你是你）。</li></ul></li><li><strong>区别：</strong><ul><li>LDAP 也可以验证密码（通过 <code>bind</code> 操作），但在 Windows 域环境中，登录过程主要是 Kerberos 在跑，登录成功后，系统会用 LDAP 去拉取你的个人策略、组信息等。</li><li>Kerberos 极其依赖内网环境和时间同步，<strong>出了局域网就基本废了</strong>，所以它也没法用于互联网 SSO。</li></ul></li></ul><h4 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h4><ul><li><strong>Windows域环境</strong>：AD域的默认认证机制</li><li><strong>Hadoop集群</strong>：大数据平台的安全认证</li><li><strong>企业网络</strong>：内网资源的安全访问</li></ul><h3 id="各协议对比"><a href="#各协议对比" class="headerlink" title="各协议对比"></a>各协议对比</h3><table><thead><tr><th><strong>协议</strong></th><th><strong>角色定位</strong></th><th><strong>典型“对话”内容</strong></th><th><strong>适用范围</strong></th><th><strong>是否存放数据?</strong></th></tr></thead><tbody><tr><td><strong>LDAP</strong></td><td><strong>大管家 (数据库)</strong></td><td>“帮我查下张三的部门” &#x2F; “密码对不对?”</td><td><strong>局域网深处</strong> (后端)</td><td><strong>是</strong> (核心数据源)</td></tr><tr><td><strong>Kerberos</strong></td><td><strong>内网保安</strong></td><td>“这是张三的票据(Ticket)，放行吗?”</td><td><strong>局域网</strong> (Windows域)</td><td>否 (依赖KDC)</td></tr><tr><td><strong>SAML</strong></td><td><strong>企业信使</strong></td><td>“我是IdP，我证明这个XML里的张三已登录”</td><td>互联网 &#x2F; 企业互信</td><td>否</td></tr><tr><td><strong>OIDC</strong></td><td><strong>现代护照</strong></td><td>“这是张三的ID Token(JWT)，你自己看”</td><td>互联网 &#x2F; App &#x2F; SPA</td><td>否</td></tr><tr><td><strong>OAuth</strong></td><td><strong>授权钥匙</strong></td><td>“我有令牌，让我进屋拿照片”</td><td>API 授权</td><td>否</td></tr></tbody></table><pre class="mermaid">graph TD    subgraph "前端应用层 (App / Web)"    A[现代 Web 应用]     B[第三方 SaaS 比如 Salesforce]    end    subgraph "中间件层 (IdP / 认证中心)"    C[SSO 平台 比如 Keycloak, Okta, ADFS]    end    subgraph "后端存储层 (Source of Truth)"    D[LDAP 目录服务 比如 AD, OpenLDAP]    E[SQL 数据库]    end    A -- "OIDC / OAuth" --> C    B -- "SAML" --> C    C -- "LDAP 协议" --> D</pre><hr><h2 id="二、Token技术体系"><a href="#二、Token技术体系" class="headerlink" title="二、Token技术体系"></a>二、Token技术体系</h2><h3 id="1-Access-Token-资源访问凭证"><a href="#1-Access-Token-资源访问凭证" class="headerlink" title="1. Access Token - 资源访问凭证"></a>1. Access Token - 资源访问凭证</h3><p><strong>Access Token</strong> 是客户端访问资源服务器的核心凭证，是OAuth 2.0体系的关键组件。</p><h4 id="Token格式对比"><a href="#Token格式对比" class="headerlink" title="Token格式对比"></a>Token格式对比</h4><table><thead><tr><th>类型</th><th>特点</th><th>验证方式</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>不透明Token</strong></td><td>随机字符串，无法解析</td><td>需调用授权服务器验证</td><td>高安全要求的企业环境</td></tr><tr><td><strong>JWT Token</strong></td><td>自包含，可本地解析</td><td>本地验证签名</td><td>微服务、分布式系统</td></tr></tbody></table><h4 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h4><ul><li><strong>短期有效</strong>：通常1小时内过期</li><li><strong>续期机制</strong>：配合Refresh Token实现自动续期</li><li><strong>撤销能力</strong>：支持主动撤销和黑名单机制</li></ul><h3 id="2-Refresh-Token-令牌续期机制"><a href="#2-Refresh-Token-令牌续期机制" class="headerlink" title="2. Refresh Token - 令牌续期机制"></a>2. Refresh Token - 令牌续期机制</h3><p><strong>Refresh Token</strong> 专门用于在Access Token过期后获取新的Access Token，实现长期会话管理。</p><h4 id="核心特性-1"><a href="#核心特性-1" class="headerlink" title="核心特性"></a>核心特性</h4><ul><li><strong>长期有效性</strong>：7-30天有效期，但可被撤销</li><li><strong>存储限制</strong>：仅在客户端和授权服务器间流转</li><li><strong>单次使用</strong>：使用后立即失效，返回新的Refresh Token（Rotation机制）</li></ul><h4 id="安全要求"><a href="#安全要求" class="headerlink" title="安全要求"></a>安全要求</h4><ul><li><strong>HTTPS传输</strong>：防止网络传输中被截获</li><li><strong>安全存储</strong>：客户端需安全存储（如Keychain、Keystore）</li><li><strong>撤销机制</strong>：支持用户主动撤销或异常检测自动撤销</li></ul><h3 id="3-ID-Token-身份信息载体"><a href="#3-ID-Token-身份信息载体" class="headerlink" title="3. ID Token - 身份信息载体"></a>3. ID Token - 身份信息载体</h3><p><strong>ID Token</strong> 是OpenID Connect的核心组件，以JWT格式承载用户身份信息。</p><h4 id="标准声明（Claims）"><a href="#标准声明（Claims）" class="headerlink" title="标准声明（Claims）"></a>标准声明（Claims）</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;iss&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://accounts.google.com&quot;</span><span class="punctuation">,</span>        <span class="comment">// 发行者</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span>                         <span class="comment">// 用户唯一标识</span></span><br><span class="line">  <span class="attr">&quot;aud&quot;</span><span class="punctuation">:</span> <span class="string">&quot;your-client-id&quot;</span><span class="punctuation">,</span>                     <span class="comment">// 目标客户端</span></span><br><span class="line">  <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1620000000</span><span class="punctuation">,</span>                           <span class="comment">// 过期时间</span></span><br><span class="line">  <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1619996400</span><span class="punctuation">,</span>                           <span class="comment">// 签发时间</span></span><br><span class="line">  <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user@example.com&quot;</span><span class="punctuation">,</span>                 <span class="comment">// 邮箱</span></span><br><span class="line">  <span class="attr">&quot;email_verified&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                      <span class="comment">// 邮箱验证状态</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span>                          <span class="comment">// 姓名</span></span><br><span class="line">  <span class="attr">&quot;picture&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://example.com/avatar.jpg&quot;</span>  <span class="comment">// 头像</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="安全特性"><a href="#安全特性" class="headerlink" title="安全特性"></a>安全特性</h4><ul><li><strong>数字签名</strong>：RS256&#x2F;ES256算法签名，防篡改</li><li><strong>时效性</strong>：短期有效（通常15-60分钟）</li><li><strong>完整性</strong>：包含完整的用户身份信息</li></ul><h3 id="4-JWT-自包含令牌标准"><a href="#4-JWT-自包含令牌标准" class="headerlink" title="4. JWT - 自包含令牌标准"></a>4. JWT - 自包含令牌标准</h3><p><strong>JWT（JSON Web Token）</strong> 是一种开放标准（RFC 7519），用于在各方之间安全地传输信息。</p><h4 id="三段式结构"><a href="#三段式结构" class="headerlink" title="三段式结构"></a>三段式结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Header.Payload.Signature</span><br></pre></td></tr></table></figure><h4 id="详细结构解析"><a href="#详细结构解析" class="headerlink" title="详细结构解析"></a>详细结构解析</h4><p><strong>Header（头部）</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;RS256&quot;</span><span class="punctuation">,</span>    <span class="comment">// 签名算法</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span><span class="punctuation">,</span>      <span class="comment">// 令牌类型</span></span><br><span class="line">  <span class="attr">&quot;kid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;key-id&quot;</span>    <span class="comment">// 密钥标识</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>Payload（负载）</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user123&quot;</span><span class="punctuation">,</span>           <span class="comment">// 主题（用户ID）</span></span><br><span class="line">  <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1646092800</span><span class="punctuation">,</span>          <span class="comment">// 签发时间</span></span><br><span class="line">  <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1646096400</span><span class="punctuation">,</span>          <span class="comment">// 过期时间</span></span><br><span class="line">  <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;read write&quot;</span><span class="punctuation">,</span>      <span class="comment">// 权限范围</span></span><br><span class="line">  <span class="attr">&quot;aud&quot;</span><span class="punctuation">:</span> <span class="string">&quot;api.example.com&quot;</span>    <span class="comment">// 受众</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>Signature（签名）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RSASHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  private_key</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="算法选择指南"><a href="#算法选择指南" class="headerlink" title="算法选择指南"></a>算法选择指南</h4><table><thead><tr><th>算法</th><th>类型</th><th>安全性</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>HS256</strong></td><td>对称加密</td><td>中等</td><td>内部微服务</td></tr><tr><td><strong>RS256</strong></td><td>非对称加密</td><td>高</td><td>跨域认证</td></tr><tr><td><strong>ES256</strong></td><td>椭圆曲线</td><td>高</td><td>移动端应用</td></tr></tbody></table><h4 id="安全注意事项"><a href="#安全注意事项" class="headerlink" title="安全注意事项"></a>安全注意事项</h4><ul><li><strong>密钥管理</strong>：定期轮换签名密钥</li><li><strong>算法验证</strong>：明确指定允许的签名算法</li><li><strong>时效控制</strong>：设置合理的过期时间</li><li><strong>敏感信息</strong>：避免在Payload中包含敏感数据</li></ul><h3 id="5-Session-Token-会话状态管理"><a href="#5-Session-Token-会话状态管理" class="headerlink" title="5. Session Token - 会话状态管理"></a>5. Session Token - 会话状态管理</h3><p><strong>Session Token</strong> 是传统的会话管理机制，通过服务端状态存储维护用户会话。</p><h4 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Client (SessionID) ←→ Server (Session Store)</span><br><span class="line">                           ↓</span><br><span class="line">                    Redis/Database/Memory</span><br></pre></td></tr></table></figure><h4 id="存储策略"><a href="#存储策略" class="headerlink" title="存储策略"></a>存储策略</h4><p><strong>服务端存储</strong></p><ul><li><strong>内存存储</strong>：性能最优，但不支持集群</li><li><strong>Redis集群</strong>：高性能分布式存储</li><li><strong>数据库存储</strong>：持久化但性能较低</li></ul><p><strong>客户端传输</strong></p><ul><li><strong>HTTP Cookie</strong>：自动传输，支持HttpOnly和Secure标志</li><li><strong>LocalStorage</strong>：手动管理，存在XSS风险</li></ul><h4 id="Session-vs-JWT-对比"><a href="#Session-vs-JWT-对比" class="headerlink" title="Session vs JWT 对比"></a>Session vs JWT 对比</h4><table><thead><tr><th>特性</th><th>Session Token</th><th>JWT</th></tr></thead><tbody><tr><td><strong>状态管理</strong></td><td>有状态（服务端存储）</td><td>无状态（自包含）</td></tr><tr><td><strong>扩展性</strong></td><td>需要共享存储</td><td>天然支持分布式</td></tr><tr><td><strong>性能</strong></td><td>需要查库验证</td><td>本地验证</td></tr><tr><td><strong>撤销能力</strong></td><td>立即撤销</td><td>需要黑名单机制</td></tr><tr><td><strong>存储开销</strong></td><td>服务端存储成本</td><td>网络传输成本</td></tr></tbody></table><h3 id="6-SAML-断言-XML安全声明"><a href="#6-SAML-断言-XML安全声明" class="headerlink" title="6. SAML 断言 - XML安全声明"></a>6. SAML 断言 - XML安全声明</h3><p><strong>SAML断言</strong> 是SAML 2.0协议的核心载体，以XML格式承载安全声明信息。</p><h4 id="断言类型"><a href="#断言类型" class="headerlink" title="断言类型"></a>断言类型</h4><p><strong>认证断言（Authentication Assertion）</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">saml:Assertion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">saml:AuthnStatement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">saml:AuthnContext</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">saml:AuthnContextClassRef</span>&gt;</span></span><br><span class="line">        urn:oasis:names:tc:SAML:2.0:ac:classes:Password</span><br><span class="line">      <span class="tag">&lt;/<span class="name">saml:AuthnContextClassRef</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">saml:AuthnContext</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">saml:AuthnStatement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">saml:Assertion</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>属性断言（Attribute Assertion）</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">saml:AttributeStatement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">saml:Attribute</span> <span class="attr">Name</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">saml:AttributeValue</span>&gt;</span>user@company.com<span class="tag">&lt;/<span class="name">saml:AttributeValue</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">saml:Attribute</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">saml:Attribute</span> <span class="attr">Name</span>=<span class="string">&quot;department&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">saml:AttributeValue</span>&gt;</span>Engineering<span class="tag">&lt;/<span class="name">saml:AttributeValue</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">saml:Attribute</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">saml:AttributeStatement</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>授权决策断言（Authorization Decision Assertion）</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">saml:AuthzDecisionStatement</span> <span class="attr">Resource</span>=<span class="string">&quot;https://app.company.com&quot;</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">Decision</span>=<span class="string">&quot;Permit&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">saml:Action</span>&gt;</span>Read<span class="tag">&lt;/<span class="name">saml:Action</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">saml:Action</span>&gt;</span>Write<span class="tag">&lt;/<span class="name">saml:Action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">saml:AuthzDecisionStatement</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="三、协议与Token协同架构"><a href="#三、协议与Token协同架构" class="headerlink" title="三、协议与Token协同架构"></a>三、协议与Token协同架构</h2><h3 id="1-OAuth-2-0-OpenID-Connect-组合"><a href="#1-OAuth-2-0-OpenID-Connect-组合" class="headerlink" title="1. OAuth 2.0 + OpenID Connect 组合"></a>1. OAuth 2.0 + OpenID Connect 组合</h3><p>这是现代应用最常用的认证授权组合，同时解决身份认证和资源授权问题。</p><h4 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h4><pre class="mermaid">sequenceDiagram    participant User as 用户    participant Client as 客户端应用    participant AuthServer as 认证服务器    participant Resource as 资源服务器    User->>Client: 访问应用    Client->>AuthServer: 重定向到认证页面    User->>AuthServer: 登录并授权    AuthServer->>Client: 返回授权码    Client->>AuthServer: 交换Token    AuthServer->>Client: 返回Access Token + ID Token    Client->>Resource: 使用Access Token访问资源    Client->>AuthServer: 使用Access Token获取UserInfo</pre><h4 id="技术优势"><a href="#技术优势" class="headerlink" title="技术优势"></a>技术优势</h4><ul><li><strong>职责分离</strong>：OAuth负责授权，OIDC负责认证</li><li><strong>标准化</strong>：广泛的行业支持和互操作性</li><li><strong>安全性</strong>：多层安全机制和最佳实践</li><li><strong>灵活性</strong>：支持多种客户端类型和场景</li></ul><h3 id="2-SAML-LDAP-企业集成"><a href="#2-SAML-LDAP-企业集成" class="headerlink" title="2. SAML + LDAP 企业集成"></a>2. SAML + LDAP 企业集成</h3><p>传统企业环境中，SAML和LDAP的组合提供了完整的企业身份管理解决方案。</p><h4 id="集成架构"><a href="#集成架构" class="headerlink" title="集成架构"></a>集成架构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Enterprise AD/LDAP ←→ SAML IdP ←→ SaaS Applications</span><br><span class="line">       ↓                ↓              ↓</span><br><span class="line">   用户目录        身份联邦        业务应用</span><br></pre></td></tr></table></figure><h4 id="集成流程"><a href="#集成流程" class="headerlink" title="集成流程"></a>集成流程</h4><ol><li><strong>用户认证</strong>：用户通过企业AD&#x2F;LDAP进行身份验证</li><li><strong>断言生成</strong>：IdP生成包含用户属性的SAML断言</li><li><strong>应用授权</strong>：SaaS应用验证SAML断言并授权访问</li><li><strong>属性同步</strong>：通过LDAP查询获取最新的用户属性</li></ol><h4 id="企业价值"><a href="#企业价值" class="headerlink" title="企业价值"></a>企业价值</h4><ul><li><strong>统一身份</strong>：一套用户目录管理所有应用</li><li><strong>合规要求</strong>：满足企业安全和合规标准</li><li><strong>成本效益</strong>：减少重复的身份管理工作</li></ul><hr><h2 id="四、安全最佳实践"><a href="#四、安全最佳实践" class="headerlink" title="四、安全最佳实践"></a>四、安全最佳实践</h2><h3 id="1-传输层安全"><a href="#1-传输层安全" class="headerlink" title="1. 传输层安全"></a>1. 传输层安全</h3><h4 id="HTTPS-强制要求"><a href="#HTTPS-强制要求" class="headerlink" title="HTTPS 强制要求"></a>HTTPS 强制要求</h4><ul><li><strong>所有Token传输</strong>必须使用HTTPS加密</li><li><strong>证书验证</strong>：确保SSL证书有效性和域名匹配</li><li><strong>HSTS策略</strong>：启用HTTP严格传输安全</li></ul><h4 id="Token传输方式"><a href="#Token传输方式" class="headerlink" title="Token传输方式"></a>Token传输方式</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ✅ 推荐：Authorization Header</span><br><span class="line"><span class="attribute">Authorization</span><span class="punctuation">: </span>Bearer eyJhbGciOiJSUzI1NiIs...</span><br><span class="line"></span><br><span class="line"># ❌ 避免：URL参数传递</span><br><span class="line">GET /api/user?access_token=eyJhbGciOiJSUzI1NiIs...</span><br></pre></td></tr></table></figure><h3 id="2-存储安全策略"><a href="#2-存储安全策略" class="headerlink" title="2. 存储安全策略"></a>2. 存储安全策略</h3><h4 id="浏览器端安全存储"><a href="#浏览器端安全存储" class="headerlink" title="浏览器端安全存储"></a>浏览器端安全存储</h4><table><thead><tr><th>存储方式</th><th>安全性</th><th>XSS风险</th><th>CSRF风险</th><th>推荐场景</th></tr></thead><tbody><tr><td><strong>HttpOnly Cookie</strong></td><td>高</td><td>免疫</td><td>需防护</td><td>传统Web应用</td></tr><tr><td><strong>Secure Cookie</strong></td><td>高</td><td>免疫</td><td>需防护</td><td>HTTPS环境</td></tr><tr><td><strong>LocalStorage</strong></td><td>低</td><td>高风险</td><td>免疫</td><td>不推荐存储敏感Token</td></tr><tr><td><strong>Memory</strong></td><td>最高</td><td>免疫</td><td>免疫</td><td>SPA短期存储</td></tr></tbody></table><h4 id="移动端安全存储"><a href="#移动端安全存储" class="headerlink" title="移动端安全存储"></a>移动端安全存储</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iOS - Keychain Services</span></span><br><span class="line"><span class="keyword">const</span> keychain = <span class="built_in">require</span>(<span class="string">&#x27;react-native-keychain&#x27;</span>);</span><br><span class="line">keychain.<span class="title function_">setInternetCredentials</span>(<span class="string">&#x27;server&#x27;</span>, <span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;token&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Android - Keystore</span></span><br><span class="line"><span class="keyword">import</span> &#123; encrypt, decrypt &#125; <span class="keyword">from</span> <span class="string">&#x27;react-native-keystore&#x27;</span>;</span><br><span class="line"><span class="title function_">encrypt</span>(<span class="string">&#x27;tokenKey&#x27;</span>, accessToken);</span><br></pre></td></tr></table></figure><h3 id="3-密钥管理体系"><a href="#3-密钥管理体系" class="headerlink" title="3. 密钥管理体系"></a>3. 密钥管理体系</h3><h4 id="密钥轮换策略"><a href="#密钥轮换策略" class="headerlink" title="密钥轮换策略"></a>密钥轮换策略</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">JWT签名密钥轮换:</span></span><br><span class="line">  <span class="string">频率:</span> <span class="string">每3-6个月</span></span><br><span class="line">  <span class="string">过程:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">生成新密钥</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">同时支持新旧密钥验证</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">逐步淘汰旧密钥</span></span><br><span class="line">  </span><br><span class="line"><span class="string">密钥存储:</span></span><br><span class="line">  <span class="string">开发环境:</span> <span class="string">环境变量</span></span><br><span class="line">  <span class="string">生产环境:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">AWS</span> <span class="string">KMS</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Azure</span> <span class="string">Key</span> <span class="string">Vault</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">HashiCorp</span> <span class="string">Vault</span></span><br></pre></td></tr></table></figure><h4 id="密钥管理最佳实践"><a href="#密钥管理最佳实践" class="headerlink" title="密钥管理最佳实践"></a>密钥管理最佳实践</h4><ul><li><strong>分离存储</strong>：密钥与应用代码分离</li><li><strong>访问控制</strong>：最小权限原则</li><li><strong>审计日志</strong>：记录所有密钥操作</li><li><strong>备份恢复</strong>：建立密钥备份和恢复机制</li></ul><h3 id="4-攻击防护机制"><a href="#4-攻击防护机制" class="headerlink" title="4. 攻击防护机制"></a>4. 攻击防护机制</h3><h4 id="重放攻击防护"><a href="#重放攻击防护" class="headerlink" title="重放攻击防护"></a>重放攻击防护</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;jti&quot;</span><span class="punctuation">:</span> <span class="string">&quot;unique-token-id&quot;</span><span class="punctuation">,</span>     <span class="comment">// JWT ID，防止重复使用</span></span><br><span class="line">  <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1646092800</span><span class="punctuation">,</span>            <span class="comment">// 签发时间</span></span><br><span class="line">  <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1646096400</span><span class="punctuation">,</span>            <span class="comment">// 过期时间</span></span><br><span class="line">  <span class="attr">&quot;nonce&quot;</span><span class="punctuation">:</span> <span class="string">&quot;random-value&quot;</span>       <span class="comment">// 随机数，OIDC中使用</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="常见攻击与防护"><a href="#常见攻击与防护" class="headerlink" title="常见攻击与防护"></a>常见攻击与防护</h4><table><thead><tr><th>攻击类型</th><th>防护措施</th><th>实现方式</th></tr></thead><tbody><tr><td><strong>Token劫持</strong></td><td>HTTPS + Secure Cookie</td><td>传输加密</td></tr><tr><td><strong>XSS攻击</strong></td><td>HttpOnly Cookie + CSP</td><td>存储隔离</td></tr><tr><td><strong>CSRF攻击</strong></td><td>SameSite Cookie + CSRF Token</td><td>跨站防护</td></tr><tr><td><strong>重放攻击</strong></td><td>时间戳 + Nonce + JTI</td><td>唯一性验证</td></tr></tbody></table><hr><h2 id="五、技术选型指南"><a href="#五、技术选型指南" class="headerlink" title="五、技术选型指南"></a>五、技术选型指南</h2><h3 id="场景化选型矩阵"><a href="#场景化选型矩阵" class="headerlink" title="场景化选型矩阵"></a>场景化选型矩阵</h3><table><thead><tr><th>应用场景</th><th>推荐协议</th><th>Token类型</th><th>优势</th><th>考虑因素</th></tr></thead><tbody><tr><td><strong>消费级应用</strong></td><td>OAuth 2.0 + OIDC</td><td>Access Token + ID Token</td><td>标准化、易集成</td><td>用户体验</td></tr><tr><td><strong>企业SSO</strong></td><td>SAML 2.0</td><td>SAML断言</td><td>成熟稳定、合规</td><td>复杂度较高</td></tr><tr><td><strong>移动应用</strong></td><td>OIDC + JWT</td><td>JWT + Refresh Token</td><td>离线可用、性能好</td><td>存储安全</td></tr><tr><td><strong>微服务架构</strong></td><td>JWT</td><td>自包含JWT</td><td>无状态、可扩展</td><td>密钥管理</td></tr><tr><td><strong>API网关</strong></td><td>OAuth 2.0</td><td>Bearer Token</td><td>细粒度控制</td><td>性能要求</td></tr></tbody></table><h3 id="现代化选型建议"><a href="#现代化选型建议" class="headerlink" title="现代化选型建议"></a>现代化选型建议</h3><h4 id="新项目推荐"><a href="#新项目推荐" class="headerlink" title="新项目推荐"></a>新项目推荐</h4><ol><li><strong>OAuth 2.1 + OIDC</strong>：现代应用的首选</li><li><strong>PKCE扩展</strong>：公共客户端必须启用</li><li><strong>JWT格式</strong>：Access Token使用JWT格式</li><li><strong>短期Token</strong>：Access Token 15-60分钟过期</li></ol><h4 id="企业级要求"><a href="#企业级要求" class="headerlink" title="企业级要求"></a>企业级要求</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">安全要求:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">SAML</span> <span class="number">2.0</span><span class="string">用于企业SSO</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">mTLS用于服务间通信</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">HSM用于密钥存储</span></span><br><span class="line"></span><br><span class="line"><span class="string">合规要求:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">GDPR:</span> <span class="string">数据保护和用户同意</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">SOX:</span> <span class="string">访问控制和审计</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">HIPAA:</span> <span class="string">医疗数据保护</span></span><br></pre></td></tr></table></figure><h3 id="实施路线图"><a href="#实施路线图" class="headerlink" title="实施路线图"></a>实施路线图</h3><h4 id="第一阶段：基础实施"><a href="#第一阶段：基础实施" class="headerlink" title="第一阶段：基础实施"></a>第一阶段：基础实施</h4><ul><li><input disabled="" type="checkbox"> 选择认证协议（OAuth 2.0 + OIDC）</li><li><input disabled="" type="checkbox"> 部署身份提供商（如Auth0、Okta）</li><li><input disabled="" type="checkbox"> 实现基础的登录登出功能</li><li><input disabled="" type="checkbox"> 配置HTTPS和基础安全策略</li></ul><h4 id="第二阶段：安全加固"><a href="#第二阶段：安全加固" class="headerlink" title="第二阶段：安全加固"></a>第二阶段：安全加固</h4><ul><li><input disabled="" type="checkbox"> 启用多因素认证（MFA）</li><li><input disabled="" type="checkbox"> 实施Token轮换和撤销</li><li><input disabled="" type="checkbox"> 配置安全存储和传输</li><li><input disabled="" type="checkbox"> 建立监控和审计机制</li></ul><h4 id="第三阶段：高级特性"><a href="#第三阶段：高级特性" class="headerlink" title="第三阶段：高级特性"></a>第三阶段：高级特性</h4><ul><li><input disabled="" type="checkbox"> 细粒度权限控制（RBAC&#x2F;ABAC）</li><li><input disabled="" type="checkbox"> 跨域SSO集成</li><li><input disabled="" type="checkbox"> 零信任架构实施</li><li><input disabled="" type="checkbox"> 持续安全评估</li></ul><h2 id="六、技术发展趋势"><a href="#六、技术发展趋势" class="headerlink" title="六、技术发展趋势"></a>六、技术发展趋势</h2><h3 id="新兴技术标准"><a href="#新兴技术标准" class="headerlink" title="新兴技术标准"></a>新兴技术标准</h3><h4 id="OAuth-2-1"><a href="#OAuth-2-1" class="headerlink" title="OAuth 2.1"></a>OAuth 2.1</h4><p>OAuth 2.1整合了OAuth 2.0的安全最佳实践，主要改进包括：</p><ul><li><strong>强制PKCE</strong>：所有公共客户端必须使用PKCE</li><li><strong>移除隐式流</strong>：不再支持隐式授权模式</li><li><strong>刷新令牌安全</strong>：强化Refresh Token的安全要求</li></ul><h4 id="WebAuthn-FIDO2"><a href="#WebAuthn-FIDO2" class="headerlink" title="WebAuthn (FIDO2)"></a>WebAuthn (FIDO2)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebAuthn注册示例</span></span><br><span class="line"><span class="keyword">const</span> credential = <span class="keyword">await</span> navigator.<span class="property">credentials</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">publicKey</span>: &#123;</span><br><span class="line">    <span class="attr">challenge</span>: <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="attr">rp</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;Example Corp&quot;</span> &#125;,</span><br><span class="line">    <span class="attr">user</span>: &#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="keyword">new</span> <span class="title class_">TextEncoder</span>().<span class="title function_">encode</span>(<span class="string">&quot;user123&quot;</span>),</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;user@example.com&quot;</span>,</span><br><span class="line">      <span class="attr">displayName</span>: <span class="string">&quot;John Doe&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">pubKeyCredParams</span>: [&#123;<span class="attr">alg</span>: -<span class="number">7</span>, <span class="attr">type</span>: <span class="string">&quot;public-key&quot;</span>&#125;],</span><br><span class="line">    <span class="attr">authenticatorSelection</span>: &#123;</span><br><span class="line">      <span class="attr">authenticatorAttachment</span>: <span class="string">&quot;platform&quot;</span>,</span><br><span class="line">      <span class="attr">userVerification</span>: <span class="string">&quot;required&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="零信任架构下的认证"><a href="#零信任架构下的认证" class="headerlink" title="零信任架构下的认证"></a>零信任架构下的认证</h3><h4 id="动态授权模型"><a href="#动态授权模型" class="headerlink" title="动态授权模型"></a>动态授权模型</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">零信任原则:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">永不信任，始终验证</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">最小权限访问</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">持续验证和监控</span></span><br><span class="line"></span><br><span class="line"><span class="string">实施策略:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">基于风险的自适应认证</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">上下文感知的访问控制</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">实时威胁检测和响应</span></span><br></pre></td></tr></table></figure><h3 id="标准参考文档"><a href="#标准参考文档" class="headerlink" title="标准参考文档"></a>标准参考文档</h3><h4 id="RFC标准"><a href="#RFC标准" class="headerlink" title="RFC标准"></a>RFC标准</h4><ul><li><strong>RFC 6749</strong>: OAuth 2.0 Authorization Framework</li><li><strong>RFC 7519</strong>: JSON Web Token (JWT)</li><li><strong>RFC 7636</strong>: Proof Key for Code Exchange (PKCE)</li><li><strong>RFC 8414</strong>: OAuth 2.0 Authorization Server Metadata</li></ul><h4 id="安全框架"><a href="#安全框架" class="headerlink" title="安全框架"></a>安全框架</h4><ul><li><strong>OWASP API Security Top 10</strong>: API安全最佳实践</li><li><strong>NIST Cybersecurity Framework</strong>: 网络安全框架</li><li><strong>ISO 27001</strong>: 信息安全管理体系标准</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>认证和授权技术体系正在快速发展，从传统的Session管理到现代的JWT和OAuth体系，再到新兴的零信任架构，技术选择需要综合考虑安全性、可用性、可扩展性等多个维度。</p><p><strong>关键要点：</strong></p><ol><li><strong>OAuth 2.0 + OIDC</strong> 是现代应用的主流选择</li><li><strong>JWT</strong> 在微服务架构中具有显著优势</li><li><strong>SAML</strong> 在企业环境中仍然重要</li><li><strong>安全性</strong> 始终是第一考虑因素</li><li><strong>标准化</strong> 有助于系统集成和维护</li></ol><p>选择合适的认证授权方案，需要基于具体的业务场景、技术架构和安全要求进行综合评估。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OAuth </tag>
            
            <tag> JWT </tag>
            
            <tag> SAML </tag>
            
            <tag> OIDC </tag>
            
            <tag> 认证 </tag>
            
            <tag> 授权 </tag>
            
            <tag> Token </tag>
            
            <tag> Kerberos </tag>
            
            <tag> LDAP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字证书与 PKI 技术详解</title>
      <link href="/posts/6104.html"/>
      <url>/posts/6104.html</url>
      
        <content type="html"><![CDATA[<h1 id="数字证书与-PKI-技术详解"><a href="#数字证书与-PKI-技术详解" class="headerlink" title="数字证书与 PKI 技术详解"></a>数字证书与 PKI 技术详解</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>数字证书是现代网络安全的基石，PKI (Public Key Infrastructure) 公钥基础设施则是管理这些证书的完整框架。本文将深入探讨 PKI 的核心概念、组件架构、证书格式标准以及自动化管理协议。</p><h2 id="PKI-Public-Key-Infrastructure-公钥基础设施"><a href="#PKI-Public-Key-Infrastructure-公钥基础设施" class="headerlink" title="PKI (Public Key Infrastructure) 公钥基础设施"></a>PKI (Public Key Infrastructure) 公钥基础设施</h2><h3 id="定义与核心价值"><a href="#定义与核心价值" class="headerlink" title="定义与核心价值"></a>定义与核心价值</h3><p><strong>PKI</strong> 是一个综合性的安全框架，专门用于管理数字证书和公钥加密的完整生命周期。它通过建立可信的数字身份体系，为现代网络通信提供身份验证、数据完整性和机密性保障。</p><h3 id="核心组件架构"><a href="#核心组件架构" class="headerlink" title="核心组件架构"></a>核心组件架构</h3><h4 id="1-CA-Certificate-Authority-证书颁发机构"><a href="#1-CA-Certificate-Authority-证书颁发机构" class="headerlink" title="1. CA (Certificate Authority) - 证书颁发机构"></a>1. CA (Certificate Authority) - 证书颁发机构</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">核心职能:</span> <span class="string">PKI</span> <span class="string">的信任根节点，负责数字证书的全生命周期管理</span></span><br><span class="line"><span class="string">主要职责:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">严格验证申请者身份和资质</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">颁发符合标准的数字证书</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">实时维护证书状态信息</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">及时发布证书撤销列表</span> <span class="string">(CRL)</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">管理证书有效期和续期流程</span></span><br></pre></td></tr></table></figure><h4 id="2-RA-Registration-Authority-注册机构"><a href="#2-RA-Registration-Authority-注册机构" class="headerlink" title="2. RA (Registration Authority) - 注册机构"></a>2. RA (Registration Authority) - 注册机构</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">定位:</span> <span class="string">CA</span> <span class="string">的授权代理，专注于证书申请前端处理</span></span><br><span class="line"><span class="string">核心功能:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">执行严格的身份验证流程</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">标准化证书申请处理程序</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">向</span> <span class="string">CA</span> <span class="string">转发已验证的合规申请</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">提供用户支持和咨询服务</span></span><br></pre></td></tr></table></figure><h4 id="3-证书存储与分发系统"><a href="#3-证书存储与分发系统" class="headerlink" title="3. 证书存储与分发系统"></a>3. 证书存储与分发系统</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">功能:</span> <span class="string">安全存储和高效分发已颁发证书</span></span><br><span class="line"><span class="string">实现方式:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">LDAP</span> <span class="string">目录服务</span> <span class="string">(企业环境首选)</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">关系型数据库</span> <span class="string">(高性能场景)</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Web</span> <span class="string">服务器</span> <span class="string">(公网访问)</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">分布式存储系统</span> <span class="string">(大规模部署)</span></span><br></pre></td></tr></table></figure><h4 id="4-证书状态验证系统"><a href="#4-证书状态验证系统" class="headerlink" title="4. 证书状态验证系统"></a>4. 证书状态验证系统</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">组件构成:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">CRL</span> <span class="string">(Certificate</span> <span class="string">Revocation</span> <span class="string">List)</span> <span class="bullet">-</span> <span class="string">传统撤销列表</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">OCSP</span> <span class="string">(Online</span> <span class="string">Certificate</span> <span class="string">Status</span> <span class="string">Protocol)</span> <span class="bullet">-</span> <span class="string">实时状态查询</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">证书透明度日志</span> <span class="string">(Certificate</span> <span class="string">Transparency)</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">自动化状态监控服务</span></span><br></pre></td></tr></table></figure><h3 id="PKI-架构关系"><a href="#PKI-架构关系" class="headerlink" title="PKI 架构关系"></a>PKI 架构关系</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PKI (公钥基础设施生态系统)</span><br><span class="line">├── CA (证书颁发机构) ← 信任锚点</span><br><span class="line">├── RA (注册机构) ← 身份验证网关</span><br><span class="line">├── 证书存储与分发系统 ← 数据管理层</span><br><span class="line">├── 证书状态验证系统 ← 安全监控层</span><br><span class="line">├── 密钥管理与托管系统 ← 密码学核心</span><br><span class="line">├── 策略引擎与合规框架 ← 治理层</span><br><span class="line">└── 用户接口与API服务 ← 应用接口层</span><br></pre></td></tr></table></figure><p><strong>组件协同关系</strong>:</p><ul><li><strong>CA</strong> 作为信任的根基，建立整个信任链条</li><li><strong>PKI</strong> 提供完整的治理框架和运营体系</li><li><strong>各组件协同工作</strong>，确保端到端的安全保障</li></ul><h3 id="信任模型架构"><a href="#信任模型架构" class="headerlink" title="信任模型架构"></a>信任模型架构</h3><h4 id="层次化信任模型-主流架构"><a href="#层次化信任模型-主流架构" class="headerlink" title="层次化信任模型 (主流架构)"></a>层次化信任模型 (主流架构)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Root CA (根证书颁发机构)</span><br><span class="line">├── Policy CA (策略证书颁发机构)</span><br><span class="line">│   ├── Issuing CA 1 (颁发证书颁发机构)</span><br><span class="line">│   │   ├── SSL/TLS Server Certificate</span><br><span class="line">│   │   └── Code Signing Certificate</span><br><span class="line">│   └── Issuing CA 2</span><br><span class="line">│       ├── Email Certificate</span><br><span class="line">│       └── User Authentication Certificate</span><br><span class="line">└── Cross-Certified CA (交叉认证证书颁发机构)</span><br><span class="line">    ├── Partner Organization Certificate</span><br><span class="line">    └── Federal Bridge Certificate</span><br></pre></td></tr></table></figure><h4 id="信任链验证流程"><a href="#信任链验证流程" class="headerlink" title="信任链验证流程"></a>信任链验证流程</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">验证步骤:</span></span><br><span class="line"><span class="number">1</span><span class="string">.</span> <span class="string">获取目标实体证书</span></span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="string">提取颁发者CA信息</span></span><br><span class="line"><span class="number">3</span><span class="string">.</span> <span class="string">递归验证上级CA证书</span></span><br><span class="line"><span class="number">4</span><span class="string">.</span> <span class="string">追溯至受信任根CA</span></span><br><span class="line"><span class="number">5</span><span class="string">.</span> <span class="string">验证整条链的数字签名</span></span><br><span class="line"><span class="number">6</span><span class="string">.</span> <span class="string">检查证书有效期和撤销状态</span></span><br><span class="line"><span class="number">7</span><span class="string">.</span> <span class="string">应用证书策略约束</span></span><br></pre></td></tr></table></figure><h3 id="证书生命周期管理"><a href="#证书生命周期管理" class="headerlink" title="证书生命周期管理"></a>证书生命周期管理</h3><h4 id="完整生命周期流程"><a href="#完整生命周期流程" class="headerlink" title="完整生命周期流程"></a>完整生命周期流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">密钥对生成 → 证书申请提交 → 身份验证审核 → </span><br><span class="line">证书颁发签名 → 证书分发部署 → 日常使用监控 → </span><br><span class="line">定期更新续期 → 必要时撤销销毁</span><br></pre></td></tr></table></figure><h4 id="各阶段详细说明"><a href="#各阶段详细说明" class="headerlink" title="各阶段详细说明"></a>各阶段详细说明</h4><ul><li><strong>密钥生成</strong>: 采用安全随机数生成器，确保密钥强度</li><li><strong>身份验证</strong>: 多因素验证，包括文档审核和域名控制验证</li><li><strong>证书颁发</strong>: 遵循 X.509 标准，嵌入必要的扩展字段</li><li><strong>使用监控</strong>: 实时监控证书使用情况和安全事件</li><li><strong>更新续期</strong>: 自动化或半自动化的证书更新流程</li><li><strong>撤销管理</strong>: 基于 CRL 和 OCSP 的实时撤销检查</li></ul><h3 id="主流-PKI-实现方案"><a href="#主流-PKI-实现方案" class="headerlink" title="主流 PKI 实现方案"></a>主流 PKI 实现方案</h3><h4 id="Microsoft-Active-Directory-Certificate-Services-AD-CS"><a href="#Microsoft-Active-Directory-Certificate-Services-AD-CS" class="headerlink" title="Microsoft Active Directory Certificate Services (AD CS)"></a>Microsoft Active Directory Certificate Services (AD CS)</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">特点:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Windows</span> <span class="string">Server</span> <span class="string">原生</span> <span class="string">PKI</span> <span class="string">解决方案</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">与</span> <span class="string">Active</span> <span class="string">Directory</span> <span class="string">深度集成</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">支持企业级证书模板和自动注册</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">内置</span> <span class="string">Web</span> <span class="string">注册界面和</span> <span class="string">SCEP</span> <span class="string">支持</span></span><br><span class="line"><span class="string">应用场景:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">企业内部</span> <span class="string">PKI</span> <span class="string">部署</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Windows</span> <span class="string">域环境证书管理</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">智能卡和</span> <span class="string">EFS</span> <span class="string">文件加密</span></span><br></pre></td></tr></table></figure><h4 id="Let’s-Encrypt-开源免费-CA"><a href="#Let’s-Encrypt-开源免费-CA" class="headerlink" title="Let’s Encrypt (开源免费 CA)"></a>Let’s Encrypt (开源免费 CA)</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">特点:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">基于</span> <span class="string">ACME</span> <span class="string">协议的自动化证书管理</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">免费提供</span> <span class="string">DV</span> <span class="string">(域名验证)</span> <span class="string">证书</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">90</span><span class="string">天短期证书，强制自动化更新</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">支持通配符证书和多域名证书</span></span><br><span class="line"><span class="string">应用场景:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">公网</span> <span class="string">HTTPS</span> <span class="string">网站加密</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">开发测试环境</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">小型企业和个人项目</span></span><br></pre></td></tr></table></figure><h4 id="企业级商业-PKI-解决方案"><a href="#企业级商业-PKI-解决方案" class="headerlink" title="企业级商业 PKI 解决方案"></a>企业级商业 PKI 解决方案</h4><ul><li><strong>Entrust PKI</strong>: 高安全等级，政府和金融行业首选</li><li><strong>DigiCert CertCentral</strong>: 全球领先的商业证书服务</li><li><strong>GlobalSign</strong>: 欧洲主导的国际化 PKI 服务商</li></ul><h2 id="数字证书格式标准"><a href="#数字证书格式标准" class="headerlink" title="数字证书格式标准"></a>数字证书格式标准</h2><h3 id="X-509-证书标准概述"><a href="#X-509-证书标准概述" class="headerlink" title="X.509 证书标准概述"></a>X.509 证书标准概述</h3><p>所有数字证书均基于 <strong>ITU-T X.509 标准</strong>，定义了证书的基本结构和字段。无论是 PKCS#1、PKCS#12、SCEP 还是 ACME 获取的证书，本质上都是 X.509 格式的不同封装和传输方式。</p><h3 id="PKCS-标准族系"><a href="#PKCS-标准族系" class="headerlink" title="PKCS 标准族系"></a>PKCS 标准族系</h3><p><strong>PKCS (Public-Key Cryptography Standards)</strong> 是由 RSA 实验室制定的公钥密码学标准系列，其中 PKCS#1 和 PKCS#12 是数字证书领域的重要标准。</p><h4 id="PKCS-1-格式证书-仅证书内容"><a href="#PKCS-1-格式证书-仅证书内容" class="headerlink" title="PKCS#1 格式证书 (仅证书内容)"></a>PKCS#1 格式证书 (仅证书内容)</h4><p><strong>核心特征</strong>:</p><ul><li><strong>内容</strong>: 仅包含 X.509 公钥证书，不包含私钥</li><li><strong>安全性</strong>: 可公开分发，用于身份验证和加密</li><li><strong>编码方式</strong>: 支持 DER (二进制) 和 PEM (Base64文本) 两种编码</li></ul><p><strong>常见文件扩展名</strong>:</p><table><thead><tr><th>扩展名</th><th>编码格式</th><th>主要用途</th><th>适用平台</th></tr></thead><tbody><tr><td><strong>.crt</strong></td><td>DER&#x2F;PEM</td><td>服务器证书、通用证书文件</td><td>跨平台通用</td></tr><tr><td><strong>.cer</strong></td><td>DER&#x2F;PEM</td><td>Windows 系统偏好格式</td><td>Windows主导</td></tr><tr><td><strong>.der</strong></td><td>DER</td><td>二进制编码证书</td><td>系统级应用</td></tr><tr><td><strong>.pem</strong></td><td>PEM</td><td>Base64文本证书、证书链</td><td>Linux&#x2F;Unix</td></tr></tbody></table><p><strong>实际应用示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 典型证书文件命名</span></span><br><span class="line">ssl-certificate.crt      <span class="comment"># Web服务器SSL证书</span></span><br><span class="line">root-ca.cer             <span class="comment"># 根证书颁发机构证书</span></span><br><span class="line">intermediate.der        <span class="comment"># 中间证书颁发机构证书</span></span><br><span class="line">certificate-chain.pem   <span class="comment"># 完整证书链文件</span></span><br><span class="line">client-auth.crt         <span class="comment"># 客户端认证证书</span></span><br></pre></td></tr></table></figure><h4 id="PKCS-12-格式证书-完整身份包"><a href="#PKCS-12-格式证书-完整身份包" class="headerlink" title="PKCS#12 格式证书 (完整身份包)"></a>PKCS#12 格式证书 (完整身份包)</h4><p><strong>核心特征</strong>:</p><ul><li><strong>内容</strong>: 证书 + 私钥 + 可选的证书链</li><li><strong>安全性</strong>: 密码保护的二进制容器格式</li><li><strong>用途</strong>: 完整数字身份的安全传输和存储</li></ul><p><strong>常见文件扩展名</strong>:</p><table><thead><tr><th>扩展名</th><th>主要平台</th><th>使用场景</th></tr></thead><tbody><tr><td><strong>.p12</strong></td><td>跨平台标准</td><td>标准 PKCS#12 格式</td></tr><tr><td><strong>.pfx</strong></td><td>Windows</td><td>Microsoft 个人信息交换格式</td></tr><tr><td><strong>.pkcs12</strong></td><td>Linux&#x2F;Unix</td><td>明确标识的 PKCS#12 格式</td></tr></tbody></table><p><strong>典型使用场景</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实际应用示例</span></span><br><span class="line">user-identity.p12        <span class="comment"># 用户个人数字身份</span></span><br><span class="line">client-certificate.pfx   <span class="comment"># 客户端双向认证证书</span></span><br><span class="line">device-identity.pkcs12   <span class="comment"># IoT设备身份证书</span></span><br><span class="line">code-signing.p12         <span class="comment"># 代码签名证书</span></span><br><span class="line">email-certificate.pfx    <span class="comment"># S/MIME邮件加密证书</span></span><br></pre></td></tr></table></figure><h4 id="格式对比总结"><a href="#格式对比总结" class="headerlink" title="格式对比总结"></a>格式对比总结</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">PKCS#1</span> <span class="string">证书:</span></span><br><span class="line">  <span class="string">包含内容:</span> <span class="string">仅</span> <span class="string">X.509</span> <span class="string">证书</span> <span class="string">(公钥)</span></span><br><span class="line">  <span class="string">私钥位置:</span> <span class="string">单独存储管理</span></span><br><span class="line">  <span class="string">安全等级:</span> <span class="string">中等</span> <span class="string">(证书可公开)</span></span><br><span class="line">  <span class="string">使用复杂度:</span> <span class="string">需要额外管理私钥</span></span><br><span class="line">  <span class="string">主要用途:</span> <span class="string">服务器证书、证书链验证</span></span><br><span class="line"></span><br><span class="line"><span class="string">PKCS#12</span> <span class="string">证书:</span></span><br><span class="line">  <span class="string">包含内容:</span> <span class="string">证书</span> <span class="string">+</span> <span class="string">私钥</span> <span class="string">+</span> <span class="string">证书链</span></span><br><span class="line">  <span class="string">私钥保护:</span> <span class="string">密码加密保护</span></span><br><span class="line">  <span class="string">安全等级:</span> <span class="string">高</span> <span class="string">(完整身份保护)</span></span><br><span class="line">  <span class="string">使用便利性:</span> <span class="string">一站式身份解决方案</span></span><br><span class="line">  <span class="string">主要用途:</span> <span class="string">客户端身份认证、数字签名</span></span><br></pre></td></tr></table></figure><h2 id="SCEP"><a href="#SCEP" class="headerlink" title="SCEP"></a>SCEP</h2><p>SCEP（Simple Certificate Enrollment Protocol，简单证书注册协议）证书是通过 SCEP 协议从 CA 获取的数字证书（也是 X.509 格式），包含公钥和私钥（设备本地生成，不由CA传输）。</p><ul><li>相较于P12证书要手动更新， SCEP证书，需要联网，根据配置参数申请证书，动态更新，支持自动续期，</li><li>场景：常用于企业内部，专注于设备身份验证（VPN 、WIFI）</li><li>使用者：企业 IT 管理员、设备管理。</li></ul><h2 id="ACME"><a href="#ACME" class="headerlink" title="ACME"></a>ACME</h2><p>ACME（Automatic Certificate Management Environmen）证书是通过 ACME 协议从 CA（如 Let’s Encrypt）获取的数字证书，通常是 X.509 格式，包含公钥和私钥（设备本地生成，不由CA传输），用于证明身份和加密通信。</p><ul><li>场景：专注于WEB安全，多用于网站的HTTPS验证</li><li>使用者：网站管理员、开发者。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PKI </tag>
            
            <tag> 数字证书 </tag>
            
            <tag> CA </tag>
            
            <tag> 加密 </tag>
            
            <tag> PKCS </tag>
            
            <tag> SCEP </tag>
            
            <tag> ACME </tag>
            
            <tag> X.509 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hibernate ORM 框架详解</title>
      <link href="/posts/22172.html"/>
      <url>/posts/22172.html</url>
      
        <content type="html"><![CDATA[<h1 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h1><p>Hibernate 是一个用于 Java 环境的开源对象关系映射（ORM）框架，XML 映射文件是 Hibernate 配置实体类和数据库表之间映射关系的重要方式。以下是 Hibernate XML 映射文件中常见标签的介绍：</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>在 Spring 框架中使用 Hibernate 作为 ORM 框架时，需要导入以下相关库（依赖项）。以下是基于 Maven 或 Gradle 的依赖配置，具体依赖取决于你使用的 Spring 版本、Hibernate 版本以及是否使用 JPA。</p><h3 id="1-核心-Dependencies"><a href="#1-核心-Dependencies" class="headerlink" title="1. 核心 Dependencies"></a>1. <strong>核心 D</strong>ependencies</h3><h4 id="Hibernate-Core"><a href="#Hibernate-Core" class="headerlink" title="Hibernate Core"></a>Hibernate Core</h4><p>Hibernate 的核心库，提供基本的 ORM 功能。</p><ul><li><strong>Maven</strong>:<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.6.15.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 替换为最新稳定版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>Gradle</strong>:<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.hibernate:hibernate-core:5.6.15.Final&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="Spring-ORM"><a href="#Spring-ORM" class="headerlink" title="Spring ORM"></a>Spring ORM</h4><p>Spring 提供的 ORM 模块，集成 Hibernate 并简化配置（如 <code>SessionFactory</code> 管理）。</p><ul><li><strong>Maven</strong>:<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-orm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 与你的 Spring 版本保持一致 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>Gradle</strong>:<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.springframework:spring-orm:5.3.27&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-数据库驱动"><a href="#2-数据库驱动" class="headerlink" title="2. 数据库驱动"></a>2. <strong>数据库驱动</strong></h3><p>需要根据你使用的数据库（如 MySQL、PostgreSQL 等）添加对应的 JDBC 驱动。例如：</p><ul><li><p><strong>MySQL 驱动</strong>:</p><ul><li><strong>Maven</strong>:<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 替换为最新版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>Gradle</strong>:<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;mysql:mysql-connector-java:8.0.33&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>PostgreSQL 驱动</strong>（示例）:</p><ul><li><strong>Maven</strong>:<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.postgresql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>postgresql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>42.7.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>Gradle</strong>:<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.postgresql:postgresql:42.7.3&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-可选依赖"><a href="#3-可选依赖" class="headerlink" title="3. 可选依赖"></a>3. <strong>可选依赖</strong></h3><h4 id="连接池（推荐）"><a href="#连接池（推荐）" class="headerlink" title="连接池（推荐）"></a>连接池（推荐）</h4><p>为了提高性能，通常使用数据库连接池（如 HikariCP、C3P0 或 DBCP）。Spring Boot 默认使用 HikariCP。</p><ul><li><strong>HikariCP</strong>:<ul><li><strong>Maven</strong>:<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zaxxer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HikariCP<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>Gradle</strong>:<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.zaxxer:HikariCP:5.0.1&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="如果使用-Spring-Boot"><a href="#如果使用-Spring-Boot" class="headerlink" title="如果使用 Spring Boot"></a>如果使用 Spring Boot</h4><p>Spring Boot 提供了 starter 依赖，简化配置：</p><ul><li><strong>Maven</strong>:<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 与你的 Spring Boot 版本一致 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>Gradle</strong>:<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-data-jpa:2.7.18&#x27;</span></span><br></pre></td></tr></table></figure><strong>说明</strong>：<code>spring-boot-starter-data-jpa</code> 已经包含了 Hibernate、Spring ORM 和 JPA 相关依赖，并默认配置 HikariCP。你还需要单独添加数据库驱动（如 MySQL）。</li></ul><h3 id="4-版本注意事项"><a href="#4-版本注意事项" class="headerlink" title="4. 版本注意事项"></a>4. <strong>版本注意事项</strong></h3><ul><li><strong>Hibernate 版本</strong>：推荐使用最新稳定版（截至 2025 年 4 月，5.6.x 或 6.x 系列）。Hibernate 6.x 要求 JDK 11+ 并有重大变更（如去掉 <code>hibernate-entitymanager</code> 包）。</li><li><strong>Spring 版本</strong>：确保 Spring 和 Hibernate 版本兼容。例如，Spring 5.x 通常与 Hibernate 5.x 搭配，Spring 6.x 与 Hibernate 6.x 更兼容。</li><li><strong>Spring Boot</strong>：如果使用 Spring Boot，<code>spring-boot-starter-data-jpa</code> 会自动管理兼容的 Hibernate 版本。</li></ul><h3 id="5-典型配置示例（非-Spring-Boot）"><a href="#5-典型配置示例（非-Spring-Boot）" class="headerlink" title="5. 典型配置示例（非 Spring Boot）"></a>5. <strong>典型配置示例（非 Spring Boot）</strong></h3><p>在 Spring 配置文件（如 <code>applicationContext.xml</code>）中配置 Hibernate：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zaxxer.hikari.HikariDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/yourdb&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;packagesToScan&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.example.model&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernateProperties&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.dialect&quot;</span>&gt;</span>org.hibernate.dialect.MySQL8Dialect<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.show_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.hbm2ddl.auto&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sessionFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-Spring-Boot-配置"><a href="#6-Spring-Boot-配置" class="headerlink" title="6. Spring Boot 配置"></a>6. <strong>Spring Boot 配置</strong></h3><p>如果使用 Spring Boot，只需在 <code>application.properties</code> 或 <code>application.yml</code> 中配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/yourdb</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">password</span></span><br><span class="line"><span class="attr">spring.jpa.hibernate.ddl-auto</span>=<span class="string">update</span></span><br><span class="line"><span class="attr">spring.jpa.show-sql</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.jpa.properties.hibernate.dialect</span>=<span class="string">org.hibernate.dialect.MySQL8Dialect</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>最小依赖</strong>：<code>hibernate-core</code>、<code>spring-orm</code>、数据库驱动。</li><li><strong>推荐（Spring Boot）</strong>：<code>spring-boot-starter-data-jpa</code> + 数据库驱动。</li><li><strong>JPA 场景</strong>：添加 <code>hibernate-entitymanager</code>（Hibernate 5.x）。</li><li><strong>连接池</strong>：建议使用 HikariCP。</li></ul><p>如果使用 Spring Boot，<code>spring-boot-starter-data-jpa</code> 是最简便的方式。如果是传统 Spring 项目，需手动添加 Hibernate 和 Spring ORM 依赖。确保版本兼容，并根据数据库类型选择合适的驱动。</p><p>如果你有具体场景（例如 Spring Boot 版本、数据库类型）或遇到配置问题，请提供更多细节，我可以进一步优化答案！</p><h2 id="XML-配置文件"><a href="#XML-配置文件" class="headerlink" title="XML 配置文件"></a>XML 配置文件</h2><h3 id=""><a href="#" class="headerlink" title="&lt;hibernate-mapping&gt;"></a><code>&lt;hibernate-mapping&gt;</code></h3><p>这是 Hibernate XML 映射文件的根标签，用于标识一个映射文档的开始和结束，它可以包含多个 <code>&lt;class&gt;</code> 标签。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 其他标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title="&lt;class&gt;"></a><code>&lt;class&gt;</code></h3><p><code>&lt;class&gt;</code> 标签用于定义 Java 类和数据库表之间的映射关系。</p><ul><li><p><code>name</code> 属性：指定 Java 类的全限定名。</p></li><li><p><code>table</code> 属性：指定对应的数据库表名。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;com.example.User&quot;</span> <span class="attr">table</span>=<span class="string">&quot;users&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 其他标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="-2"><a href="#-2" class="headerlink" title="&lt;id&gt;"></a><code>&lt;id&gt;</code></h3><p>  <code>&lt;id&gt;</code> 标签用于映射 Java 类中的主键属性到数据库表的主键列。</p><ul><li><p><code>name</code> 属性：指定 Java 类中的主键属性名。</p></li><li><p><code>column</code> 属性：指定数据库表中的主键列名。</p></li><li><p><code>type</code> 属性：指定属性的数据类型。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;long&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 主键生成策略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="-3"><a href="#-3" class="headerlink" title="&lt;generator&gt;"></a><code>&lt;generator&gt;</code></h3><p><code>&lt;generator&gt;</code> 标签用于指定主键的生成策略，通常嵌套在 <code>&lt;id&gt;</code> 标签内。常见的生成策略有：</p><ul><li><p><code>native</code>：根据数据库的支持自动选择合适的主键生成策略（如自增、序列等）。</p></li><li><p><code>increment</code>：由 Hibernate 自动生成一个递增的主键值。</p></li><li><p><code>uuid</code>：生成一个 UUID 作为主键值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="-4"><a href="#-4" class="headerlink" title="&lt;property&gt;"></a><code>&lt;property&gt;</code></h3><p><code>&lt;property&gt;</code> 标签用于映射 Java 类中的普通属性到数据库表的列。</p><ul><li><p><code>name</code> 属性：指定 Java 类中的属性名。</p></li><li><p><code>column</code> 属性：指定数据库表中的列名。</p></li><li><p><code>type</code> 属性：指定属性的数据类型。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="-5"><a href="#-5" class="headerlink" title="&lt;many-to-one&gt;"></a><code>&lt;many-to-one&gt;</code></h3><p><code>&lt;many-to-one&gt;</code> 标签用于映射多对一的关联关系，例如多个用户属于一个部门。</p><ul><li><p><code>name</code> 属性：指定 Java 类中关联对象的属性名。</p></li><li><p><code>column</code> 属性：指定数据库表中用于关联的外键列名。</p></li><li><p><code>class</code> 属性：指定关联对象的 Java 类全限定名。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">&quot;department&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Department&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="-6"><a href="#-6" class="headerlink" title="&lt;one-to-many&gt;"></a><code>&lt;one-to-many&gt;</code></h3><p><code>&lt;one-to-many&gt;</code> 标签用于映射一对多的关联关系，例如一个部门有多个用户。</p><ul><li><p><code>name</code> 属性：指定 Java 类中关联对象集合的属性名。</p></li><li><p><code>class</code> 属性：指定关联对象的 Java 类全限定名。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">name</span>=<span class="string">&quot;users&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.User&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="-7"><a href="#-7" class="headerlink" title="&lt;set&gt;"></a><code>&lt;set&gt;</code></h3><p><code>&lt;set&gt;</code> 标签用于映射 Java 类中的集合属性，通常与 <code>&lt;one-to-many&gt;</code> 或 <code>&lt;many-to-many&gt;</code> 关联使用。</p><ul><li><p><code>name</code> 属性：指定 Java 类中的集合属性名。</p></li><li><p><code>table</code> 属性：指定关联表名（在多对多关系中使用）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">&quot;users&quot;</span> <span class="attr">table</span>=<span class="string">&quot;user_department&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">&quot;com.example.User&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="-8"><a href="#-8" class="headerlink" title="&lt;Bag&gt;"></a><code>&lt;Bag&gt;</code></h3><p>在 Hibernate XML 映射文件里，<code>&lt;bag&gt;</code>标签用于映射 Java 类中的集合属性，它表示无序且可重复的集合，类似于 Java 里的<code>java.util.Collection</code>。下面为你详细介绍其用法和相关属性：</p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>&lt;bag&gt;</code>标签常被用于映射一对多或者多对多的关联关系。它一般和<code>&lt;key&gt;</code>、<code>&lt;one-to-many&gt;</code>或者<code>&lt;many-to-many&gt;</code>标签搭配使用。以下是个简单示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;com.example.Department&quot;</span> <span class="attr">table</span>=<span class="string">&quot;departments&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;long&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bag</span> <span class="attr">name</span>=<span class="string">&quot;employees&quot;</span> <span class="attr">table</span>=<span class="string">&quot;dept_emp&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Employee&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bag</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Department</code>类有一个<code>employees</code>属性，它是一个无序且可重复的<code>Employee</code>对象集合。<code>&lt;bag&gt;</code>标签定义了这个集合属性的映射，<code>&lt;key&gt;</code>标签指明了关联表中的外键列，<code>&lt;one-to-many&gt;</code>标签表明了一对多的关联关系。</p><h4 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h4><ul><li><p><strong><code>name</code></strong>：指定 Java 类中的集合属性名，就像上面例子中的<code>employees</code>。</p></li><li><p><strong><code>table</code></strong>：指定关联表名，在一对多或者多对多关系里使用。比如在多对多关系中，需要一个中间表来存储关联信息，<code>table</code>属性就指定了这个中间表的名称。</p></li><li><p><strong><code>cascade</code></strong>：定义级联操作，它确定了在对父对象执行某些操作（如保存、更新、删除）时，是否要对关联对象也执行相同操作。常见的值有<code>save-update</code>、<code>delete</code>、<code>all</code>等。示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bag</span> <span class="attr">name</span>=<span class="string">&quot;employees&quot;</span> <span class="attr">table</span>=<span class="string">&quot;dept_emp&quot;</span> <span class="attr">cascade</span>=<span class="string">&quot;save-update&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Employee&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bag</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>inverse</code></strong>：是一个布尔值，用来指定关联关系的控制权在哪一方。若设为<code>true</code>，则表示关联关系的维护由另一方负责；若设为<code>false</code>（默认值），则当前对象负责维护关联关系。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bag</span> <span class="attr">name</span>=<span class="string">&quot;employees&quot;</span> <span class="attr">table</span>=<span class="string">&quot;dept_emp&quot;</span> <span class="attr">inverse</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Employee&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bag</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>与<code>&lt;set&gt;</code>标签对比</p><p>和<code>&lt;set&gt;</code>标签不同，<code>&lt;bag&gt;</code>允许集合中有重复元素，而<code>&lt;set&gt;</code>要求元素唯一。所以，当你需要一个可包含重复元素的集合时，就可以使用<code>&lt;bag&gt;</code>标签。 </p><h3 id="-9"><a href="#-9" class="headerlink" title="&lt;discriminator&gt;"></a><code>&lt;discriminator&gt;</code></h3><p>在 Hibernate 的 XML 配置文件里，<code>&lt;discriminator&gt;</code>标签主要用于实现继承映射。当 Java 类存在继承关系时，该标签能够把这些具有继承关系的类映射到数据库的同一张表中，借助一个特定的列来区分不同的子类。下面为你详细介绍其使用方式和相关属性。</p><h4 id="基本使用场景"><a href="#基本使用场景" class="headerlink" title="基本使用场景"></a>基本使用场景</h4><p>在实际开发中，可能会有多个子类继承自同一个父类的情况。若把这些子类分别映射到不同的数据库表，会使数据库结构变得复杂。通过<code>&lt;discriminator&gt;</code>标签，可将所有子类的数据存储在同一张表中，再用一个特殊的列来辨别不同的子类。</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;com.example.Animal&quot;</span> <span class="attr">table</span>=<span class="string">&quot;animals&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;animal_id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;long&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">column</span>=<span class="string">&quot;animal_type&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">subclass</span> <span class="attr">name</span>=<span class="string">&quot;com.example.Dog&quot;</span> <span class="attr">discriminator-value</span>=<span class="string">&quot;dog&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Dog 类特有的属性映射 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">subclass</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">subclass</span> <span class="attr">name</span>=<span class="string">&quot;com.example.Cat&quot;</span> <span class="attr">discriminator-value</span>=<span class="string">&quot;cat&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Cat 类特有的属性映射 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">subclass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述示例中：</p><ul><li><code>Animal</code>是父类，<code>Dog</code>和<code>Cat</code>是它的子类。</li><li><code>&lt;discriminator&gt;</code>标签指定了一个名为<code>animal_type</code>的列，数据类型为字符串，用于区分不同的子类。</li><li><code>&lt;subclass&gt;</code>标签定义了子类的映射，<code>discriminator-value</code>属性指定了该子类在<code>animal_type</code>列中对应的值。</li></ul><h4 id="常用属性-1"><a href="#常用属性-1" class="headerlink" title="常用属性"></a>常用属性</h4><ul><li><strong><code>column</code></strong>：指定数据库表中用于区分不同子类的列名。在上面的例子中，<code>column=&quot;animal_type&quot;</code>表示使用<code>animal_type</code>列来存储子类的区分信息。</li><li><strong><code>type</code></strong>：指定区分列的数据类型，例如<code>string</code>、<code>integer</code>等。</li></ul><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>当 Hibernate 从数据库中查询数据时，会依据<code>&lt;discriminator&gt;</code>标签指定的列的值来判断应该将数据实例化为哪个子类的对象。比如，若<code>animal_type</code>列的值为<code>dog</code>，Hibernate 就会把数据实例化为<code>Dog</code>类的对象；若值为<code>cat</code>，则实例化为<code>Cat</code>类的对象。</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li><strong>简化数据库结构</strong>：避免为每个子类创建单独的表，减少了数据库表的数量，使数据库结构更加简洁。</li><li><strong>提高数据查询效率</strong>：因为所有子类的数据都存储在同一张表中，查询时无需进行复杂的表连接操作，提高了查询效率。</li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><strong>区分列的唯一性</strong>：<code>discriminator-value</code>属性的值必须唯一，否则会导致 Hibernate 在实例化对象时出现混淆。</li><li><strong>数据一致性</strong>：在插入数据时，要确保区分列的值与<code>&lt;subclass&gt;</code>标签中<code>discriminator-value</code>属性的值一致，以保证数据的一致性。</li></ul><h3 id="-10"><a href="#-10" class="headerlink" title="&lt;key&gt;"></a><code>&lt;key&gt;</code></h3><p><code>&lt;key&gt;</code> 标签用于指定关联表中的外键列，通常在 <code>&lt;set&gt;</code> 或 <code>&lt;list&gt;</code> 标签中使用。</p><ul><li><p><code>column</code> 属性：指定外键列名。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>这些标签是 Hibernate XML 映射文件中最常用的部分，通过合理使用它们，可以实现 Java 类和数据库表之间的灵活映射。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>Hibernate 是一个流行的 Java 持久层框架，它允许你通过对象关系映射（ORM）的方式来操作数据库。以下是 Hibernate 中一些常用的注解：</p><ol><li><p><strong>@Entity</strong>：用于标注实体类，表示该类对应数据库中的一张表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@Table</strong>：与 <code>@Entity</code> 一起使用，指定实体类所对应的数据库表名。如果不指定，默认使用类名作为表名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@Id</strong>：标记属性为主键。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure></li><li><p><strong>@GeneratedValue</strong>：定义主键的生成策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure><p>常见的生成策略有 <code>AUTO</code>, <code>IDENTITY</code>, <code>SEQUENCE</code>, 和 <code>TABLE</code>。</p></li><li><p><strong>@Column</strong>：用于描述实体类中的字段如何映射到数据库表中的列。可以指定列名、是否允许为空等属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Column(name = &quot;user_name&quot;, nullable = false, length = 30)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure></li><li><p><strong>@Transient</strong>：表示某个属性不会被持久化到数据库中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> String tempValue;</span><br></pre></td></tr></table></figure></li><li><p><strong>@ManyToOne</strong>, <strong>@OneToMany</strong>, <strong>@OneToOne</strong>, <strong>@ManyToMany</strong>：用于定义实体之间的关系。例如，<code>@ManyToOne</code> 表示多对一的关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn(name = &quot;department_id&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Department department;</span><br></pre></td></tr></table></figure></li><li><p><strong>@JoinColumn</strong>：用于指定连接列（外键），通常在定义关联关系时使用。</p></li><li><p><strong>@Embedded</strong>, <strong>@Embeddable</strong>：用于组合模式，<code>@Embeddable</code> 标记的类可以在其他实体中嵌入使用，而 <code>@Embedded</code> 用来嵌入这些可嵌入的对象。</p></li><li><p><strong>@Formula</strong>：用于定义基于SQL公式或子查询的虚拟属性。</p></li></ol><p>以上仅是部分常用的 Hibernate 注解，根据实际需要可能还会涉及到更多高级特性和注解。使用这些注解可以大大简化Java应用程序与数据库交互的代码。</p><h2 id="Session-和-SessionFactory"><a href="#Session-和-SessionFactory" class="headerlink" title="Session 和 SessionFactory"></a>Session 和 SessionFactory</h2><p>在 Hibernate 中，<code>Session</code> 和 <code>SessionFactory</code> 是核心组件，负责管理与数据库的交互以及对象持久化。它们与 Hibernate 的缓存机制密切相关，共同影响应用的性能和数据一致性。下面详细解释 <code>Session</code>、<code>SessionFactory</code>、缓存机制及其相关性。</p><hr><h3 id="1-Session"><a href="#1-Session" class="headerlink" title="1. Session"></a><strong>1. Session</strong></h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h4><p><code>Session</code> 是 Hibernate 的核心接口（<code>org.hibernate.Session</code>），用于执行数据库操作（如增删改查），是应用程序与数据库交互的主要入口。它封装了 JDBC 连接，管理实体对象的生命周期，并维护一个<strong>一级缓存</strong>（Persistence Context）。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h4><ul><li><strong>非线程安全</strong>：<code>Session</code> 设计为单线程使用，不应在多个线程间共享。每个线程或请求通常需要独立的 <code>Session</code>。</li><li><strong>短生命周期</strong>：<code>Session</code> 通常在一次数据库操作或事务中创建，用完后关闭，避免资源泄漏。</li><li><strong>一级缓存</strong>：<code>Session</code> 内部维护一个缓存，存储当前会话中的实体对象，减少数据库访问。</li><li><strong>代理 JDBC 连接</strong>：<code>Session</code> 通过底层的 JDBC 连接与数据库通信，但开发者无需直接操作 JDBC。</li></ul><h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a><strong>主要功能</strong></h4><ul><li><strong>CRUD 操作</strong>：保存（<code>save</code>）、更新（<code>update</code>）、删除（<code>delete</code>）、查询（<code>get</code>、<code>load</code>）。</li><li><strong>查询执行</strong>：支持 HQL（<code>createQuery</code>）、Criteria API、原生 SQL。</li><li><strong>事务管理</strong>：通过 <code>beginTransaction</code> 开启事务，管理数据库操作。</li><li><strong>缓存管理</strong>：维护一级缓存，自动处理脏检查（Dirty Checking）。</li></ul><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a><strong>常用方法</strong></h4><ul><li><code>save(Object)</code>：保存实体，返回标识符。</li><li><code>update(Object)</code>：更新实体。</li><li><code>merge(Object)</code>：合并 detached 状态的实体。</li><li><code>delete(Object)</code>：删除实体。</li><li><code>get(Class, Serializable)</code>：根据 ID 立即加载实体。</li><li><code>load(Class, Serializable)</code>：延迟加载实体。</li><li><code>createQuery(String)</code>：创建 HQL 查询。</li><li><code>flush()</code>：同步持久化上下文到数据库。</li><li><code>clear()</code>：清空一级缓存。</li><li><code>beginTransaction()</code>：开启事务。</li></ul><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a><strong>生命周期</strong></h4><ol><li>创建：通过 <code>SessionFactory.openSession()</code> 或 <code>SessionFactory.getCurrentSession()</code> 获取。</li><li>使用：执行数据库操作，管理实体。</li><li>关闭：调用 <code>close()</code> 释放资源（Spring 可自动管理）。</li></ol><hr><h3 id="2-SessionFactory"><a href="#2-SessionFactory" class="headerlink" title="2. SessionFactory"></a><strong>2. SessionFactory</strong></h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a><strong>定义</strong></h4><p><code>SessionFactory</code> 是 Hibernate 的工厂接口（<code>org.hibernate.SessionFactory</code>），负责创建 <code>Session</code> 实例。它是一个<strong>线程安全</strong>的全局对象，初始化时加载 Hibernate 配置和映射元数据。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a><strong>特点</strong></h4><ul><li><strong>线程安全</strong>：<code>SessionFactory</code> 可以在多个线程间共享，通常在应用启动时创建单一实例。</li><li><strong>重量级对象</strong>：创建 <code>SessionFactory</code> 开销大，因为它需要解析配置文件、映射元数据并建立数据库连接池。</li><li><strong>全局单例</strong>：整个应用通常只有一个 <code>SessionFactory</code>，除非使用多个数据库。</li><li><strong>配置中心</strong>：存储 Hibernate 配置（如数据库连接、方言、缓存设置）和实体映射信息。</li></ul><h4 id="主要功能-1"><a href="#主要功能-1" class="headerlink" title="主要功能"></a><strong>主要功能</strong></h4><ul><li>创建 <code>Session</code> 实例。</li><li>管理 Hibernate 配置和元数据。</li><li>提供对二级缓存（如果启用）的访问。</li></ul><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a><strong>常用方法</strong></h4><ul><li><code>openSession()</code>：创建新的 <code>Session</code>，需手动关闭。</li><li><code>getCurrentSession()</code>：获取当前线程绑定的 <code>Session</code>（需配置事务上下文，Spring 常用）。</li><li><code>close()</code>：关闭工厂，释放资源（通常在应用关闭时调用）。</li></ul><h4 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a><strong>生命周期</strong></h4><ol><li>初始化：应用启动时，通过 <code>Configuration</code> 或 Spring 配置创建 <code>SessionFactory</code>。</li><li>使用：提供 <code>Session</code> 实例，服务整个应用。</li><li>销毁：应用关闭时调用 <code>close()</code> 释放资源。</li></ol><hr><h3 id="3-Hibernate-缓存机制"><a href="#3-Hibernate-缓存机制" class="headerlink" title="3. Hibernate 缓存机制"></a><strong>3. Hibernate 缓存机制</strong></h3><p>Hibernate 提供两级缓存机制，用于减少数据库访问，提高性能：<strong>一级缓存</strong>（与 <code>Session</code> 相关）和<strong>二级缓存</strong>（与 <code>SessionFactory</code> 相关）。</p><h4 id="一级缓存（First-Level-Cache）"><a href="#一级缓存（First-Level-Cache）" class="headerlink" title="一级缓存（First-Level Cache）"></a><strong>一级缓存（First-Level Cache）</strong></h4><ul><li><strong>定义</strong>：一级缓存是 <code>Session</code> 级别的缓存，自动启用，存储当前 <code>Session</code> 内的实体对象。也被称为<strong>持久化上下文</strong>（Persistence Context）。</li><li><strong>作用</strong>：<ul><li>缓存实体对象，避免重复查询数据库。</li><li>实现脏检查，自动检测实体变化并同步到数据库。</li><li>管理实体状态（Managed、Detached、Transient）。</li></ul></li><li><strong>生命周期</strong>：与 <code>Session</code> 绑定，<code>Session</code> 关闭或调用 <code>clear()</code> 时缓存清空。</li><li><strong>特点</strong>：<ul><li>强制启用，无法禁用。</li><li>仅在同一 <code>Session</code> 内有效，不跨 <code>Session</code> 共享。</li><li>缓存的是实体对象的完整状态（包括关联对象）。</li></ul></li><li><strong>工作原理</strong>：<ul><li>当通过 <code>get()</code>、<code>load()</code> 或查询加载实体时，Hibernate 将实体放入一级缓存。</li><li>同一 <code>Session</code> 内重复查询相同实体时，直接从缓存返回，避免数据库访问。</li><li>在事务提交或 <code>flush()</code> 时，Hibernate 对比缓存中的实体与数据库状态，执行必要的 SQL 更新（脏检查）。</li></ul></li></ul><h4 id="二级缓存（Second-Level-Cache）"><a href="#二级缓存（Second-Level-Cache）" class="headerlink" title="二级缓存（Second-Level Cache）"></a><strong>二级缓存（Second-Level Cache）</strong></h4><ul><li><strong>定义</strong>：二级缓存是 <code>SessionFactory</code> 级别的缓存，可选启用，存储跨 <code>Session</code> 的实体数据或查询结果。</li><li><strong>作用</strong>：<ul><li>提高跨 <code>Session</code> 的查询性能，减少数据库访问。</li><li>适合频繁读取、不常修改的数据（如配置表、字典表）。</li></ul></li><li><strong>生命周期</strong>：与 <code>SessionFactory</code> 绑定，应用运行期间持续存在。</li><li><strong>特点</strong>：<ul><li>默认禁用，需显式配置（如 EHCache、Redis）。</li><li>可缓存实体、查询结果或集合。</li><li>跨 <code>Session</code> 和线程共享，需考虑并发一致性。</li></ul></li><li><strong>配置</strong>：<ul><li>启用二级缓存：设置 <code>hibernate.cache.use_second_level_cache=true</code>。</li><li>指定缓存提供者（如 <code>org.hibernate.cache.ehcache.EhCacheRegionFactory</code>）。</li><li>在实体上使用 <code>@Cache</code> 注解：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="查询缓存（Query-Cache）"><a href="#查询缓存（Query-Cache）" class="headerlink" title="查询缓存（Query Cache）"></a><strong>查询缓存（Query Cache）</strong></h4><ul><li><strong>定义</strong>：查询缓存是二级缓存的子集，用于缓存 HQL&#x2F;JPQL 查询的结果（仅缓存实体 ID 和简单数据）。</li><li><strong>作用</strong>：避免重复执行相同的查询。</li><li><strong>启用方式</strong>：<ul><li>设置 <code>hibernate.cache.use_query_cache=true</code>。</li><li>在查询时调用 <code>setCacheable(true)</code>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> session.createQuery(<span class="string">&quot;from User where name = :name&quot;</span>);</span><br><span class="line">query.setParameter(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">query.setCacheable(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>注意</strong>：查询缓存通常与二级缓存一起使用，因为查询结果的实体仍需从二级缓存加载。</li></ul><hr><h3 id="4-Session、SessionFactory-和缓存机制的相关性"><a href="#4-Session、SessionFactory-和缓存机制的相关性" class="headerlink" title="4. Session、SessionFactory 和缓存机制的相关性"></a><strong>4. Session、SessionFactory 和缓存机制的相关性</strong></h3><p><code>Session</code>、<code>SessionFactory</code> 和缓存机制在 Hibernate 中紧密协作，共同管理数据访问和性能优化。以下是它们之间的关系：</p><h4 id="Session-和-SessionFactory-1"><a href="#Session-和-SessionFactory-1" class="headerlink" title="Session 和 SessionFactory"></a><strong>Session 和 SessionFactory</strong></h4><ul><li><strong>创建关系</strong>：<code>SessionFactory</code> 是工厂，负责创建 <code>Session</code> 实例。每个 <code>Session</code> 都与 <code>SessionFactory</code> 关联，共享其配置（如数据库连接、方言）。</li><li><strong>配置共享</strong>：<code>SessionFactory</code> 持有 Hibernate 的全局配置（包括映射元数据、缓存设置），<code>Session</code> 使用这些配置执行具体操作。</li><li><strong>生命周期差异</strong>：<ul><li><code>SessionFactory</code> 是应用级别的单例，生命周期长。</li><li><code>Session</code> 是请求或事务级别的，生命周期短，创建和销毁频繁。</li></ul></li><li><strong>Spring 集成</strong>：在 Spring 中，<code>SessionFactory</code> 由容器管理，<code>Session</code> 通过 <code>getCurrentSession()</code> 或 Spring 的 <code>@Transactional</code> 自动管理。</li></ul><h4 id="Session-和一级缓存"><a href="#Session-和一级缓存" class="headerlink" title="Session 和一级缓存"></a><strong>Session 和一级缓存</strong></h4><ul><li><strong>直接关联</strong>：一级缓存是 <code>Session</code> 的内置功能，存储在 <code>Session</code> 的持久化上下文中。</li><li><strong>缓存作用</strong>：<ul><li>同一 <code>Session</code> 内，重复查询相同实体（如 <code>get(User.class, id)</code>）直接从一级缓存返回。</li><li>脏检查依赖一级缓存，Hibernate 在 <code>flush()</code> 或事务提交时对比缓存中的实体状态。</li></ul></li><li><strong>管理方式</strong>：<ul><li>调用 <code>Session.clear()</code> 清空一级缓存。</li><li>调用 <code>Session.evict(Object)</code> 移除特定实体。</li><li><code>Session</code> 关闭时，一级缓存自动失效。</li></ul></li><li><strong>示例</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.openSession();</span><br><span class="line"><span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> session.beginTransaction();</span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> session.get(User.class, <span class="number">1L</span>); <span class="comment">// 查询数据库，放入一级缓存</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> session.get(User.class, <span class="number">1L</span>); <span class="comment">// 直接从一级缓存返回</span></span><br><span class="line">tx.commit();</span><br><span class="line">session.close(); <span class="comment">// 一级缓存失效</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="SessionFactory-和二级缓存"><a href="#SessionFactory-和二级缓存" class="headerlink" title="SessionFactory 和二级缓存"></a><strong>SessionFactory 和二级缓存</strong></h4><ul><li><strong>管理关系</strong>：二级缓存由 <code>SessionFactory</code> 管理，跨 <code>Session</code> 共享。<code>SessionFactory</code> 负责初始化缓存提供者（如 EHCache）并维护缓存区域。</li><li><strong>缓存访问</strong>：<ul><li>当 <code>Session</code> 查询实体时，Hibernate 先检查一级缓存，若未命中，再检查二级缓存（若启用）。</li><li>如果二级缓存命中，Hibernate 从缓存加载实体，减少数据库访问。</li></ul></li><li><strong>配置依赖</strong>：二级缓存的配置（如缓存策略、提供者）在 <code>SessionFactory</code> 初始化时设置，影响所有 <code>Session</code>。</li><li><strong>示例</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Session</span> <span class="variable">session1</span> <span class="operator">=</span> sessionFactory.openSession();</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> session1.get(User.class, <span class="number">1L</span>); <span class="comment">// 查询数据库，放入二级缓存</span></span><br><span class="line">session1.close();</span><br><span class="line"></span><br><span class="line"><span class="type">Session</span> <span class="variable">session2</span> <span class="operator">=</span> sessionFactory.openSession();</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> session2.get(User.class, <span class="number">1L</span>); <span class="comment">// 从二级缓存加载</span></span><br><span class="line">session2.close();</span><br></pre></td></tr></table></figure></li></ul><h4 id="Session、SessionFactory-和查询缓存"><a href="#Session、SessionFactory-和查询缓存" class="headerlink" title="Session、SessionFactory 和查询缓存"></a><strong>Session、SessionFactory 和查询缓存</strong></h4><ul><li><strong>协作机制</strong>：<ul><li>查询缓存存储查询结果的元数据（如实体 ID），由 <code>SessionFactory</code> 管理。</li><li>实际实体数据仍需从二级缓存或数据库加载。</li><li><code>Session</code> 通过 <code>setCacheable(true)</code> 启用查询缓存，查询结果与 <code>SessionFactory</code> 的缓存区域关联。</li></ul></li><li><strong>依赖关系</strong>：查询缓存依赖二级缓存，必须同时启用二级缓存才能生效。</li></ul><h4 id="整体工作流程"><a href="#整体工作流程" class="headerlink" title="整体工作流程"></a><strong>整体工作流程</strong></h4><ol><li><strong>初始化</strong>：<code>SessionFactory</code> 在应用启动时创建，加载配置、映射和缓存设置（包括二级缓存）。</li><li><strong>创建 Session</strong>：应用通过 <code>SessionFactory</code> 创建 <code>Session</code>，每个 <code>Session</code> 维护独立的一级缓存。</li><li><strong>查询操作</strong>：<ul><li><code>Session</code> 首先检查一级缓存。</li><li>如果一级缓存未命中，检查二级缓存（若启用）。</li><li>如果二级缓存未命中，查询数据库，并将结果存入一级缓存和二级缓存（若启用）。</li></ul></li><li><strong>事务提交</strong>：<ul><li><code>Session</code> 执行脏检查，同步一级缓存中的变化到数据库。</li><li>二级缓存根据策略（如 <code>READ_WRITE</code>）更新。</li></ul></li><li><strong>关闭</strong>：<code>Session</code> 关闭，一级缓存失效；<code>SessionFactory</code> 和二级缓存保持有效，直到应用关闭。</li></ol><hr><h3 id="5-实践中的注意事项"><a href="#5-实践中的注意事项" class="headerlink" title="5. 实践中的注意事项"></a><strong>5. 实践中的注意事项</strong></h3><ol><li><p><strong>Session 管理</strong>：</p><ul><li>避免长时间持有 <code>Session</code>，防止内存泄漏。</li><li>在 Spring 中，使用 <code>@Transactional</code> 自动管理 <code>Session</code>（通过 <code>getCurrentSession()</code>）。</li><li>总是关闭 <code>Session</code>（<code>close()</code>），或依赖 Spring 管理。</li></ul></li><li><p><strong>SessionFactory 配置</strong>：</p><ul><li>确保 <code>SessionFactory</code> 单例，避免重复创建。</li><li>合理配置数据库连接池（如 HikariCP）和 Hibernate 属性（如 <code>hibernate.dialect</code>）。</li></ul></li><li><p><strong>缓存优化</strong>：</p><ul><li><strong>一级缓存</strong>：避免在单一 <code>Session</code> 内加载过多实体，防止内存溢出。</li><li><strong>二级缓存</strong>：仅缓存不常修改的数据，配置合适的并发策略（如 <code>READ_ONLY</code> 或 <code>READ_WRITE</code>）。</li><li><strong>查询缓存</strong>：谨慎使用，适合高频、参数固定的查询。</li></ul></li><li><p><strong>性能调试</strong>：</p><ul><li>开启 <code>hibernate.show_sql</code> 和 <code>hibernate.format_sql</code> 查看生成的 SQL。</li><li>使用 <code>statistics</code> 检查缓存命中率：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sessionFactory.getStatistics().setStatisticsEnabled(<span class="literal">true</span>);</span><br><span class="line">System.out.println(sessionFactory.getStatistics().getSecondLevelCacheHitCount());</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>常见问题</strong>：</p><ul><li><strong>LazyInitializationException</strong>：因 <code>Session</code> 关闭后访问延迟加载的关联对象，解决方法是提前加载或使用 Spring 的 <code>OpenSessionInView</code>。</li><li><strong>N+1 查询问题</strong>：因一级缓存未命中或关联对象逐个加载，解决方法是使用 <code>JOIN FETCH</code> 或批量加载。</li></ul></li></ol><hr><h3 id="6-示例代码：展示-Session、SessionFactory-和缓存"><a href="#6-示例代码：展示-Session、SessionFactory-和缓存" class="headerlink" title="6. 示例代码：展示 Session、SessionFactory 和缓存"></a><strong>6. 示例代码：展示 Session、SessionFactory 和缓存</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置 SessionFactory</span></span><br><span class="line"><span class="type">Configuration</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>().configure();</span><br><span class="line">config.addAnnotatedClass(User.class);</span><br><span class="line"><span class="type">SessionFactory</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> config.buildSessionFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Session 和一级缓存</span></span><br><span class="line"><span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.openSession();</span><br><span class="line"><span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> session.beginTransaction();</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> session.get(User.class, <span class="number">1L</span>); <span class="comment">// 查询数据库，放入一级缓存</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> session.get(User.class, <span class="number">1L</span>); <span class="comment">// 从一级缓存返回</span></span><br><span class="line">System.out.println(user1 == user2); <span class="comment">// true，同一对象</span></span><br><span class="line"></span><br><span class="line">tx.commit();</span><br><span class="line">session.close(); <span class="comment">// 一级缓存失效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二级缓存示例（需配置 EHCache 和 @Cache）</span></span><br><span class="line"><span class="type">Session</span> <span class="variable">session2</span> <span class="operator">=</span> sessionFactory.openSession();</span><br><span class="line"><span class="type">Transaction</span> <span class="variable">tx2</span> <span class="operator">=</span> session2.beginTransaction();</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> session2.get(User.class, <span class="number">1L</span>); <span class="comment">// 从二级缓存加载（若命中）</span></span><br><span class="line">tx2.commit();</span><br><span class="line">session2.close();</span><br><span class="line"></span><br><span class="line">sessionFactory.close(); <span class="comment">// 关闭 SessionFactory，二级缓存失效</span></span><br></pre></td></tr></table></figure><hr><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a><strong>7. 总结</strong></h3><ul><li><strong>Session</strong>：<ul><li>作用：管理数据库操作和一级缓存，非线程安全，短生命周期。</li><li>核心方法：<code>save</code>、<code>get</code>、<code>createQuery</code>、<code>flush</code>。</li></ul></li><li><strong>SessionFactory</strong>：<ul><li>作用：创建 <code>Session</code>，管理全局配置和二级缓存，线程安全，单例。</li><li>核心方法：<code>openSession</code>、<code>getCurrentSession</code>。</li></ul></li><li><strong>缓存机制</strong>：<ul><li><strong>一级缓存</strong>：<code>Session</code> 级别，自动启用，存储当前会话实体，负责脏检查。</li><li><strong>二级缓存</strong>：<code>SessionFactory</code> 级别，可选启用，跨 <code>Session</code> 共享，适合只读数据。</li><li><strong>查询缓存</strong>：缓存查询结果，依赖二级缓存。</li></ul></li><li><strong>相关性</strong>：<ul><li><code>SessionFactory</code> 创建 <code>Session</code>，提供配置和二级缓存。</li><li><code>Session</code> 维护一级缓存，执行操作，可能访问二级缓存。</li><li>缓存机制通过减少数据库访问优化性能，与 <code>Session</code> 和 <code>SessionFactory</code> 的生命周期紧密相关。</li></ul></li></ul><hr><h3 id="进一步学习建议"><a href="#进一步学习建议" class="headerlink" title="进一步学习建议"></a><strong>进一步学习建议</strong></h3><ol><li><strong>实践</strong>：搭建一个 Spring Boot + Hibernate 项目，测试一级缓存和二级缓存的效果。</li><li><strong>调试</strong>：使用 Hibernate 的 <code>Statistics</code> API 监控缓存命中率，优化查询。</li><li><strong>深入</strong>：学习关联映射（如 <code>@OneToMany</code>）和 <code>fetch</code> 策略，结合缓存优化性能。</li><li><strong>资源</strong>：参考 <a href="https://docs.jboss.org/hibernate/orm/5.6/userguide/html_single/Hibernate_User_Guide.html#caching">Hibernate 官方文档</a> 的缓存章节。</li></ol><p>如果你有具体场景（如缓存配置、性能问题、代码调试），请提供细节，我可以进一步提供定制化指导！</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>要熟悉使用 Hibernate 作为 ORM 框架，建议从理解其核心概念开始，逐步通过实践掌握常用类、接口和方法。以下是一个系统化的学习路径，以及 Hibernate 中常用的类、接口和方法的详细说明，帮助你快速上手。</p><hr><h3 id="学习路径：如何入手-Hibernate"><a href="#学习路径：如何入手-Hibernate" class="headerlink" title="学习路径：如何入手 Hibernate"></a><strong>学习路径：如何入手 Hibernate</strong></h3><ol><li><p><strong>理解核心概念</strong></p><ul><li><strong>ORM 原理</strong>：了解对象-关系映射，Hibernate 如何将 Java 对象映射到数据库表。</li><li><strong>Session 和 SessionFactory</strong>：掌握 Hibernate 的核心工作单元。</li><li><strong>事务管理</strong>：理解事务在 Hibernate 中的作用。</li><li><strong>一级缓存和查询</strong>：学习 Hibernate 如何缓存对象和执行查询。</li></ul></li><li><p><strong>搭建开发环境</strong></p><ul><li><strong>依赖配置</strong>：使用 Maven 或 Gradle 引入 Hibernate 依赖（参考之前的回答）。</li><li><strong>数据库准备</strong>：选择一个数据库（如 MySQL、H2），创建表结构。</li><li><strong>Spring 集成</strong>：推荐结合 Spring（或 Spring Boot）简化配置，Spring Boot 的 <code>spring-boot-starter-data-jpa</code> 是快速入门的首选。</li></ul></li><li><p><strong>实践基础操作</strong></p><ul><li><strong>创建实体类</strong>：使用注解（如 <code>@Entity</code>、<code>@Id</code>）定义 Java 类与数据库表的映射。</li><li><strong>配置 Hibernate</strong>：设置 <code>hibernate.cfg.xml</code> 或 <code>application.properties</code>（Spring Boot）。</li><li><strong>实现 CRUD</strong>：通过 <code>Session</code> 或 JPA 的 <code>EntityManager</code> 实现增删改查。</li><li><strong>练习查询</strong>：使用 HQL（Hibernate Query Language）或 Criteria API 编写查询。</li></ul></li><li><p><strong>深入高级功能</strong></p><ul><li><strong>关联映射</strong>：学习 <code>@OneToMany</code>、<code>@ManyToOne</code> 等关联关系。</li><li><strong>延迟加载</strong>：理解 <code>fetch</code> 策略（如 <code>FetchType.LAZY</code>）。</li><li><strong>事务管理</strong>：结合 Spring 的 <code>@Transactional</code> 管理事务。</li><li><strong>性能优化</strong>：探索一级缓存、二级缓存、批量操作。</li></ul></li><li><p><strong>通过项目巩固</strong></p><ul><li>构建一个简单的应用（如用户管理系统），包含实体、DAO、服务层和控制器。</li><li>使用 Spring Boot + Hibernate 实现 REST API，涵盖 CRUD 和关联查询。</li><li>调试常见问题（如 <code>LazyInitializationException</code>、N+1 查询问题）。</li></ul></li><li><p><strong>查阅官方资源</strong></p><ul><li><strong>Hibernate 文档</strong>：参考 <a href="https://hibernate.org/orm/documentation/">Hibernate 官方文档</a>。</li><li><strong>教程和社区</strong>：学习 Baeldung、Mkyong 等网站的 Hibernate 教程，参与 Stack Overflow 讨论。</li><li><strong>源码和示例</strong>：查看 Hibernate 的 GitHub 仓库或官方示例项目。</li></ul></li></ol><hr><h3 id="常用类、接口和方法"><a href="#常用类、接口和方法" class="headerlink" title="常用类、接口和方法"></a><strong>常用类、接口和方法</strong></h3><p>以下是 Hibernate 中最常用的类、接口及其核心方法，分为 **Hibernate 核心（Session 模式）**和 <strong>JPA 模式</strong>（Spring Boot 常用）。</p><h4 id="1-Hibernate-核心（Session-模式）"><a href="#1-Hibernate-核心（Session-模式）" class="headerlink" title="1. Hibernate 核心（Session 模式）"></a><strong>1. Hibernate 核心（Session 模式）</strong></h4><p>这些类和接口用于传统的 Hibernate 操作，基于 <code>Session</code> 和 <code>SessionFactory</code>。</p><h5 id="常用类和接口"><a href="#常用类和接口" class="headerlink" title="常用类和接口"></a><strong>常用类和接口</strong></h5><ol><li><p><strong><code>org.hibernate.Session</code></strong></p><ul><li><strong>作用</strong>：核心接口，管理实体对象的持久化操作，维护一级缓存。</li><li><strong>非线程安全</strong>，每个线程应有独立的 <code>Session</code>。</li><li><strong>获取方式</strong>：通过 <code>SessionFactory.openSession()</code> 获取。</li></ul></li><li><p><strong><code>org.hibernate.SessionFactory</code></strong></p><ul><li><strong>作用</strong>：线程安全的工厂类，负责创建 <code>Session</code>，初始化 Hibernate 配置。</li><li><strong>特点</strong>：全局单例，创建开销大，应用启动时初始化。</li></ul></li><li><p><strong><code>org.hibernate.Transaction</code></strong></p><ul><li><strong>作用</strong>：管理数据库事务，确保操作的原子性。</li><li><strong>获取方式</strong>：通过 <code>Session.beginTransaction()</code> 获取。</li></ul></li><li><p><strong><code>org.hibernate.query.Query</code></strong></p><ul><li><strong>作用</strong>：执行 HQL 或 SQL 查询，返回结果集。</li><li><strong>获取方式</strong>：通过 <code>Session.createQuery()</code> 创建。</li></ul></li></ol><h5 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a><strong>常用方法</strong></h5><ul><li><p><strong><code>Session</code> 方法</strong>：</p><ul><li><code>save(Object)</code>：保存实体，返回标识符。</li><li><code>update(Object)</code>：更新实体。</li><li><code>merge(Object)</code>：合并 detached 状态的实体。</li><li><code>delete(Object)</code>：删除实体。</li><li><code>get(Class, Serializable)</code>：根据 ID 立即加载实体。</li><li><code>load(Class, Serializable)</code>：延迟加载实体。</li><li><code>createQuery(String)</code>：创建 HQL 查询。</li><li><code>flush()</code>：同步持久化上下文到数据库。</li><li><code>clear()</code>：清空一级缓存。</li><li><code>beginTransaction()</code>：开启事务。</li></ul></li><li><p><strong><code>SessionFactory</code> 方法</strong>：</p><ul><li><code>openSession()</code>：创建新的 <code>Session</code>。</li><li><code>getCurrentSession()</code>：获取当前线程绑定的 <code>Session</code>（需配置事务上下文）。</li><li><code>close()</code>：关闭工厂，释放资源。</li></ul></li><li><p><strong><code>Transaction</code> 方法</strong>：</p><ul><li><code>commit()</code>：提交事务。</li><li><code>rollback()</code>：回滚事务。</li></ul></li><li><p><strong><code>Query</code> 方法</strong>：</p><ul><li><code>getResultList()</code>：返回查询结果列表。</li><li><code>getSingleResult()</code>：返回单个结果。</li><li><code>setParameter(String, Object)</code>：设置查询参数。</li><li><code>setMaxResults(int)</code>：限制结果数量。</li></ul></li></ul><h5 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SessionFactory</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>().configure().buildSessionFactory();</span><br><span class="line"><span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.openSession();</span><br><span class="line"><span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    tx = session.beginTransaction();</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    session.save(user); <span class="comment">// 保存</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">loaded</span> <span class="operator">=</span> session.get(User.class, user.getId()); <span class="comment">// 查询</span></span><br><span class="line">    tx.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tx != <span class="literal">null</span>) tx.rollback();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-JPA-模式（EntityManager-模式）"><a href="#2-JPA-模式（EntityManager-模式）" class="headerlink" title="2. JPA 模式（EntityManager 模式）"></a><strong>2. JPA 模式（EntityManager 模式）</strong></h4><p>在 Spring Boot 或现代项目中，通常使用 Hibernate 作为 JPA 实现，基于 <code>EntityManager</code>。</p><h5 id="常用类和接口-1"><a href="#常用类和接口-1" class="headerlink" title="常用类和接口"></a><strong>常用类和接口</strong></h5><ol><li><p><strong><code>javax.persistence.EntityManager</code>（或 <code>jakarta.persistence</code>）</strong></p><ul><li><strong>作用</strong>：JPA 的核心接口，类似 <code>Session</code>，管理实体的持久化操作。</li><li><strong>获取方式</strong>：通过 Spring 注入或 <code>EntityManagerFactory</code> 创建。</li></ul></li><li><p><strong><code>javax.persistence.EntityManagerFactory</code></strong></p><ul><li><strong>作用</strong>：创建 <code>EntityManager</code>，类似 <code>SessionFactory</code>。</li><li><strong>特点</strong>：线程安全，全局单例。</li></ul></li><li><p><strong><code>javax.persistence.Query</code></strong></p><ul><li><strong>作用</strong>：执行 JPQL（类似 HQL）或原生 SQL 查询。</li><li><strong>获取方式</strong>：通过 <code>EntityManager.createQuery()</code> 创建。</li></ul></li><li><p><strong><code>javax.persistence.EntityTransaction</code></strong></p><ul><li><strong>作用</strong>：管理 JPA 事务。</li><li><strong>获取方式</strong>：通过 <code>EntityManager.getTransaction()</code> 获取。</li></ul></li></ol><h5 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a><strong>常用方法</strong></h5><ul><li><p><strong><code>EntityManager</code> 方法</strong>：</p><ul><li><code>persist(Object)</code>：将实体设为持久化状态。</li><li><code>merge(Object)</code>：合并 detached 状态的实体。</li><li><code>remove(Object)</code>：删除实体。</li><li><code>find(Class, Object)</code>：根据 ID 查找实体。</li><li><code>createQuery(String)</code>：创建 JPQL 查询。</li><li><code>createNativeQuery(String)</code>：创建原生 SQL 查询。</li><li><code>flush()</code>：同步持久化上下文。</li><li><code>detach(Object)</code>：将实体从持久化上下文中分离。</li><li><code>getTransaction()</code>：获取事务对象。</li></ul></li><li><p><strong><code>EntityManagerFactory</code> 方法</strong>：</p><ul><li><code>createEntityManager()</code>：创建 <code>EntityManager</code>。</li><li><code>close()</code>：关闭工厂。</li></ul></li><li><p><strong><code>Query</code> 方法</strong>：</p><ul><li>类似 <code>Session</code> 的 <code>Query</code> 方法，如 <code>getResultList()</code>、<code>setParameter()</code>。</li></ul></li></ul><h5 id="Spring-Boot-示例（JPA）"><a href="#Spring-Boot-示例（JPA）" class="headerlink" title="Spring Boot 示例（JPA）"></a><strong>Spring Boot 示例（JPA）</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// Getters and Setters</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRepository</span> &#123;</span><br><span class="line">    <span class="meta">@PersistenceContext</span></span><br><span class="line">    <span class="keyword">private</span> EntityManager entityManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        entityManager.persist(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> entityManager.find(User.class, id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-常用注解"><a href="#3-常用注解" class="headerlink" title="3. 常用注解"></a><strong>3. 常用注解</strong></h4><p>Hibernate 依赖注解定义实体和映射关系，常用注解包括：</p><ul><li><strong><code>@Entity</code></strong>：标记类为实体。</li><li><strong><code>@Table(name)</code></strong>：指定数据库表名。</li><li><strong><code>@Id</code></strong>：标记主键。</li><li><strong><code>@GeneratedValue</code></strong>：定义主键生成策略（如 <code>AUTO</code>、<code>IDENTITY</code>）。</li><li><strong><code>@Column</code></strong>：映射字段到列，指定属性（如 <code>nullable</code>、<code>length</code>）。</li><li><strong><code>@OneToMany</code> &#x2F; <code>@ManyToOne</code> &#x2F; <code>@ManyToMany</code></strong>：定义关联关系。</li><li><strong><code>@JoinColumn</code></strong>：指定外键列。</li><li><strong><code>@Fetch</code></strong>：设置加载策略（<code>FetchType.LAZY</code> 或 <code>EAGER</code>）。</li><li><strong><code>@Transactional</code></strong>（Spring）：管理事务。</li></ul><hr><h3 id="实践建议：掌握-Hibernate-的步骤"><a href="#实践建议：掌握-Hibernate-的步骤" class="headerlink" title="实践建议：掌握 Hibernate 的步骤"></a><strong>实践建议：掌握 Hibernate 的步骤</strong></h3><ol><li><p><strong>从简单实体开始</strong>：</p><ul><li>创建一个简单的实体类（如 <code>User</code>），使用 <code>@Entity</code>、<code>@Id</code> 等注解。</li><li>配置 <code>hibernate.cfg.xml</code> 或 Spring Boot 的 <code>application.properties</code>。</li><li>实现基本的 CRUD 操作，熟悉 <code>Session</code> 或 <code>EntityManager</code>。</li></ul></li><li><p><strong>学习 HQL 和 JPQL</strong>：</p><ul><li>编写简单的 HQL 查询（如 <code>from User where name = :name</code>）。</li><li>使用 <code>Query</code> 设置参数和分页。</li></ul></li><li><p><strong>探索关联映射</strong>：</p><ul><li>创建两个实体（如 <code>User</code> 和 <code>Order</code>），使用 <code>@OneToMany</code> 建立关系。</li><li>测试级联操作（如 <code>CascadeType.ALL</code>）和延迟加载。</li></ul></li><li><p><strong>集成 Spring</strong>：</p><ul><li>使用 Spring 的 <code>@Repository</code> 和 <code>@Transactional</code> 管理 <code>Session</code> 或 <code>EntityManager</code>。</li><li>尝试 Spring Data JPA，简化 DAO 层代码。</li></ul></li><li><p><strong>调试和优化</strong>：</p><ul><li>开启 <code>hibernate.show_sql</code> 和 <code>hibernate.format_sql</code> 查看生成的 SQL。</li><li>解决常见问题，如 <code>LazyInitializationException</code> 或 N+1 查询。</li><li>学习使用 <code>@BatchSize</code> 或二级缓存优化性能。</li></ul></li></ol><hr><h3 id="推荐练习项目"><a href="#推荐练习项目" class="headerlink" title="推荐练习项目"></a><strong>推荐练习项目</strong></h3><ol><li><p><strong>用户管理系统</strong>：</p><ul><li>实体：<code>User</code>（ID、姓名、邮箱）、<code>Role</code>（ID、名称）。</li><li>功能：用户增删改查、角色分配（多对多关系）。</li><li>技术：Spring Boot + Hibernate + MySQL。</li></ul></li><li><p><strong>博客系统</strong>：</p><ul><li>实体：<code>Post</code>（ID、标题、内容）、<code>Comment</code>（ID、内容、Post）。</li><li>功能：发布帖子、添加评论（一对多关系）。</li><li>技术：Spring Boot + JPA + H2 数据库。</li></ul></li></ol><hr><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ul><li><strong>版本兼容</strong>：确保 Hibernate、Spring 和数据库驱动版本兼容（如 Hibernate 5.x 搭配 Spring 5.x）。</li><li><strong>事务管理</strong>：始终在事务中执行写操作，避免非事务性错误。</li><li><strong>资源释放</strong>：手动管理 <code>Session</code> 时，确保关闭（Spring 自动管理）。</li><li><strong>性能监控</strong>：关注生成的 SQL，避免 N+1 查询问题。</li></ul><hr><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><strong>入手方式</strong>：从配置环境、创建简单实体开始，逐步学习 CRUD、HQL 和关联映射，结合 Spring 实践。</li><li><strong>核心类&#x2F;接口</strong>：<code>Session</code>、<code>SessionFactory</code>（Hibernate 模式）或 <code>EntityManager</code>、<code>EntityManagerFactory</code>（JPA 模式）。</li><li><strong>核心方法</strong>：<code>save</code>、<code>get</code>、<code>createQuery</code>（Session）或 <code>persist</code>、<code>find</code>、<code>createQuery</code>（EntityManager）。</li><li><strong>实践重点</strong>：搭建小项目，熟悉注解、查询和事务管理。</li></ul><p>如果你有具体问题（如配置示例、某个方法的用法、调试错误），请提供更多细节，我可以进一步指导！</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Hibernate </tag>
            
            <tag> ORM </tag>
            
            <tag> JPA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka 深度学习笔记</title>
      <link href="/posts/1562.html"/>
      <url>/posts/1562.html</url>
      
        <content type="html"><![CDATA[<h2 id="📖-简介"><a href="#📖-简介" class="headerlink" title="📖 简介"></a>📖 简介</h2><p>Apache Kafka 是一个分布式流处理平台,最初由 LinkedIn 开发。早期版本使用 Scala 编写并运行在 JVM 上,后续版本逐渐迁移至 Java 实现。</p><h2 id="🔑-核心概念"><a href="#🔑-核心概念" class="headerlink" title="🔑 核心概念"></a>🔑 核心概念</h2><h3 id="副本机制"><a href="#副本机制" class="headerlink" title="副本机制"></a>副本机制</h3><ul><li><p><strong>Leader Replica（主副本）</strong></p><ul><li>负责处理所有客户端的读写请求</li><li>维护消息的写入顺序和偏移量等元数据</li></ul></li><li><p><strong>Follower Replica（从副本）</strong></p><ul><li>从 Leader 同步最新数据</li><li>提供数据冗余和高可用保障</li><li>不对外提供读写服务</li></ul></li></ul><h3 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h3><p>Kafka 使用高效的日志存储机制来持久化消息：</p><ul><li><p><strong>顺序 I&#x2F;O 追加写入</strong></p><ul><li>消息以追加方式顺序写入日志文件</li><li>充分利用磁盘顺序读写的高性能特性</li></ul></li><li><p><strong>Log Segment 分段管理</strong></p><ul><li>将日志按照 Log Segment 进行分段</li><li>定时清理过期的 Segment 来释放磁盘空间</li></ul></li></ul><hr><h2 id="📚-核心术语"><a href="#📚-核心术语" class="headerlink" title="📚 核心术语"></a>📚 核心术语</h2><table><thead><tr><th>术语</th><th>英文</th><th>说明</th></tr></thead><tbody><tr><td><strong>消息</strong></td><td>Record</td><td>Kafka 处理的主要对象</td></tr><tr><td><strong>主题</strong></td><td>Topic</td><td>承载消息的逻辑容器，用于区分不同的业务</td></tr><tr><td><strong>分区</strong></td><td>Partition</td><td>一个有序不变的消息序列，每个主题可以有多个分区</td></tr><tr><td><strong>消息位移</strong></td><td>Offset</td><td>分区中每条消息的位置信息，单调递增且不变</td></tr><tr><td><strong>副本</strong></td><td>Replica</td><td>消息的多个拷贝，分为 Leader 和 Follower 副本</td></tr><tr><td><strong>生产者</strong></td><td>Producer</td><td>向主题发布新消息的应用程序</td></tr><tr><td><strong>消费者</strong></td><td>Consumer</td><td>从主题订阅消息的应用程序</td></tr><tr><td><strong>消费者位移</strong></td><td>Consumer Offset</td><td>表征消费者消费进度</td></tr><tr><td><strong>消费者组</strong></td><td>Consumer Group</td><td>多个消费者实例组成的组，同时消费多个分区以实现高吞吐</td></tr><tr><td><strong>重平衡</strong></td><td>Rebalance</td><td>消费者组内某个实例挂掉后，其他实例自动重新分配订阅分区的过程</td></tr></tbody></table><h3 id="高级概念"><a href="#高级概念" class="headerlink" title="高级概念"></a>高级概念</h3><ul><li><p><strong>刷盘（Flush）</strong></p><ul><li>将内存中的数据持久化到磁盘的过程</li><li>消息先写入内存缓冲区，再根据策略刷写到磁盘</li><li>保证数据持久性，即使服务器重启也不会丢失</li></ul></li><li><p><strong>副本因子（Replication Factor）</strong></p><ul><li>定义每个分区有多少个副本</li><li>例如副本因子为 3，意味着 1 个 Leader + 2 个 Follower</li></ul></li><li><p><strong>Purgatory（炼狱）</strong></p><ul><li>用于处理延迟操作的内部机制</li><li>处理不能立即完成，需要等待条件满足的操作</li><li>例如事务相关操作</li></ul></li></ul><hr><h2 id="🚀-部署配置"><a href="#🚀-部署配置" class="headerlink" title="🚀 部署配置"></a>🚀 部署配置</h2><h3 id="Broker-参数配置"><a href="#Broker-参数配置" class="headerlink" title="Broker 参数配置"></a>Broker 参数配置</h3><h4 id="存储配置"><a href="#存储配置" class="headerlink" title="存储配置"></a>存储配置</h4><p><strong><code>log.dirs</code></strong>（推荐）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">log.dirs</span>=<span class="string">/home/kafka/data1,/home/kafka/data2,/home/kafka/data3</span></span><br></pre></td></tr></table></figure><ul><li>建议将各个目录挂载到不同的物理磁盘</li><li><strong>优势</strong>：提升读写性能 + 实现故障转移</li></ul><p><strong><code>log.dir</code></strong></p><ul><li>单个路径配置，补充 <code>log.dirs</code> 使用</li></ul><h4 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h4><p><strong><code>listeners</code></strong></p><ul><li>告诉外部连接者使用什么协议连接</li><li>格式：<code>&lt;protocol&gt;://&lt;host&gt;:&lt;port&gt;</code></li><li>示例：<code>PLAINTEXT://localhost:9092</code></li></ul><p><strong><code>advertised.listeners</code></strong></p><ul><li>Broker 对外发布的监听器地址</li><li>客户端实际连接的地址</li></ul><p><strong>自定义协议配置</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">listeners</span>=<span class="string">CONTROLLER://localhost:9992</span></span><br><span class="line"><span class="attr">listener.security.protocol.map</span>=<span class="string">CONTROLLER:PLAINTEXT</span></span><br></pre></td></tr></table></figure><h4 id="Topic-管理"><a href="#Topic-管理" class="headerlink" title="Topic 管理"></a>Topic 管理</h4><table><thead><tr><th>参数</th><th>推荐值</th><th>说明</th></tr></thead><tbody><tr><td><code>auto.create.topics.enable</code></td><td><strong>false</strong></td><td>禁止自动创建 Topic，避免线上未知问题</td></tr><tr><td><code>unclean.leader.election.enable</code></td><td><strong>false</strong></td><td>禁止不干净的 Leader 选举，防止数据丢失</td></tr><tr><td><code>auto.leader.rebalance.enable</code></td><td><strong>false</strong></td><td>禁止定期 Leader 选举，避免频繁切换</td></tr></tbody></table><h4 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h4><p><strong>消息保留时间</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">log.retention.hours</span>=<span class="string">168    # 7天</span></span><br><span class="line"><span class="attr">log.retention.minutes</span>=<span class="string">10080</span></span><br><span class="line"><span class="attr">log.retention.ms</span>=<span class="string">604800000  # 优先级最高</span></span><br></pre></td></tr></table></figure><p><strong>消息大小限制</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">message.max.bytes</span>=<span class="string">1048576   # 1MB</span></span><br><span class="line"><span class="attr">log.retention.bytes</span>=<span class="string">-1      # 无限制</span></span><br></pre></td></tr></table></figure><h3 id="Topic-级别参数"><a href="#Topic-级别参数" class="headerlink" title="Topic 级别参数"></a>Topic 级别参数</h3><p>Topic 参数优先级高于 Broker 全局参数：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 消息保留时间</span></span><br><span class="line"><span class="attr">retention.ms</span>=<span class="string">604800000  # 7天</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 磁盘空间配额</span></span><br><span class="line"><span class="attr">retention.bytes</span>=<span class="string">-1      # 无限制</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 最大消息大小</span></span><br><span class="line"><span class="attr">max.message.bytes</span>=<span class="string">1048576</span></span><br></pre></td></tr></table></figure><h3 id="JVM-参数调优"><a href="#JVM-参数调优" class="headerlink" title="JVM 参数调优"></a>JVM 参数调优</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 堆内存配置（推荐 6GB）</span></span><br><span class="line"><span class="built_in">export</span> KAFKA_HEAP_OPTS=<span class="string">&quot;-Xms6g -Xmx6g&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># GC 配置</span></span><br><span class="line"><span class="built_in">export</span> KAFKA_JVM_PERFORMANCE_OPTS=<span class="string">&quot;-XX:+UseG1GC -XX:MaxGCPauseMillis=20&quot;</span></span><br></pre></td></tr></table></figure><hr><h2 id="🎯-分区策略"><a href="#🎯-分区策略" class="headerlink" title="🎯 分区策略"></a>🎯 分区策略</h2><p>决定生产者将消息发送到哪个分区的算法。</p><h3 id="自定义分区策略"><a href="#自定义分区策略" class="headerlink" title="自定义分区策略"></a>自定义分区策略</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 Partitioner 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomPartitioner</span> <span class="keyword">implements</span> <span class="title class_">org</span>.apache.kafka.clients.producer.Partitioner &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(String topic, Object key, <span class="type">byte</span>[] keyBytes, </span></span><br><span class="line"><span class="params">                        Object value, <span class="type">byte</span>[] valueBytes, Cluster cluster)</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义分区逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置参数：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">partitioner.class</span>=<span class="string">com.example.CustomPartitioner</span></span><br></pre></td></tr></table></figure><h3 id="内置分区策略"><a href="#内置分区策略" class="headerlink" title="内置分区策略"></a>内置分区策略</h3><h4 id="1-轮询策略（Round-Robin）"><a href="#1-轮询策略（Round-Robin）" class="headerlink" title="1. 轮询策略（Round-Robin）"></a>1. 轮询策略（Round-Robin）</h4><p><strong>特点</strong>：</p><ul><li>Kafka 默认策略</li><li>消息均匀分配到所有分区</li><li>最佳负载均衡表现</li></ul><p><strong>适用场景</strong>：</p><ul><li>无需保证消息顺序</li><li>追求负载均衡</li></ul><h4 id="2-随机策略（Random）"><a href="#2-随机策略（Random）" class="headerlink" title="2. 随机策略（Random）"></a>2. 随机策略（Random）</h4><p><strong>特点</strong>：</p><ul><li>随机选择分区</li><li>理论上也能实现负载均衡</li><li>但效果不如轮询策略</li></ul><h4 id="3-按键保序策略（Key-Ordering）"><a href="#3-按键保序策略（Key-Ordering）" class="headerlink" title="3. 按键保序策略（Key-Ordering）"></a>3. 按键保序策略（Key-Ordering）</h4><p><strong>特点</strong>：</p><ul><li>相同 Key 的消息进入同一分区</li><li>保证相同 Key 的消息顺序</li></ul><p><strong>实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line"><span class="keyword">return</span> Math.abs(key.hashCode()) % partitions.size();</span><br></pre></td></tr></table></figure><p><strong>适用场景</strong>：</p><ul><li>需要保证相同 Key 的消息顺序</li><li>例如：同一用户的操作日志</li></ul><hr><h2 id="🎮-Kafka-控制器"><a href="#🎮-Kafka-控制器" class="headerlink" title="🎮 Kafka 控制器"></a>🎮 Kafka 控制器</h2><h3 id="角色定位"><a href="#角色定位" class="headerlink" title="角色定位"></a>角色定位</h3><p>Kafka 集群中只能有<strong>一台 Broker</strong> 充当控制器（Controller）角色。</p><h3 id="主要职责"><a href="#主要职责" class="headerlink" title="主要职责"></a>主要职责</h3><h4 id="1-分区分配"><a href="#1-分区分配" class="headerlink" title="1. 分区分配"></a>1. 分区分配</h4><p>控制器负责决定每个分区的副本分布：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：Topic 有 2 个分区，副本因子为 2</span><br><span class="line">- 分区1: Leader→Broker1, Follower→Broker2</span><br><span class="line">- 分区2: Leader→Broker2, Follower→Broker1</span><br></pre></td></tr></table></figure><h4 id="2-Leader-副本选举"><a href="#2-Leader-副本选举" class="headerlink" title="2. Leader 副本选举"></a>2. Leader 副本选举</h4><ul><li>当 Leader 副本所在 Broker 宕机时</li><li>控制器从 ISR（In-Sync Replicas）中选举新的 Leader</li></ul><h4 id="3-主题管理"><a href="#3-主题管理" class="headerlink" title="3. 主题管理"></a>3. 主题管理</h4><ul><li>接受来自管理工具或 API 的请求</li><li>处理主题的创建和删除操作</li></ul><h4 id="4-集群监控与协调"><a href="#4-集群监控与协调" class="headerlink" title="4. 集群监控与协调"></a>4. 集群监控与协调</h4><ul><li>通过心跳机制检测 Broker 存活状态</li><li>节点失联时重新分配分区和副本</li></ul><h3 id="控制器选举"><a href="#控制器选举" class="headerlink" title="控制器选举"></a>控制器选举</h3><p><strong>选举机制</strong>：</p><ol><li>Broker 启动时尝试在 ZooKeeper 中创建 <code>/controller</code> 节点</li><li>第一个成功创建节点的 Broker 成为控制器</li><li>其他 Broker 通过 Watch 机制监控控制器状态</li></ol><p><strong>Failover 机制</strong>：</p><ul><li>ZooKeeper 检测到控制器节点失效</li><li>删除 <code>/controller</code> 节点</li><li>存活的 Broker 重新竞选新的控制器</li></ul><hr><h2 id="🔒-消息交付可靠性"><a href="#🔒-消息交付可靠性" class="headerlink" title="🔒 消息交付可靠性"></a>🔒 消息交付可靠性</h2><p>Kafka 提供三种消息交付可靠性保障：</p><h3 id="1-最多一次（At-Most-Once）"><a href="#1-最多一次（At-Most-Once）" class="headerlink" title="1. 最多一次（At Most Once）"></a>1. 最多一次（At Most Once）</h3><ul><li><strong>特征</strong>：消息可能丢失，但绝不重复</li><li><strong>场景</strong>：日志收集等对数据完整性要求不高的场景</li></ul><h3 id="2-至少一次（At-Least-Once）"><a href="#2-至少一次（At-Least-Once）" class="headerlink" title="2. 至少一次（At Least Once）"></a>2. 至少一次（At Least Once）</h3><ul><li><strong>特征</strong>：消息不会丢失，但可能重复</li><li><strong>默认</strong>：Kafka 默认提供此级别保障</li><li><strong>场景</strong>：大多数业务场景</li></ul><h3 id="3-精确一次（Exactly-Once）"><a href="#3-精确一次（Exactly-Once）" class="headerlink" title="3. 精确一次（Exactly Once）"></a>3. 精确一次（Exactly Once）</h3><ul><li><strong>特征</strong>：消息不丢失也不重复</li><li><strong>实现</strong>：通过幂等性 + 事务机制</li><li><strong>场景</strong>：金融交易等对数据准确性要求极高的场景</li></ul><hr><h2 id="❓-常见问题"><a href="#❓-常见问题" class="headerlink" title="❓ 常见问题"></a>❓ 常见问题</h2><h3 id="Q1-为什么-Kafka-不允许从副本读取数据？"><a href="#Q1-为什么-Kafka-不允许从副本读取数据？" class="headerlink" title="Q1: 为什么 Kafka 不允许从副本读取数据？"></a>Q1: 为什么 Kafka 不允许从副本读取数据？</h3><p>与 MySQL 主从复制不同，Kafka 的从副本不对外提供读服务。原因如下：</p><h4 id="1-一致性模型差异"><a href="#1-一致性模型差异" class="headerlink" title="1. 一致性模型差异"></a>1. 一致性模型差异</h4><p><strong>Kafka</strong>：</p><ul><li>基于日志的消息传递模型</li><li>强调消息顺序和实时性</li><li>从副本可能存在同步延迟，导致数据不一致</li></ul><p><strong>MySQL</strong>：</p><ul><li>ACID 事务模型</li><li>从库应用完 Binlog 后数据一致</li><li>可以安全地提供读服务</li></ul><h4 id="2-设计目标不同"><a href="#2-设计目标不同" class="headerlink" title="2. 设计目标不同"></a>2. 设计目标不同</h4><p><strong>Kafka</strong>：</p><ul><li>专注于高吞吐量的消息写入和顺序读取</li><li>允许从副本读取会增加复杂性</li></ul><p><strong>MySQL</strong>：</p><ul><li>支持复杂查询和事务处理</li><li>读写分离可以分担主库压力</li></ul><h4 id="3-故障恢复复杂性"><a href="#3-故障恢复复杂性" class="headerlink" title="3. 故障恢复复杂性"></a>3. 故障恢复复杂性</h4><p><strong>Kafka</strong>：</p><ul><li>从副本提供读服务时，故障切换更复杂</li><li>需要处理正在进行的读操作</li></ul><p><strong>MySQL</strong>：</p><ul><li>从库故障恢复相对简单</li><li>重新同步 Binlog 即可</li></ul><h3 id="Q2-Kafka-如何保证消息顺序性？"><a href="#Q2-Kafka-如何保证消息顺序性？" class="headerlink" title="Q2: Kafka 如何保证消息顺序性？"></a>Q2: Kafka 如何保证消息顺序性？</h3><h4 id="1-分区有序"><a href="#1-分区有序" class="headerlink" title="1. 分区有序"></a>1. 分区有序</h4><ul><li>每个分区内的消息严格有序</li><li>全局有序需要使用单分区（牺牲并发性）</li></ul><h4 id="2-同步发送"><a href="#2-同步发送" class="headerlink" title="2. 同步发送"></a>2. 同步发送</h4><p>配置 <code>acks=all</code> 保证消息持久性：</p><table><thead><tr><th>acks 值</th><th>说明</th><th>可靠性</th><th>性能</th></tr></thead><tbody><tr><td><strong>0</strong></td><td>不等待确认，立即返回</td><td>❌ 最低</td><td>✅ 最高</td></tr><tr><td><strong>1</strong></td><td>等待 Leader 确认</td><td>⚠️ 中等</td><td>⚠️ 中等</td></tr><tr><td><strong>all</strong></td><td>等待所有 ISR 确认</td><td>✅ 最高</td><td>❌ 最低</td></tr></tbody></table><h4 id="3-消息偏移量"><a href="#3-消息偏移量" class="headerlink" title="3. 消息偏移量"></a>3. 消息偏移量</h4><ul><li>每个消息有唯一的 Offset</li><li>消费者按 Offset 顺序消费</li><li>保证消费顺序与生产顺序一致</li></ul><h3 id="Q3-Kafka-消息如何存储？"><a href="#Q3-Kafka-消息如何存储？" class="headerlink" title="Q3: Kafka 消息如何存储？"></a>Q3: Kafka 消息如何存储？</h3><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Topic</span><br><span class="line">└── Partition</span><br><span class="line">    └── Log Segment</span><br><span class="line">        ├── .log    # 消息数据</span><br><span class="line">        └── .index  # 索引文件</span><br></pre></td></tr></table></figure><h4 id="存储特性"><a href="#存储特性" class="headerlink" title="存储特性"></a>存储特性</h4><ul><li><strong>格式</strong>：优化的日志格式</li><li><strong>不可变</strong>：消息一旦写入不可修改</li><li><strong>顺序追加</strong>：新消息追加到日志末尾</li><li><strong>分段管理</strong>：Log Segment 便于管理和清理</li></ul><hr><h2 id="💡-生产环境最佳实践"><a href="#💡-生产环境最佳实践" class="headerlink" title="💡 生产环境最佳实践"></a>💡 生产环境最佳实践</h2><h3 id="关键参数配置"><a href="#关键参数配置" class="headerlink" title="关键参数配置"></a>关键参数配置</h3><h4 id="auto-create-topics-enable-false"><a href="#auto-create-topics-enable-false" class="headerlink" title="auto.create.topics.enable &#x3D; false"></a>auto.create.topics.enable &#x3D; false</h4><p><strong>理由</strong>：</p><ul><li>避免因拼写错误自动创建 Topic</li><li>例如：<code>test</code> 误写为 <code>tst</code>，会自动创建 <code>tst</code> Topic</li><li>大公司应由运维统一管理 Topic</li></ul><h4 id="unclean-leader-election-enable-false"><a href="#unclean-leader-election-enable-false" class="headerlink" title="unclean.leader.election.enable &#x3D; false"></a>unclean.leader.election.enable &#x3D; false</h4><p><strong>场景</strong>：所有高质量副本都挂掉了，怎么办？</p><p><strong>选择</strong>：</p><ul><li><code>false</code>：坚持原则，分区不可用（保证数据完整性）</li><li><code>true</code>：降级服务，允许落后副本成为 Leader（可能丢数据）</li></ul><p><strong>推荐</strong>：生产环境设置为 <code>false</code></p><h4 id="auto-leader-rebalance-enable-false"><a href="#auto-leader-rebalance-enable-false" class="headerlink" title="auto.leader.rebalance.enable &#x3D; false"></a>auto.leader.rebalance.enable &#x3D; false</h4><p><strong>问题</strong>：定期换 Leader 的代价很高</p><ul><li>所有客户端需要切换连接</li><li>没有实质性能收益</li><li>可能影响服务稳定性</li></ul><p><strong>推荐</strong>：生产环境设置为 <code>false</code></p><hr><h2 id="📚-参考资料"><a href="#📚-参考资料" class="headerlink" title="📚 参考资料"></a>📚 参考资料</h2><ul><li><a href="https://kafka.apache.org/documentation/">Apache Kafka 官方文档</a></li><li><a href="https://www.confluent.io/resources/kafka-the-definitive-guide/">Kafka: The Definitive Guide</a></li><li><a href="https://time.geekbang.org/column/intro/100029201">Kafka 核心技术与实战</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP 事务失效与底层代理机制深度总结</title>
      <link href="/posts/60441.html"/>
      <url>/posts/60441.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-AOP-事务失效与底层代理机制深度总结"><a href="#Spring-AOP-事务失效与底层代理机制深度总结" class="headerlink" title="Spring AOP 事务失效与底层代理机制深度总结"></a>Spring AOP 事务失效与底层代理机制深度总结</h1><h2 id="1-核心问题：为什么自调用导致事务失效？"><a href="#1-核心问题：为什么自调用导致事务失效？" class="headerlink" title="1. 核心问题：为什么自调用导致事务失效？"></a>1. 核心问题：为什么自调用导致事务失效？</h2><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>在同一个类中，方法 A 调用方法 B（<code>this.methodB()</code>），即使方法 B 上加了 <code>@Transactional</code> 注解，事务依然不生效。</p><h3 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h3><p>Spring AOP 的默认实现基于 <strong>代理模式 (Proxy Pattern)</strong>。Spring 容器中注入的 Bean 实际上是一个 <strong>代理对象 (Proxy)</strong>，它持有你编写的 <strong>目标对象 (Target)</strong>。</p><ul><li><strong>生效路径</strong>：外部调用 $\rightarrow$ Proxy $\rightarrow$ 事务拦截器 (Interceptor) $\rightarrow$ Target。</li><li><strong>失效路径</strong>：Target 内部调用 $\rightarrow$ <code>this.methodB()</code> $\rightarrow$ Target。</li></ul><p>此时，<code>this</code> 指针指向的是<strong>目标对象本身</strong>。代码执行流直接在目标对象内部流转，完全<strong>绕过</strong>了外层的代理对象及其持有的事务拦截器。</p><h3 id="形象比喻"><a href="#形象比喻" class="headerlink" title="形象比喻"></a>形象比喻</h3><ul><li><strong>Proxy (代理)</strong>：大楼门口的<strong>安检员</strong>。</li><li><strong>Target (目标)</strong>：大楼里的<strong>员工</strong>。</li><li><strong>外部访问</strong>：访客找员工，必须经过安检（事务生效）。</li><li><strong>内部自调用</strong>：员工之间互找，直接在楼里见面，不需要跑出去再过一次安检（事务失效）。</li></ul><hr><h2 id="2-解决方案-按架构师推荐度排序"><a href="#2-解决方案-按架构师推荐度排序" class="headerlink" title="2. 解决方案 (按架构师推荐度排序)"></a>2. 解决方案 (按架构师推荐度排序)</h2><table><thead><tr><th><strong>方案</strong></th><th><strong>具体做法</strong></th><th><strong>评价</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>1. 架构重构 (Refactoring)</strong></td><td>将需要事务的方法提取到<strong>独立的 Service</strong> 中，通过 Bean 注入调用。</td><td>⭐⭐⭐⭐⭐ (强烈推荐)</td><td>符合单一职责原则 (SRP)，代码结构最清晰。</td></tr><tr><td><strong>2. 自我注入 (Self-Injection)</strong></td><td>在类中注入自身 (<code>@Lazy</code> 解决循环依赖)，调用 <code>self.methodB()</code>。</td><td>⭐⭐⭐ (可用)</td><td>业务逻辑紧密耦合，不适合拆分文件时。</td></tr><tr><td><strong>3. AopContext</strong></td><td>使用 <code>AopContext.currentProxy()</code> 强转获取当前代理对象。</td><td>⭐ (不推荐)</td><td>代码侵入性强，与 Spring API 强耦合。</td></tr><tr><td><strong>4. AspectJ</strong></td><td>放弃代理模式，使用字节码织入 (Weaving)。</td><td>N&#x2F;A (特殊需求)</td><td>追求极致性能或必须在 private&#x2F;自调用中生效时。</td></tr></tbody></table><hr><h2 id="3-深度辨析：JDK-动态代理-vs-CGLIB"><a href="#3-深度辨析：JDK-动态代理-vs-CGLIB" class="headerlink" title="3. 深度辨析：JDK 动态代理 vs CGLIB"></a>3. 深度辨析：JDK 动态代理 vs CGLIB</h2><p><img src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/SpringAOP.webp" alt="SpringAOP"></p><h3 id="常见误区"><a href="#常见误区" class="headerlink" title="常见误区"></a>常见误区</h3><blockquote><p><strong>误区</strong>：”JDK Proxy 会导致自调用失效，换成 CGLIB 就能解决了。”</p><p><strong>真相</strong>：<strong>错误的。</strong> 无论是 JDK Proxy 还是 CGLIB，只要是基于<strong>代理模式</strong>，自调用都会失效。因为它们底层架构都是 <code>Proxy</code> 持有 <code>Target</code>。</p></blockquote><h3 id="技术对比表"><a href="#技术对比表" class="headerlink" title="技术对比表"></a>技术对比表</h3><table><thead><tr><th><strong>维度</strong></th><th><strong>JDK 动态代理</strong></th><th><strong>CGLIB (Code Generation Library)</strong></th></tr></thead><tbody><tr><td><strong>实现机制</strong></td><td>基于 <strong>接口 (Interface)</strong></td><td>基于 <strong>继承 (Subclass)</strong></td></tr><tr><td><strong>类关系</strong></td><td>代理类与目标类是 <strong>兄弟关系</strong></td><td>代理类是目标类的 <strong>子类</strong></td></tr><tr><td><strong>核心限制</strong></td><td>目标类 <strong>必须实现接口</strong></td><td>目标类或方法 <strong>不能是 Final</strong></td></tr><tr><td><strong>调用方式</strong></td><td><strong>反射</strong> (<code>Method.invoke</code>)</td><td><strong>FastClass 索引</strong> (直接调用)</td></tr><tr><td><strong>自调用支持</strong></td><td>❌ 不支持</td><td>❌ 不支持</td></tr><tr><td><strong>Spring 默认</strong></td><td>旧版本 (有接口时默认)</td><td><strong>Spring Boot 2.0+ 默认</strong></td></tr></tbody></table><hr><h2 id="4-性能黑科技：CGLIB-的-FastClass-机制"><a href="#4-性能黑科技：CGLIB-的-FastClass-机制" class="headerlink" title="4. 性能黑科技：CGLIB 的 FastClass 机制"></a>4. 性能黑科技：CGLIB 的 FastClass 机制</h2><p>CGLIB 在运行时之所以高效，是因为它通过 <strong>FastClass</strong> 机制规避了 Java 反射 API 的开销。</p><h3 id="FastClass-原理"><a href="#FastClass-原理" class="headerlink" title="FastClass 原理"></a>FastClass 原理</h3><p>CGLIB 在生成代理类时，会利用 ASM 字节码技术额外生成一个 <code>FastClass</code>。它相当于把”反射查找”变成了”硬编码的索引跳转”。</p><p><strong>伪代码逻辑：</strong></p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// FastClass 就像一个巨大的 switch-case，建立了 方法签名 -&gt; 索引 的映射</span><br><span class="line">public Object invoke(int index, Object target, Object[] args) &#123;</span><br><span class="line">    MyService service = (MyService) target;</span><br><span class="line">    // 直接调用，没有反射的 invoke() 开销</span><br><span class="line">    switch (index) &#123;</span><br><span class="line">        case 1: return service.login(); </span><br><span class="line">        case 2: return service.logout();</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-FastClass"><a href="#总结-FastClass" class="headerlink" title="总结 FastClass"></a>总结 FastClass</h3><ul><li><strong>本质</strong>：<strong>空间换时间</strong>。通过生成更多的字节码类，建立索引。</li><li><strong>优势</strong>：<strong>运行时 (Runtime)</strong> 调用速度极快，接近原生 Java 方法调用，不仅省去了反射的安全检查，还能享受 JVM 的内联优化。</li><li><strong>劣势</strong>：<strong>启动时间</strong>稍慢（需要生成和加载字节码）。</li></ul><hr><h2 id="5-架构师建议-“The-Spring-Way”"><a href="#5-架构师建议-“The-Spring-Way”" class="headerlink" title="5. 架构师建议 (“The Spring Way”)"></a>5. 架构师建议 (“The Spring Way”)</h2><ol><li><strong>首选重构</strong>：遇到自调用失效，首先反思类的职责是否过重。将事务逻辑拆分到不同 Service 是最优雅的解法。</li><li><strong>拥抱 CGLIB</strong>：在 Spring Boot 2.x&#x2F;3.x 时代，默认使用 CGLIB 是最佳实践（稳定、高效、无需接口），除非你有特殊的 JDK 原生洁癖。</li><li><strong>避坑 Final</strong>：使用 Spring 管理的 Bean（尤其是涉及 AOP&#x2F;事务的），<strong>严禁</strong>将类或方法设为 <code>final</code>，否则 CGLIB 无法生成子类代理，会导致启动报错或 AOP 失效。</li><li><strong>理解原理</strong>：不要盲目背诵“CGLIB 比 JDK 快”，要理解它是通过“启动时的复杂”换取了“运行时的简单”。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java </tag>
            
            <tag> AOP </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

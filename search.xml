<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL 日志系统</title>
      <link href="/posts/356a30bc.html"/>
      <url>/posts/356a30bc.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h1><p><img src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/MySQL_RedoLog.webp" alt="img"></p><p>这张图被一条中间的虚线分为左右两部分，代表了计算机系统中两种截然不同的存储介质属性。</p><h2 id="1-左侧区域：IN-MEMORY-内存区域-Volatile-易失性"><a href="#1-左侧区域：IN-MEMORY-内存区域-Volatile-易失性" class="headerlink" title="1. 左侧区域：IN-MEMORY (内存区域) - Volatile (易失性)"></a>1. 左侧区域：IN-MEMORY (内存区域) - Volatile (易失性)</h2><ul><li><p><strong>特点：</strong></p><ul><li><strong>速度极快：</strong> CPU 对内存的读写速度远远高于磁盘。为了高性能，数据库必须尽可能在内存中处理数据。</li><li><strong>易失性 (Volatile)：</strong> 这是最大的弱点。一旦断电、系统崩溃或进程被强制终止，内存中的所有数据瞬间消失。图中的气泡对话框形象地说明了这一点：“Fast access, but data lost on power failure.”（访问快，但断电丢数据）。</li></ul></li><li><p><strong>关键组件：</strong></p><ul><li><strong>BUFFER POOL (缓冲池)：</strong><ul><li>这是 InnoDB 在内存中最大的保留区域。它缓存了从磁盘读取的数据页 (Data Pages)。</li><li>当我们要修改数据时，不是直接去改磁盘文件，而是先在 Buffer Pool 中找到对应的数据页进行修改。</li><li><strong>Dirty Page (脏页)：</strong> 图中高亮的橙色方块。当一个数据页在内存中被修改了，但还没有写回到磁盘的数据文件中时，它就和磁盘上的版本不一致了，我们称之为“脏页”。</li></ul></li><li><strong>LOG BUFFER (日志缓冲)：</strong><ul><li>这是一个相对较小的内存区域，专门用来暂存即将写入磁盘的 Redo Log 记录。</li><li>每当 Buffer Pool 中的数据发生修改，InnoDB 就会生成一条对应的、非常紧凑的日志记录（比如：“第10号数据页偏移量500的位置，值从A改成了B”），先暂存在这里。</li></ul></li></ul></li></ul><h2 id="2-右侧区域：ON-DISK-磁盘区域-Persistent-持久性"><a href="#2-右侧区域：ON-DISK-磁盘区域-Persistent-持久性" class="headerlink" title="2. 右侧区域：ON-DISK (磁盘区域) - Persistent (持久性)"></a>2. 右侧区域：ON-DISK (磁盘区域) - Persistent (持久性)</h2><ul><li><p><strong>特点：</strong></p><ul><li><p><strong>速度慢：</strong> 相比内存，磁盘 I&#x2F;O 是非常昂贵的操作，速度很慢。</p></li><li><p><strong>持久性 (Persistent)：</strong> 优点是数据安全。写入磁盘后，即使断电，数据也不会丢失。</p></li></ul></li><li><p><strong>关键组件：</strong></p><ul><li><p><strong>REDO LOG FILES (重做日志文件)：</strong></p><ul><li><p>这是保证数据安全的核心。它们是物理磁盘上的文件（通常命名为 <code>ib_logfile0</code>, <code>ib_logfile1</code> 等）。</p></li><li><p>特点是<strong>顺序写入 (Sequential Write)</strong>。就像写日记一样，一直往文件末尾追加内容。对于机械硬盘来说，顺序写的速度远快于随机写。</p></li></ul></li><li><p><strong>DATA FILES (数据文件)：</strong></p><ul><li><p>这是表数据最终的归宿（通常是 <code>.ibd</code> 文件）。</p></li><li><p>写入这些文件通常是<strong>随机写入 (Random Write)</strong>，因为不同的数据页分布在文件的不同位置。</p></li></ul></li></ul></li></ul><hr><h2 id="流程详解：正常事务操作-Normal-Operation"><a href="#流程详解：正常事务操作-Normal-Operation" class="headerlink" title="流程详解：正常事务操作 (Normal Operation)"></a>流程详解：正常事务操作 (Normal Operation)</h2><p>这个流程的目标是：<strong>既要利用内存的高速，又要保证数据的安全。</strong></p><p><strong>步骤 1. UPDATE&#x2F;INSERT Data (事务开始)</strong></p><ul><li><p>客户端发起一个更新请求。</p></li><li><p>InnoDB 首先在 <strong>Buffer Pool</strong> 中查找需要修改的数据页。如果不在，就先从磁盘读入。</p></li><li><p>在内存中直接修改该数据页。此时，该页变成了 <strong>Dirty Page (脏页)</strong>。</p></li></ul><p><strong>步骤 2. COMMIT Transaction (提交事务)</strong></p><ul><li><p>客户端修改完数据后，发起 <code>COMMIT</code> 命令，告诉数据库：“我完成了，请把这些修改永久保存。”</p></li><li><p>此时，关于这次修改的日志记录已经被放入了 <strong>Log Buffer</strong> 中等待。</p></li></ul><p><strong>步骤 3. WAL: WRITE-AHEAD LOGGING (预写式日志) —— 最关键的一步！</strong></p><ul><li><p><strong>这是跨越“易失”和“持久”边界的关键动作。</strong></p></li><li><p>在事务被认为是“提交成功”之前，InnoDB 必须遵循 WAL 原则：<strong>日志先行</strong>。</p></li><li><p>系统会将 Log Buffer 中的日志记录，强制写入到磁盘上的 <strong>Redo Log Files</strong> 中，并执行 <code>fsync()</code> 操作（确保数据真的落到物理磁盘介质上，而不是停留在操作系统的文件缓存里）。</p></li><li><p><strong>图中文字强调：</strong> “Must reach disk BEFORE transaction is confirmed.”（在确认事务之前，日志必须到达磁盘）。</p></li><li><p><em>注：一旦这一步完成，哪怕数据文件还没更新，事务也被认为是安全的了。图里虽然没画步骤4，但此时数据库会向客户端返回“Commit OK”。</em></p></li></ul><p><strong>步骤 5. ASYNC CHECKPOINT (异步检查点&#x2F;刷脏页)</strong></p><ul><li><p>这是一个后台的、异步的过程，<strong>不影响客户端的响应速度</strong>。</p></li><li><p>Buffer Pool 中的“脏页”不能永远待在内存里，内存有限，且不安全。</p></li><li><p>InnoDB 的后台线程会选择合适的时机（比如系统空闲时，或 Redo Log 快写满时），慢慢地将这些脏页刷新到磁盘上的 <strong>Data Files</strong> 中。我们将这个过程称为“刷脏”或 Checkpoint。</p></li><li><p>图中虚线箭头和文字 “Lazy write of data pages”（数据的延迟写入）准确地描述了这个过程。</p></li></ul><hr><h2 id="流程详解：崩溃恢复-Crash-Recovery-Process"><a href="#流程详解：崩溃恢复-Crash-Recovery-Process" class="headerlink" title="流程详解：崩溃恢复 (Crash Recovery Process)"></a>流程详解：崩溃恢复 (Crash Recovery Process)</h2><p>这个流程的目标是：<strong>当发生意外时，把还没来得及写入数据文件的修改找回来。</strong></p><p><strong>场景假设：</strong> 假设在上面的流程中，<strong>步骤 3 刚刚完成</strong>（Redo Log 已经落盘），但是<strong>步骤 5 还没有发生</strong>（脏页还在内存里，没写到数据文件），突然机房断电了。</p><p><strong>后果：</strong> 内存中的 Dirty Page 瞬间消失。磁盘上的 Data Files 里存的还是旧数据。</p><p><strong>恢复过程 (图的底部区域)：</strong></p><ol><li><p><strong>SYSTEM CRASH &#x2F; POWER OUTAGE (系统崩溃&#x2F;断电)</strong>。</p></li><li><p><strong>RESTART (重启)</strong>：MySQL 服务器重新启动。</p></li><li><p><strong>Read from Last Checkpoint (从上次检查点读取)</strong>：</p><ul><li><p>InnoDB 启动时会检查状态，发现上次是非正常关闭。</p></li><li><p>它会去读取磁盘上的 <strong>REDO LOG FILES</strong>。它需要找到一个“检查点 (Checkpoint)”，这个点之前的数据保证都已经写入数据文件了。</p></li></ul></li><li><p><strong>REPLAY LOGS (重放日志)</strong>：</p><ul><li><p>InnoDB 从检查点开始，往后读取所有的 Redo Log 记录。</p></li><li><p>它按照日志记录的内容，在内存的 <strong>Buffer Pool</strong> 中重新执行一遍修改操作。</p></li></ul></li><li><p><strong>Restore Dirty Pages to Memory (恢复脏页到内存)</strong>：</p><ul><li><p>通过重放日志，崩溃前那一刻内存中的 <strong>Dirty Page</strong> 就被完美还原了。</p></li><li><p>此时，数据库恢复到了崩溃前的一致状态，可以对外提供服务了。随后，后台线程会再次尝试执行步骤 5，把这些恢复出来的脏页写入数据文件。</p></li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这张图完美地展示了 MySQL InnoDB 的设计哲学：</p><ul><li><p>利用 <strong>内存 (Buffer Pool)</strong> 来保证<strong>高性能</strong>（读写都在内存）。</p></li><li><p>利用 <strong>Redo Log (WAL机制)</strong> 来保证<strong>持久性</strong>（关键时刻利用顺序写快速落盘日志）。</p></li><li><p>利用 <strong>异步刷脏 (Checkpoint)</strong> 来平衡性能和数据最终的一致性。</p></li></ul><h1 id="Bin-Log"><a href="#Bin-Log" class="headerlink" title="Bin Log"></a>Bin Log</h1><ul><li>Server 层也有自己的日志，称为 binlog（归档日志）。</li><li>binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。<br><img src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/MySQL_BinLog.webp" alt="img"></li></ul><h2 id="工作流程图详解"><a href="#工作流程图详解" class="headerlink" title="工作流程图详解"></a>工作流程图详解</h2><p>这张图片直观地展示了 <strong>MySQL Binlog (Binary Log，二进制日志)</strong> 的工作原理，以及它是如何支撑 <strong>主从复制 (Replication)</strong> 的。</p><p>我们可以把这张图的流程拆解为三个主要部分：<strong>主库（Master）的记录</strong>、<strong>数据的传输</strong>、<strong>从库（Slave&#x2F;Replica）的重放</strong>。</p><p>以下是详细的步骤解释：</p><h3 id="1-主库端-Master-Server-：记录变更"><a href="#1-主库端-Master-Server-：记录变更" class="headerlink" title="1. 主库端 (Master Server)：记录变更"></a>1. 主库端 (Master Server)：记录变更</h3><p>这是流程的起点，对应图中左侧或上方的部分。</p><ul><li><p>写入操作 (Write Operations):</p><p>  当客户端应用（Client Application）向数据库发送 修改数据 的请求（如 INSERT, UPDATE, DELETE）时，这些操作首先在主库的存储引擎中执行。</p><ul><li><em>注意：<code>SELECT</code> 等读取操作不会被记录，因为它们不改变数据。</em></li></ul></li><li><p>写入 Binlog 文件 (Binary Log File):</p><p>  在数据被提交（Commit）到底层存储之前（或同时），MySQL 会将这次数据变更的详细信息顺序写入到磁盘上的 Binlog 文件 中。</p><ul><li><strong>Binlog 的内容：</strong> 它可以记录具体的 SQL 语句（Statement 格式），也可以记录行数据的变化（Row 格式），或者两者的混合（Mixed 格式）。</li></ul></li></ul><h3 id="2-复制与传输过程：三个关键线程"><a href="#2-复制与传输过程：三个关键线程" class="headerlink" title="2. 复制与传输过程：三个关键线程"></a>2. 复制与传输过程：三个关键线程</h3><p>这是连接主库和从库的核心机制，也是图中的核心逻辑。为了把数据同步过去，MySQL 使用了三个专门的线程：</p><h4 id="A-Binlog-Dump-Thread-主库端"><a href="#A-Binlog-Dump-Thread-主库端" class="headerlink" title="A. Binlog Dump Thread (主库端)"></a>A. Binlog Dump Thread (主库端)</h4><ul><li><p>当从库连接到主库并请求同步时，主库会创建一个 <strong>Binlog Dump 线程</strong>。</p></li><li><p>它的任务是读取主库的 Binlog 文件，并将内容通过网络发送给从库。</p></li></ul><h4 id="B-I-O-Thread-从库端"><a href="#B-I-O-Thread-从库端" class="headerlink" title="B. I&#x2F;O Thread (从库端)"></a>B. I&#x2F;O Thread (从库端)</h4><ul><li><p>从库启动后，会创建一个 <strong>I&#x2F;O 线程</strong>。</p></li><li><p>它的任务是“搬运工”：它连接到主库，接收 Dump 线程发来的 Binlog 数据块。</p></li><li><p><strong>关键点：</strong> I&#x2F;O 线程收到数据后，<strong>不会直接写入从库的数据库</strong>，而是将其写入到从库磁盘上的一个临时中转文件，叫做 <strong>Relay Log (中继日志)</strong>。</p></li></ul><h4 id="C-SQL-Thread-从库端"><a href="#C-SQL-Thread-从库端" class="headerlink" title="C. SQL Thread (从库端)"></a>C. SQL Thread (从库端)</h4><ul><li><p>这是从库的第二个关键线程。</p></li><li><p>它的任务是“执行者”：它实时检测 Relay Log 中有没有新内容。</p></li><li><p>一旦发现新内容，它就读取这些日志，并将其解析为具体的数据库操作，然后在从库的数据库中<strong>重新执行 (Replay)</strong> 一遍。</p></li></ul><h3 id="3-从库端-Replica-Server-：最终一致性"><a href="#3-从库端-Replica-Server-：最终一致性" class="headerlink" title="3. 从库端 (Replica Server)：最终一致性"></a>3. 从库端 (Replica Server)：最终一致性</h3><p>对应图中右侧或下方的部分。</p><ul><li><p>Relay Log (中继日志):</p><p>  这是一个缓冲地带。它的存在使得“获取日志”和“执行日志”解耦了。即使从库执行 SQL 比较慢（SQL Thread 阻塞），I&#x2F;O 线程依然可以快速地把主库的日志拉取回来存在本地，保证数据不丢失。</p></li><li><p>数据同步完成:</p><p>  当 SQL 线程执行完 Relay Log 中的操作后，从库的数据状态就和主库保持了一致。</p></li></ul><hr><h3 id="总结：这张图告诉了我们什么？"><a href="#总结：这张图告诉了我们什么？" class="headerlink" title="总结：这张图告诉了我们什么？"></a>总结：这张图告诉了我们什么？</h3><ol><li><p><strong>异步复制 (Asynchronous):</strong> 主库写完 Binlog 就可以告诉客户端“成功了”，它不需要等从库确认。从库是后来慢慢追上来的。</p></li><li><p><strong>解耦:</strong> 通过 Binlog 和 Relay Log，主库和从库的压力被隔离开了。</p></li><li><p><strong>核心用途:</strong></p><ul><li><p><strong>主从复制:</strong> 实现读写分离（主库写，从库读）或高可用热备。</p></li><li><p><strong>数据恢复:</strong> 如果数据库误删了，可以通过重放 Binlog 把数据恢复到误删前的任意时刻（Point-in-Time Recovery）。</p></li></ul></li></ol><p>你可以把这个过程想象成：</p><p>主库是演讲者（执行写操作），它把演讲内容录在磁带（Binlog）里。从库派了一个快递员（I&#x2F;O 线程）把磁带复刻一份拿回家（Relay Log），然后从库自己在家里放磁带（SQL 线程），跟着录音再做一遍动作。</p><p><strong>需要我为您解释 Binlog 的三种格式（Statement, Row, Mixed）的区别吗？这对性能和数据一致性有很大影响。</strong></p><h1 id="Undo-Log"><a href="#Undo-Log" class="headerlink" title="Undo Log"></a>Undo Log</h1><p>如果说 <strong>Redo Log</strong> 是“发生意外时的救命稻草”，<strong>Bin Log</strong> 是“传给别人的操作手册”，那么 <strong>Undo Log</strong> 就是**“后悔药”**（或者说是电脑上的 <code>Ctrl+Z</code>）。</p><p>它是 MySQL 保证事务 <strong>原子性 (Atomicity)</strong> 和实现 <strong>MVCC (多版本并发控制)</strong> 的核心组件。</p><p>以下是 Undo Log 的详细解析及其与另外两个日志的区别。</p><hr><h2 id="1-什么是-Undo-Log？"><a href="#1-什么是-Undo-Log？" class="headerlink" title="1. 什么是 Undo Log？"></a>1. 什么是 Undo Log？</h2><p>Undo Log（回滚日志）记录的是数据的<strong>逻辑变化</strong>，但它的记录方式是**“反着来的”**。</p><ul><li><p><strong>记录原理：</strong> 只要你修改数据，MySQL 就会在 Undo Log 里记录一条<strong>相反</strong>的操作，以便随时回滚。</p><ul><li><p>你执行 <code>INSERT</code>，它记录 <code>DELETE</code>。</p></li><li><p>你执行 <code>DELETE</code>，它记录 <code>INSERT</code>。</p></li><li><p>你执行 <code>UPDATE</code> 把 <code>age</code> 从 10 改为 20，它记录 <code>UPDATE age = 10</code>。</p></li></ul></li></ul><h4 id="它的两大核心作用："><a href="#它的两大核心作用：" class="headerlink" title="它的两大核心作用："></a><strong>它的两大核心作用：</strong></h4><ol><li><p><strong>事务回滚 (Rollback)：</strong></p><ul><li>当事务执行到一半，用户手动输入 <code>ROLLBACK</code>，或者程序发生错误（如唯一索引冲突），MySQL 就利用 Undo Log 将数据恢复到事务开始前的样子。</li></ul></li><li><p><strong>MVCC (多版本并发控制)：</strong></p><ul><li>当一个事务正在修改某行数据（还没提交），另一个事务来读取这行数据时，为了不加锁且不读到脏数据，MySQL 会利用 Undo Log 构建一个**“历史版本快照”**，让读取者看到修改之前的数据。</li></ul></li></ol><hr><h2 id="2-Undo-Log-的工作流程图解"><a href="#2-Undo-Log-的工作流程图解" class="headerlink" title="2. Undo Log 的工作流程图解"></a>2. Undo Log 的工作流程图解</h2><p>假设我们执行一个事务：<code>UPDATE user SET age = 20 WHERE id = 1;</code> (原 age &#x3D; 10)</p><h4 id="Step-1-准备回滚数据"><a href="#Step-1-准备回滚数据" class="headerlink" title="Step 1: 准备回滚数据"></a><strong>Step 1: 准备回滚数据</strong></h4><p>在真正修改内存中的数据之前，InnoDB 会先生成一条 Undo Log：</p><blockquote><p>“如果要把 id&#x3D;1 的数据回滚，请执行 <code>UPDATE user SET age = 10 WHERE id = 1;</code>”</p></blockquote><h4 id="Step-2-修改内存-写-Redo-Log"><a href="#Step-2-修改内存-写-Redo-Log" class="headerlink" title="Step 2: 修改内存 &amp; 写 Redo Log"></a><strong>Step 2: 修改内存 &amp; 写 Redo Log</strong></h4><p>执行修改，内存中的 age 变为 20。同时写入 Redo Log（记录物理修改）。</p><h4 id="Step-3-此时如果有别的事务来查-MVCC"><a href="#Step-3-此时如果有别的事务来查-MVCC" class="headerlink" title="Step 3: 此时如果有别的事务来查 (MVCC)"></a><strong>Step 3: 此时如果有别的事务来查 (MVCC)</strong></h4><p>事务还没提交。此时事务 B 来查 id&#x3D;1。</p><p>InnoDB 发现这行数据被锁定了（或处于活跃事务中），它不会阻塞，而是顺着回滚指针 (Rollback Pointer) 找到 Undo Log 里的记录。</p><ul><li><p><strong>结果：</strong> 事务 B 读到了 <code>age = 10</code>。</p></li><li><p><strong>意义：</strong> 读写互不阻塞，高并发性能的关键。</p></li></ul><h4 id="Step-4-事务提交-Commit-或-回滚-Rollback"><a href="#Step-4-事务提交-Commit-或-回滚-Rollback" class="headerlink" title="Step 4: 事务提交 (Commit) 或 回滚 (Rollback)"></a><strong>Step 4: 事务提交 (Commit) 或 回滚 (Rollback)</strong></h4><ul><li><p><strong>如果提交：</strong> Undo Log 不会立即删除（因为可能还有长事务需要看旧版本），而是放入“待清理列表 (History List)”，由 Purge 线程后续清理。</p></li><li><p><strong>如果回滚：</strong> 立即执行 Undo Log 里的反向操作，将 age 变回 10。</p></li></ul><hr><h2 id="3-一个刁钻的问题：Undo-Log-本身需要持久化吗？"><a href="#3-一个刁钻的问题：Undo-Log-本身需要持久化吗？" class="headerlink" title="3. 一个刁钻的问题：Undo Log 本身需要持久化吗？"></a>3. 一个刁钻的问题：Undo Log 本身需要持久化吗？</h2><p><strong>需要。</strong></p><p>这听起来有点绕：Undo Log 是用来修数据的，那谁来修 Undo Log 呢？</p><p>答案是 Redo Log。</p><ul><li><p>Undo Log 在 MySQL 中也被视为“数据”的一种（存在于系统表空间或 undo 表空间中）。</p></li><li><p>当你写 Undo Log 时，这个写入操作本身也会产生对应的 Redo Log。</p></li><li><p><strong>场景：</strong> 假设事务执行了一半，MySQL 崩溃了。</p><ol><li><p>重启后，Redo Log 会先恢复数据，<strong>同时也恢复了 Undo Log</strong>。</p></li><li><p>数据库发现有一个事务处于“未提交”状态。</p></li><li><p>利用刚刚恢复出来的 Undo Log，对该事务进行回滚 (Rollback)。</p></li><li><p>数据库恢复一致性。</p></li></ol></li></ul><hr><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li><p><strong>Redo Log</strong> 让你<strong>向前走</strong>（掉电了也能继续往前走完）。</p></li><li><p><strong>Undo Log</strong> 让你<strong>向后退</strong>（做错了可以退回到原点）。</p></li><li><p><strong>Bin Log</strong> 让你<strong>克隆</strong>（把你的经历完整复制给另一个库）。</p></li></ul><p>三者配合：</p><ol><li><p>事务开启。</p></li><li><p>写 <strong>Undo Log</strong> (为了能退回来)。</p></li><li><p>执行内存修改。</p></li><li><p>写 <strong>Redo Log</strong> (为了防断电)。</p></li><li><p>提交时写 <strong>Bin Log</strong> (为了给从库)。</p></li><li><p>事务结束。</p></li></ol><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><table><thead><tr><th><strong>特性</strong></th><th><strong>Redo Log (重做日志)</strong></th><th><strong>Bin Log (归档日志)</strong></th><th><strong>Undo Log (回滚日志)</strong></th></tr></thead><tbody><tr><td><strong>核心关键词</strong></td><td><strong>“恢复”</strong></td><td><strong>“复制”</strong></td><td><strong>“撤销”</strong></td></tr><tr><td><strong>比喻</strong></td><td>记账本的草稿 (防止断电忘事)</td><td>完整的账单明细 (给别人看)</td><td><strong>橡皮擦 &#x2F; Ctrl+Z</strong></td></tr><tr><td><strong>侧重点</strong></td><td>物理偏向 (页修改)</td><td>逻辑偏向 (SQL语义)</td><td><strong>逻辑反向</strong> (逆操作)</td></tr><tr><td><strong>主要作用</strong></td><td>崩溃恢复 (Crash Safe)<br><br>  <br><br>保证 <strong>D</strong> (持久性)</td><td>主从复制、数据恢复<br><br>  <br><br>保证数据一致性</td><td>事务回滚、MVCC<br><br>  <br><br>保证 <strong>A</strong> (原子性) 和 <strong>I</strong> (隔离性)</td></tr><tr><td><strong>写入时机</strong></td><td>事务进行中不断写</td><td>事务提交时一次性写</td><td>事务开始前&#x2F;修改前写</td></tr><tr><td><strong>释放时机</strong></td><td>落盘后覆盖 (循环写)</td><td>不删除 (追加写)</td><td>事务提交后，若无 MVCC 需求则标记删除 (Purge)</td></tr></tbody></table><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="为什么需要“两阶段提交”-2-PC"><a href="#为什么需要“两阶段提交”-2-PC" class="headerlink" title="为什么需要“两阶段提交” (2 PC)?"></a>为什么需要“两阶段提交” (2 PC)?</h2><p><img src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/MySQL_2PC.webp" alt="img"></p><h3 id="背景问题：数据一致性"><a href="#背景问题：数据一致性" class="headerlink" title="背景问题：数据一致性"></a>背景问题：数据一致性</h3><p>如果 MySQL 没有两阶段提交，Redo Log 和 Bin Log 的写入顺序是独立的。假设我们执行一条 <code>UPDATE</code> 语句：</p><ol><li><p><strong>先写 Redo Log，再写 Bin Log：</strong></p><ul><li>如果 Redo Log 写完，Bin Log 还没写完时系统宕机。</li><li><em>恢复后：</em> 主库通过 Redo Log 恢复了数据（A&#x3D;1）；但 Bin Log 没记录，从库同步时数据仍是旧的（A&#x3D;0）。<strong>主从不一致。</strong></li></ul></li><li><p><strong>先写 Bin Log，再写 Redo Log：</strong></p><ul><li>如果 Bin Log 写完，Redo Log 没写完时系统宕机。</li><li><em>恢复后：</em> 主库因 Redo Log 缺失，事务回滚（A&#x3D;0）；但 Bin Log 已经有了记录，从库会同步这条更新（A&#x3D;1）。<strong>主从不一致。</strong></li></ul></li></ol><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p><strong>两阶段提交是为了让 Redo Log 和 Bin Log 在逻辑上保持一致</strong>。要么同时成功，要么同时失败。</p><hr><h3 id="两阶段提交流程详解"><a href="#两阶段提交流程详解" class="headerlink" title="两阶段提交流程详解"></a>两阶段提交流程详解</h3><p>假设执行语句：<code>UPDATE user SET age = age + 1 WHERE id = 1;</code></p><h4 id="流程图解"><a href="#流程图解" class="headerlink" title="流程图解"></a><strong>流程图解</strong></h4><p>代码段</p><div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>    sequenceDiagram    participant Client as 客户端    participant Executor as 执行器 (Server层)    participant InnoDB as InnoDB 引擎    participant DiskRedo as Redo Log (磁盘)    participant DiskBin as Bin Log (磁盘)    Client-&gt;&gt;Executor: 发起 Update 语句    Executor-&gt;&gt;InnoDB: 查找 ID&#x3D;1 的行    InnoDB--&gt;&gt;Executor: 返回行数据 (若不在内存则从磁盘读)        Note over Executor: 1. 执行更新操作    Executor-&gt;&gt;InnoDB: 写入新行数据 (内存更新)    Note over InnoDB, DiskRedo: 2. Prepare 阶段 (准备)    InnoDB-&gt;&gt;DiskRedo: 写入 Redo Log (状态: PREPARE)        Note over Executor, DiskBin: 3. 写 Binlog 阶段    Executor-&gt;&gt;DiskBin: 写入 Bin Log        Note over InnoDB, DiskRedo: 4. Commit 阶段 (提交)    Executor-&gt;&gt;InnoDB: 提交事务 (调用引擎接口)    InnoDB-&gt;&gt;DiskRedo: Redo Log 标记为 (状态: COMMIT)        Executor--&gt;&gt;Client: 返回成功  </pre></div><h4 id="详细步骤解析"><a href="#详细步骤解析" class="headerlink" title="详细步骤解析"></a><strong>详细步骤解析</strong></h4><ol><li><p><strong>执行阶段：</strong></p><ul><li>InnoDB 将内存中的数据更新（此时数据在内存中是脏页）。</li></ul></li><li><p><strong>Prepare 阶段 (第一阶段)：</strong></p><ul><li><p>InnoDB 将本次事务的变更写入 Redo Log，并将 Redo Log 的记录状态标记为 <code>PREPARE</code>。</p></li><li><p>此时，事务并未真正完成，但数据变更已经持久化到了 Redo Log 中。</p></li></ul></li><li><p><strong>写 Bin Log 阶段：</strong></p><ul><li>MySQL Server 层将事务的逻辑操作写入 Bin Log 文件，并确保写入磁盘（依赖 <code>sync_binlog</code> 参数）。</li></ul></li><li><p><strong>Commit 阶段 (第二阶段)：</strong></p><ul><li><p>Server 层调用引擎的提交接口。</p></li><li><p>InnoDB 收到通知后，将 Redo Log 中刚才那条记录的状态由 <code>PREPARE</code> 修改为 <code>COMMIT</code>。</p></li><li><p>至此，事务彻底完成。</p></li></ul></li></ol><hr><h3 id="崩溃恢复逻辑：它是如何保证一致性的？"><a href="#崩溃恢复逻辑：它是如何保证一致性的？" class="headerlink" title="崩溃恢复逻辑：它是如何保证一致性的？"></a>崩溃恢复逻辑：它是如何保证一致性的？</h3><p>如果在上述流程的任意时刻发生宕机（Crash），MySQL 重启后会检查 Redo Log 中的状态：</p><ul><li><p><strong>情况 A：Redo Log 是完整的 <code>COMMIT</code> 状态</strong></p><ul><li><p><strong>处理：</strong> 直接根据 Redo Log 提交事务，恢复数据。</p></li><li><p><strong>结果：</strong> 事务成功。</p></li></ul></li><li><p><strong>情况 B：Redo Log 是 <code>PREPARE</code> 状态，且 Bin Log 完整</strong></p><ul><li><p><em>场景：</em> 步骤 3 完成了（Bin Log 写了），但步骤 4 还没来得及改状态。</p></li><li><p><strong>处理：</strong> MySQL 扫描 Bin Log，发现该事务的 XID（事务 ID）在 Bin Log 中存在且完整。引擎将 Redo Log 状态补齐为 Commit，提交事务。</p></li><li><p><strong>结果：</strong> 事务成功（因为 Bin Log 已经有了，为了主从一致，主库必须提交）。</p></li></ul></li><li><p><strong>情况 C：Redo Log 是 <code>PREPARE</code> 状态，但 Bin Log 不完整&#x2F;缺失</strong></p><ul><li><p><em>场景：</em> 步骤 2 完成了，但在写 Bin Log 时宕机。</p></li><li><p><strong>处理：</strong> 扫描 Bin Log 发现没有对应的 XID。引擎回滚（Rollback）该事务。</p></li><li><p><strong>结果：</strong> 事务失败（主库回滚，从库也没收到 Bin Log，达成一致）。</p></li></ul></li></ul><hr><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li><p><strong>Redo Log</strong> 救主库（物理恢复），<strong>Bin Log</strong> 救从库（逻辑同步）。</p></li><li><p><strong>两阶段提交</strong> 就像是一个“握手协议”：</p><ul><li>先让 Redo Log 做好准备（Prepare）。</li><li>再写 Bin Log（关键点）。</li><li>最后确认 Redo Log（Commit）。</li></ul></li><li><p><strong>判决标准：</strong> 只要 <strong>Bin Log 写成功了</strong>，这个事务就算成功，Redo Log 即使是 Prepare 状态也会被强制提交；否则就回滚。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Golang</title>
      <link href="/posts/31482.html"/>
      <url>/posts/31482.html</url>
      
        <content type="html"><![CDATA[<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p><a href="https://qcrao91.gitbook.io/go/map/map-de-di-ceng-shi-xian-yuan-li-shi-shi-mo">map 的底层实现原理是什么 - 码农桃花源 (gitbook.io)</a></p><h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// A header for a Go map.</span><br><span class="line">type hmap struct &#123;</span><br><span class="line">    // 元素个数，调用 len(map) 时，直接返回此值</span><br><span class="line">    count     int</span><br><span class="line">    flags     uint8</span><br><span class="line">    // buckets 的对数 log_2</span><br><span class="line">    B         uint8</span><br><span class="line">    // overflow 的 bucket 近似数</span><br><span class="line">    noverflow uint16</span><br><span class="line">    // 计算 key 的哈希的时候会传入哈希函数</span><br><span class="line">    hash0     uint32</span><br><span class="line">    // 指向 buckets 数组，大小为 2^B</span><br><span class="line">    // 如果元素个数为0，就为 nil</span><br><span class="line">    buckets    unsafe.Pointer</span><br><span class="line">    // 扩容的时候，buckets 长度会是 oldbuckets 的两倍</span><br><span class="line">    oldbuckets unsafe.Pointer</span><br><span class="line">    // 指示扩容进度，小于此地址的 buckets 迁移完成</span><br><span class="line">    nevacuate  uintptr</span><br><span class="line">    extra *mapextra // optional fields</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>B：buckets数组的长度的对数，也就是说 buckets 数组的长度就是 2^B。bucket 里面存储了 key 和 value</li><li>buckets是一个指针，最终指向bmap这个数据结构</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type bmap struct &#123;</span><br><span class="line">    tophash [bucketCnt]uint8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 但上述只是表面(src/runtime/hashmap.go)的结构，编译期间会给它加料，动态地创建一个新的结构：</span><br><span class="line">type bmap struct &#123;</span><br><span class="line">    topbits  [8]uint8</span><br><span class="line">    keys     [8]keytype</span><br><span class="line">    values   [8]valuetype</span><br><span class="line">    pad      uintptr</span><br><span class="line">    overflow uintptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>bmap：即常说的桶。</li></ul><ol><li>桶里面最多<strong>装8个key</strong>，会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置</li><li>如若有第九个key进来，会再创建一个bucket，通过overflow指针连接</li><li>bmap的内存模型，是key&#x2F;key&#x2F;…&#x2F;value&#x2F;value&#x2F;…，这样可以减少额外的内存对齐所需要的空间</li></ol><ul><li>map的创建：</li></ul><ol><li>map创建出来是一个指针，因此在作为函数参数传入时，内部的改动也会影响到map自身</li><li>slice是一个结构体，因此作为函数参数传入时，不会影响到数据自身，但是由于数据是指针，因此可以改变指向的数据</li></ol><ul><li>map的遍历：是随机的<br>  go中range遍历map，不是固定的从bucket0开始遍历，每次会随机一个bucket开始遍历，并且bucket内也是会随机一个cell遍历</li></ul><h2 id="map扩容"><a href="#map扩容" class="headerlink" title="map扩容"></a>map扩容</h2><p>为避免大量key落在一个桶中，退化成链表，导致查询效率变为O(n)，装载因子被提出，用来衡量该情况。</p><p>loadFactor :&#x3D; count &#x2F; (2^B)</p><p>count : map中元素个数</p><p>B：2^B表示buckets数目</p><ul><li>触发扩容的时机：在向map中插入元素时，符合下面两个条件，会触发扩容</li></ul><ol><li>装载因子超出阈值6.5（元素塞满了bucket）</li><li>overflow的bucket过多：（元素没有塞满bucket了，bucket冗余空间过多）</li></ol><p>当 B 小于 15，也就是 bucket 总数 2^B 小于 2^15 时，如果 overflow 的 bucket 数量超过 2^B；当 B &gt;&#x3D; 15，也就是 bucket 总数 2^B 大于等于 2^15，如果 overflow 的 bucket 数量超过 2^15</p><ul><li>扩容的逻辑：“渐进式”扩容，原有的 key 并不会一次性搬迁完毕，每次最多只会搬迁 2 个 bucket。</li></ul><ol><li>分配新的buckets</li><li>搬迁到新的buckets，发生在插入、修改和删除时，会先检查oldbuckets是否为nil（nil则搬迁完成，不需要再搬迁了）</li></ol><ul><li>扩容后的容量：针对扩容触发的条件1和2，有两种策略</li></ul><ol><li>buckets数目翻倍：</li></ol><p>要重新计算 key 的哈希，才能决定它到底落在哪个 bucket。</p><ol start="2"><li>buckets数目相等：</li></ol><p>从老的 buckets 搬迁到新的 buckets，由于 bucktes 数量不变，因此可以按序号来搬，比如原来在 0 号 bucktes，到新的地方后，仍然放在 0 号 buckets。</p><h1 id="context"><a href="#context" class="headerlink" title="context"></a>context</h1><h2 id="context作用"><a href="#context作用" class="headerlink" title="context作用"></a>context作用</h2><ol><li><p>在 一组 goroutine 之间传递共享的值</p></li><li><p>取消goroutine</p></li><li><p>防止goroutine泄露</p></li><li><p>不要将 Context 塞到结构体里。直接将 Context 类型作为函数的第一参数，而且一般都命名为 ctx。</p></li><li><p>不要向函数传入一个 nil 的 context，如果你实在不知道传什么，标准库给你准备好了一个 context：todo。</p></li><li><p>不要把本应该作为函数参数的类型塞到 context 中，context 存储的应该是一些共同的数据。例如：登陆的 session、cookie 等。</p></li><li><p>同一个 context 可能会被传递到多个 goroutine，别担心，context 是并发安全的。</p></li></ol><ul><li>context 主要用来在 goroutine 之间传递上下文信息，包括：取消信号、超时时间、截止时间、k-v 等。</li><li>随着 context 包的引入，context 几乎成为了并发控制和超时控制的标准做法。</li></ul><h2 id="context-Value"><a href="#context-Value" class="headerlink" title="context.Value"></a>context.Value</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type valueCtx struct &#123;</span><br><span class="line">    Context</span><br><span class="line">    key, val interface&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>key要求是可比较的</li><li>属于一个树结构</li><li>取值过程，是会向上查找的</li><li>允许存在相同的key，向上查找会找到最后一个key相等的节点，即层数高的节点</li></ol><h1 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h1><ol><li>M必须拥有P才可执行G中的代码，P含有一个包含多个G的队列，P可以调度G交由M执行</li><li>所有可执行go routine都放在队列中：</li></ol><ul><li>全局队列（GRQ）：存储全局可运行的goroutine（从系统调用中恢复的G）；</li><li>本地可运行队列（LRQ）：存储本地（分配到P的）可运行的goroutine</li></ul><ol start="3"><li>workingschedule：各个P中维护的G队列很可能是不均衡的；空闲的P会查询全局队列，若全局队列也空，则会从其他P中窃取G（一般每次取一半）。</li></ol><h2 id="goroutine和线程的区别"><a href="#goroutine和线程的区别" class="headerlink" title="goroutine和线程的区别"></a>goroutine和线程的区别</h2><ol><li>内存占用：goroutine默认栈为2KB，线程至少需要1MB</li><li>创建和销毁：goroutine由go runtime管理，属于用户级别的，消耗小；线程是操作系统创建的，是内核级别的，消耗巨大</li><li>切换：goroutine切换只需要保存三个寄存器，线程切换需要寄存器</li></ol><h2 id="M-N模型（M个线程，N个goroutine）"><a href="#M-N模型（M个线程，N个goroutine）" class="headerlink" title="M:N模型（M个线程，N个goroutine）"></a>M:N模型（M个线程，N个goroutine）</h2><ol><li>go runtime负责管理goroutine，Runtime会在程序启动的时候，创建M个线程（CPU执行调度的单位），之后创建的N个goroutine都会依附在这M个线程上执行。</li><li>同一时刻，一个线程只能跑一个goroutine，当goroutine发生阻塞时，runtime会把它调度走，让其他goroutine来执行，不让线程闲着</li></ol><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="同步调用"><a href="#同步调用" class="headerlink" title="同步调用"></a>同步调用</h3><p>G1即将进入系统调用时，M1将释放P，让某个空闲的M2获取P并继续执行P队列中剩余的G（即M2接替M1的工作）；M2可能来源于M的缓存池，也可能是新建的。当G1系统调用完成后，根据M1能否获取到P，将对G1做不同的处理：</p><ul><li>有空闲的P，则获取一个以继续执行G1；</li><li>无空闲P，将G1放入全局队列，等待被其他P调度；M1进入缓冲池睡眠</li></ul><h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><ol><li>M 不会被阻塞，G 的异步请求会被“代理人” network poller 接手，G 也会被绑定到 network poller</li><li>等到系统调用结束，G 才会重新回到 P 上。</li><li>M 由于没被阻塞，它因此可以继续执行 LRQ 里的其他 G。</li></ol><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><p>垃圾回收器主要分为两个半独立的组件：</p><ul><li>赋值器(Mutator)：指代用户态的代码，修改对象之间的引用关系，也就是在对象图（对象之间引用关系的一个有向图）上进行操作。</li><li>回收期（Collector）：负责执行垃圾回收的代码</li></ul><h2 id="根对象"><a href="#根对象" class="headerlink" title="根对象"></a>根对象</h2><p>垃圾回收过程中最先检查的对象</p><ol><li>全局变量</li><li>执行栈</li><li>寄存器</li></ol><h2 id="常见GC算法"><a href="#常见GC算法" class="headerlink" title="常见GC算法"></a>常见GC算法</h2><ol><li>追踪式</li></ol><p>从根对象出发，根据对象之间的引用信息，一步步推进直到扫描完毕整个堆并确定需要保留的对象，从而回收所有可回收的对象。</p><ol start="2"><li>引用计数</li></ol><p>每个对象自身包含一个被引用的计数器，当计数器归零时自动得到回收</p><h2 id="Go的GC算法"><a href="#Go的GC算法" class="headerlink" title="Go的GC算法"></a>Go的GC算法</h2><p>Go 的 GC 目前使用的是无分代（对象没有代际之分）、不整理（回收过程中不对对象进行移动与整理）、并发（与用户代码并发执行）的三色标记清扫算法。</p><p>三色标记法通常指标记清扫的垃圾回收，三色规定了三种不同的对象：</p><ul><li><strong>白色对象</strong>（可能死亡）：未被回收器访问到的对象。在回收开始阶段，所有对象均为白色，当回收结束后，白色对象均不可达。</li><li><strong>灰色对象</strong>（波面）：已被回收器访问到的对象，但回收器需要对其中的一个或多个指针进行扫描，因为他们可能还指向白色对象。</li><li><strong>黑色对象</strong>（确定存活）：已被回收器访问到的对象，其中所有字段都已被扫描，黑色对象中任何一个指针都不可能直接指向白色对象。</li></ul><h3 id="回收过程："><a href="#回收过程：" class="headerlink" title="回收过程："></a>回收过程：</h3><ol><li>起初所有的对象都是白色的；</li><li>从根对象出发扫描所有可达对象，标记为灰色，放入待处理队列；</li><li>从待处理队列中取出灰色对象，将其引用的对象标记为灰色并放入待处理队列中，自身标记为黑色；</li><li>重复步骤3，直到待处理队列为空，此时白色对象即为不可达的“垃圾”，回收白色对象；</li></ol><h3 id="Go-GC-需要-STW-的原因："><a href="#Go-GC-需要-STW-的原因：" class="headerlink" title="Go GC 需要 STW 的原因："></a>Go GC 需要 STW 的原因：</h3><p>为了保证准确性、防止无止境的内存增长等问题而不可避免的需要停止赋值器进一步操作对象图以完成垃圾回收。</p><h2 id="GC监控"><a href="#GC监控" class="headerlink" title="GC监控"></a>GC监控</h2><p>方式1：GODEBUG&#x3D;gctrace&#x3D;1</p><p>方式2：go tool trace 将统计来的信息以可视化的信息展现给用户<br>方式3：debug.ReadGCStats 查看gc状态</p><p>方式4：runtime.ReadMemStats 对内存进行监控</p><h2 id="GC触发时机"><a href="#GC触发时机" class="headerlink" title="GC触发时机"></a>GC触发时机</h2><ol><li><strong>调用runtime.GC主动触发</strong>，此调用阻塞式地等待当前 GC 运行完毕。</li><li>被动触发：</li></ol><ul><li>使用系统监控，当超过两分钟没有产生任何 GC 时，强制触发 GC。</li><li>使用步调（Pacing）算法，其核心思想是控制内存增长的比例。</li></ul><h2 id="GC内存分配速度超出标记清除的速度怎么办"><a href="#GC内存分配速度超出标记清除的速度怎么办" class="headerlink" title="GC内存分配速度超出标记清除的速度怎么办"></a>GC内存分配速度超出标记清除的速度怎么办</h2><p>当 GC 触发后，会首先进入并发标记的阶段。并发标记会设置一个标志，并在 mallocgc 调用时进行检查。当存在新的内存分配时，会暂停分配内存过快的那些 goroutine，并将其转去执行一些辅助标记（Mark Assist）的工作，从而达到放缓继续分配、辅助 GC 的标记工作的目的。</p><h2 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h2><p>一般需要处理的两种情况：</p><ol><li>对停顿敏感：GC过程中造成的长时间停顿，即STW</li><li>对资源消耗敏感：对于频繁分配内存的应用而言，频繁分配内存增加 GC 的工作量，原本可以充分利用 CPU 的应用不得不频繁地执行垃圾回收，影响用户代码对 CPU 的利用率，进而影响用户代码的执行效率。</li></ol><ul><li>减少并复用内存</li></ul><p>例如使用 sync.Pool 来复用需要频繁创建临时对象，例如提前分配足够的内存来降低多余的拷贝。</p><ul><li>调整 GOGC</li></ul><p>GC 的触发原则是<strong>由步调算法来</strong>控制的，其关键在于估计下一次需要触发 GC 时，堆的大小。可想而知，如果我们在遇到海量请求的时，<strong>为了避免 GC 频繁触发，是否可以通过将 GOGC 的值设置得更大</strong>，让 GC 触发的时间变得更晚，从而减少其触发频率，进而增加用户代码对机器的使用率呢</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁</title>
      <link href="/posts/18358.html"/>
      <url>/posts/18358.html</url>
      
        <content type="html"><![CDATA[<ul><li>Zookeeper的分布式锁是客户端基于创建临时节点实现的，对于排他锁，每个客户端都尝试创建临时节点，但是只有一个客户端能成功创建，创建成功则相当于获取了锁。对于共享锁，则会按照一定的顺序队列创建带序号的临时节点并尝试获取锁（可以有多个客户端获取共享锁）。Redis的分布式锁则是通过创建一个从未创建过的key并设置其过期时间实现的，创建成功则获得了锁，并且客户端会在一定时间内循环获取锁，比较消耗服务器性能。</li><li>Zookeeper释放锁时，要么正常执行完业务逻辑后，事务主动释放，要么是检测到与客户端的会话失效后释放。Redis释放锁时，要么正常执行完业务逻辑后，事务主动释放，要么是键超时后释放锁。</li><li>对于Redis的主从结构中出现的主服务器宕机情况（单点故障），客户端A已经获取到锁了，但是主服务器还没来得及将键复制到从服务器，并且从服务器晋升为了主服务器，这时客户端B也可以获取锁，锁互斥效果就失效了。可以使用RedLock解决，但是不建议，可以使用Zookeeper。</li><li>Redis性能更高。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 学习笔记</title>
      <link href="/posts/16018.html"/>
      <url>/posts/16018.html</url>
      
        <content type="html"><![CDATA[<h2 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h2><h3 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">    int len; // buf中已使用的字节数</span><br><span class="line">    int free; // buf中未使用的字节数</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ol><li>包含头尾节点，head tail，以及链表长度计数器len</li><li>无环</li><li>多态：链表节点使用void*来保存节点值，可以支持各种不同类型的值</li></ol><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>属于k-v结构的映射表。</p><ol><li>字典由两个哈希表构成，当字典处于redhash状态，ht[1]才有数据，当rehash完成之后，数据会全部复制到ht[0]</li><li>哈希表使用链地址法来解决冲突</li><li>采用渐进式rehash，并不是一次性，集中式完成，而是分多次、渐进式完成。rehash会与增删改等操作一起进行：</li></ol><h3 id="渐进式hash总结："><a href="#渐进式hash总结：" class="headerlink" title="渐进式hash总结："></a><strong>渐进式hash总结：</strong></h3><p>在扩容和收缩的时候，如果哈希字典中有很多元素，一次性将这些键全部rehash到ht[1]的话，可能会导致服务器在一段时间内停止服务。所以，采用渐进式rehash的方式，详细步骤如下：</p><ol><li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表</li><li>将rehashindex的值设置为0，表示rehash工作正式开始</li><li>在rehash期间，每次对字典执行增删改查操作是，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashindex索引上的所有键值对rehash到ht[1]，当rehash工作完成以后，rehashindex的值+1</li><li>随着字典操作的不断执行，最终会在某一时间段上ht[0]的所有键值对都会被rehash到ht[1]，这时将rehashindex的值设置为-1，表示rehash操作结束</li></ol><p><strong>渐进式rehash采用的是一种分而治之的方式，将rehash的操作分摊在每一个的访问中，避免集中式rehash而带来的庞大计算量。</strong></p><p><strong>需要注意的是在渐进式rehash的过程，如果有增删改查操作时，如果<strong><strong>index</strong></strong>大于**<strong>rehashindex</strong></strong>，访问<strong><strong>ht[0]</strong></strong>，否则访问**<strong>ht[1]。</strong></p><h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><ul><li>是一种有序的数据结构，在每个节点中维持多个指向其他的节点指针，通过维持索引层，从而达到快速访问的目的。</li><li>一定程度来讲，跳表是简化版的红黑树，平均复杂度为logn，差别是空间复杂度会</li></ul><p>应用：有序集合、集群节点中用作内部数据结构</p><h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><p>整数集合是集合键（set）的实现之一，当集合都是整数，且数目不多时，会使用整数集合作为底层的实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset &#123;</span><br><span class="line">    uint32_t encoding;// 表明了整数集合的类型，如int16 int32 int64</span><br><span class="line">    uint32_t length;</span><br><span class="line">    int8_t contents[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：当新增元素超过元素的可表示范围，会将已存储元素进行升级（比如原来是uint32，但是新增元素是uint64,，会把已存储元素都升级为uint64）。优势：</p><ol><li>提供灵活性</li><li>节约内存</li></ol><h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>按照元素占用大小进行设计的数据结构，每个节点会有一个length字段，通过其可以计算出下一个节点的位置。不同于数组，这么做可以节省内存</p><p>应用：列表和哈希，都是其数据量少，且数据占用较小的时候，会使用该数据结构，不然就是链表和字典了。</p><h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><p>Redis是key-value数据库，key的类型只能是String，但是value的数据类型就比较丰富了，主要包括五种：</p><h3 id="String："><a href="#String：" class="headerlink" title="String："></a>String：</h3><ol><li>string类型是二进制安全的</li><li>一个键最大能存储512MB的数据，底层是简单动态字符串（SDS）：内部有个函数checkStringLength会对字符串进行校验，默认就是512MB，可以在配置文件中修改这个值</li></ol><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>是一个键值(key&#x3D;&gt;value)对集合。 Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。底层使用压缩列表和字典</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>底层使用压缩列表和链表实现</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>底层使整数集合和字典实现，key不允许重复</p><h3 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h3><p>有序集合，不允许重复。相对于set，支持按照score排序，key不允许重复，但是score允许重复，底层实现使用到了压缩列表和跳表</p><h2 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h2><p>在redis集群内部，采用slot槽位的逻辑管理方式， 集群内部共有16384(2的14次方)个Slot，集群内每个Redis Instance负责其中一部分的Slot的读写。一个Key到底属于哪个Slot，由分片算法：</p><p>crc16(key) % 16384</p><p>决定。也正是通过此分片算法，将不同的key以相对均匀的方式分配到不同的slot上。</p><h2 id="watch：当执行多键值事务操作时，Redis不仅要求这些键值需要落在同一个Redis实例上，还要求落在同一个slot上。"><a href="#watch：当执行多键值事务操作时，Redis不仅要求这些键值需要落在同一个Redis实例上，还要求落在同一个slot上。" class="headerlink" title="watch：当执行多键值事务操作时，Redis不仅要求这些键值需要落在同一个Redis实例上，还要求落在同一个slot上。"></a>watch：当执行多键值事务操作时，Redis不仅要求这些键值需要落在同一个Redis实例上，还要求落在同一个slot上。</h2><p>官方介绍MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令，事务可以一次执行多个命令，但是必须满足2个条件：</p><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。<br>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。执行和是否成功是2个概念，并不是一个失败报错等，其他就失败。redis对事务是部分支持。如果最开始语法等就有提交错误，就相当于java的编译器都过不了，那么肯定全部不执行。如果在执行过程中报错，已经全部执行了，但是谁报错找谁，其他正常执行放行。各取所需！这里的事务并不是要么全部成功，要么全部失败，全部执行和全部成功（或者都失败）是2个概念。</p><h2 id="hashtag"><a href="#hashtag" class="headerlink" title="hashtag"></a><a href="https://www.cnblogs.com/kismetv/p/9853040.html#t54">hashtag</a></h2><p>Hash Tag原理是：当一个key包含 {} 的时候，不对整个key做hash，而仅对 {}包括的字符串做hash。</p><p>Hash Tag可以让不同的key拥有相同的hash值，从而分配在同一个槽里；这样针对不同key的批量操作(mget&#x2F;mset等)，以及事务、Lua脚本等都可以支持。不过Hash Tag可能会带来数据分配不均的问题，这时需要：(1)调整不同节点中槽的数量，使数据分布尽量均匀；(2)避免对热点数据使用Hash Tag，导致请求分布不均。</p><h2 id="bigkey"><a href="#bigkey" class="headerlink" title="bigkey"></a><a href="https://blog.csdn.net/huxianbo0807/article/details/102912172">bigkey</a></h2><ul><li>涉及到bigkey的操作，网卡会成为瓶颈</li><li>若需要删除bigkey，直接del，被操作的实例可能会直接卡死</li><li>业务上对bigkey取余，将数据分散，避免生成bigkey</li></ul><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><ol><li>一台redis服务的数据，复制到多台redis服务器。前者称为主节点，后者为从节点</li><li>数据的复制是单向的，只能从主节点复制到从节点</li></ol><ul><li>作用：</li></ul><ol><li>数据冗余：实现了数据的热备份，是持久化之外的数据冗余方式</li><li>故障恢复：主节点失效，丛节点提供服务</li><li>负载均衡：实现读写分离，主节点写，丛节点读</li><li>高可用的基础：主从复制是哨兵和集群模式能够实施的基础</li></ol><ul><li>数据同步：</li></ul><ol><li><strong>主从节点连接建立</strong>后，便开始数据同步。</li><li>根据<strong>主从节点当前状态</strong>，分为全量和部分复制</li><li>具体执行方式：从节点朝主节点发送psync命令，开始同步</li></ol><ul><li>命令传播：<br>  主从数据同步完成后，主节点将自己执行的写命令发送给丛节点（该过程是异步的），保证数据的一致性。</li></ul><h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><ol><li>能够自动完成故障发现和转移，从而实现高可用</li><li>由一组哨兵节点和一组（或多组）主从复制节点组成</li></ol><ul><li>心跳机制</li><li>故障转移</li></ul><ol><li>每个 Sentinel 都会定时进行心跳检查，当发现主节点出现心跳检测超时的情况时，此时认为该主节点已经不可用，这种判定称为<strong>主观下线</strong>。</li><li>哨兵节点开始投票，当<strong>超过半数</strong>认为该主节点故障，会将其下线：基于raft算法，选取一个哨兵节点来执行该过程</li></ol><ul><li>选取一个从节点作为主节点，将其他从节点和该节点绑定</li><li>原来的主节点更新为从节点，对其监控，等恢复后，命令其去复制新的主节点</li></ul><h3 id="cluster集群"><a href="#cluster集群" class="headerlink" title="cluster集群"></a>cluster集群</h3><ol><li>由多个主从复制的结构组成</li><li>每个主从复制的结构看做一个节点</li></ol><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>优势：</p><ol><li>RDB 是一个非常紧凑（compact）的二进制文件，体积小，因此在传输速度上比较快，因此适合灾难恢复。</li><li>数据恢复速度比aof快</li></ol><p>劣势：</p><ol><li>rdb出现故障丢的数据会比aof多。你通常会每隔5分钟或者更久做一次完整的保存,万一在 Redis 意外宕机,你可能会丢失几分钟的数据。</li><li>rdb需要fork子进程来保存数据到硬盘，当数据集比较大时， fork比较耗时，从而导致redis主线程在一些毫秒级别内无法响应客户端</li></ol><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>优势：</p><ol><li>数据更完整，秒级丢失（无 fsync、每秒 fsync 、每次写的时候 fsync ）</li><li>兼容性高，是基于redis通讯协议而形成的命令追加方式，无论何种版本的redis都兼容，</li><li>aof文件是明文的，可阅读性较好。</li></ol><p>劣势：</p><ol><li>数据文件大，即使有重写机制（合并命令、删减无用命令），但是同样量级还是比rdb占用大</li><li>数据恢复慢</li><li>aof更吃性能（需要频繁同步命令，虽然会先写到内存中，再同步到磁盘里）</li></ol><h3 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h3><p>混合持久化结合了RDB持久化 和 AOF 持久化的优点, 由于绝大部分都是RDB格式，加载速度快，同时结合AOF，增量的数据以AOF方式保存了，数据更少的丢失。</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="redis分布式锁"><a href="#redis分布式锁" class="headerlink" title="redis分布式锁"></a>redis分布式锁</h3><p>redis实现分布式锁常见的有以很多，官方推荐下面的这种实现（也是我们目前的方式）</p><p>set命令加锁，lua脚本释放锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value NX PX milliseconds</span><br></pre></td></tr></table></figure><ul><li>key: 资源的key,标识一种资源。</li><li>value: 此值必须在所有进程和所有获取锁的请求中都是唯一的。</li><li>NX: 该命令仅在key不存在时才设置。</li><li>PX <em>milliseconds</em>: 过期时间,单位为毫秒。</li></ul><p>这里的value,设置为唯一值，主要是为了释放锁，自己只能释放自己加的锁。注意在某些场景下，也可以不释放锁，因为本身设置了有效期。</p><p>释放锁一般是通过执行下面的lua脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then</span><br><span class="line">    return redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="存在的问题："><a href="#存在的问题：" class="headerlink" title="存在的问题："></a>存在的问题：</h4><p>对于Redis主节点与从节点之间的数据复制是异步复制的，当客户端发送写请求给master节点的时候，客户端会返回OK（这个时候A已经获得锁），然后同步到各个slave节点中。如果此时master还没来得及同步给slave节点时发生宕机，那么master内存中的数据会丢失（这样可能会导致B也能获得锁）。</p><h4 id="redlock"><a href="#redlock" class="headerlink" title="redlock:"></a>redlock:</h4><p>它的基本思路就是为锁准备多个独立的节点，在锁过期时间内只要超过半数获取到锁，就算成功，避免redis主从切换的时候，数据丢失。</p><ul><li>问题：</li></ul><ol><li>宕机重启后，两个客户端拿到同一把锁</li></ol><p>假设5个节点是A, B, C, D, E，客户端1在A, B, C上面拿到锁，D, E没有拿到锁，客户端1拿锁成功。 此时，C挂了重启，C上面锁的数据丢失（假设机器断电，数据还没来得及刷盘）。客户端2去取锁，从C, D, E 3个节点拿到锁，A, B没有拿到（还被客户端1持有），客户端2也超过多数派，也会拿到锁</p><p>解决方案：延迟重启，等待ttl之后再重启。</p><ol start="2"><li>时钟跳跃：是指系统时间发生了跳跃</li></ol><p>时钟跳跃可能延迟重启机制失效，时钟跳跃可能导致机器挂了立马重启，从而出现上面的问题。时钟跳跃可能导致客户端拿到锁之后立马失效，跟服务器挂掉类似。基于自动过期机制，依然没有解决长时间的gc pause等问题带来的锁自动失效，从而带来的安全性问题</p><h3 id="zookeeper分布式锁"><a href="#zookeeper分布式锁" class="headerlink" title="zookeeper分布式锁"></a>zookeeper分布式锁</h3><ul><li><p>使用 ZK 的临时节点和有序节点，每个线程获取锁就是在 ZK 创建一个临时有序的节点，比如在 &#x2F;lock&#x2F; 目录下</p></li><li><p>创建节点成功后，获取 &#x2F;lock 目录下的所有临时节点，再判断当前线程创建的节点是否是所有的节点的序号最小的节点</p></li><li><p>如果当前线程创建的节点是所有节点序号最小的节点，则认为获取锁成功</p></li><li><p>如果当前线程创建的节点不是所有节点序号最小的节点，则对节点序号的前一个节点添加一个事件监听。</p></li></ul><h3 id="redis-zk对比"><a href="#redis-zk对比" class="headerlink" title="redis zk对比"></a>redis zk对比</h3><ul><li>Zookeeper的分布式锁是客户端基于创建临时节点实现的，对于排他锁，每个客户端都尝试创建临时节点，但是只有一个客户端能成功创建，创建成功则相当于获取了锁。对于共享锁，则会按照一定的顺序队列创建带序号的临时节点并尝试获取锁（可以有多个客户端获取共享锁）。Redis的分布式锁则是通过创建一个从未创建过的key并设置其过期时间实现的，创建成功则获得了锁，并且客户端会在一定时间内循环获取锁，比较消耗服务器性能。</li><li>Zookeeper释放锁时，要么正常执行完业务逻辑后，事务主动释放，要么是检测到与客户端的会话失效后释放。Redis释放锁时，要么正常执行完业务逻辑后，事务主动释放，要么是键超时后释放锁。</li><li>对于Redis的主从结构中出现的主服务器宕机情况（单点故障），客户端A已经获取到锁了，但是主服务器还没来得及将键复制到从服务器，并且从服务器晋升为了主服务器，这时客户端B也可以获取锁，锁互斥效果就失效了。可以使用RedLock解决，但是不建议，可以使用Zookeeper。</li><li>Redis性能更高。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TODO</title>
      <link href="/posts/4947.html"/>
      <url>/posts/4947.html</url>
      
        <content type="html"><![CDATA[<h3 id="Pending-Issues"><a href="#Pending-Issues" class="headerlink" title="Pending Issues"></a>Pending Issues</h3><ul><li><input disabled="" type="checkbox"> 首页按照更新时间展示文章列表<ul><li><input disabled="" type="checkbox"> 更新时间显示有误，导致列表展示乱序</li><li><input disabled="" type="checkbox"> 配置更新时间具体到分钟</li></ul></li></ul><h3 id="Fixed"><a href="#Fixed" class="headerlink" title="Fixed"></a>Fixed</h3><ul><li><input checked="" disabled="" type="checkbox"> 多级目录时，通过目录定位会出问题<ul><li>目录名一致，但是层级关系不一致，不会被视为同一目录，建议不要这样设置</li></ul></li><li><input checked="" disabled="" type="checkbox"> Obsidian 双链转 hexo 链接<ul><li>引用hexo-filter-titlebased-link 库，添加配置项解决该问题</li></ul></li><li><input checked="" disabled="" type="checkbox"> Mermaid 代码块渲染失败，需要引用 JS 语法<ul><li>引用hexo-filter-mermaid-diagrams 库，但是间歇性还是会渲染不出来，推荐还是使用<strong>标签插件 (Tag Plugin)</strong> 语法</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% mermaid %&#125;</span><br><span class="line">&#123;% endmermaid %&#125;</span><br></pre></td></tr></table></figure><ul><li><p><input checked="" disabled="" type="checkbox"> 本地测试经常性报 fontawesome failure</p><blockquote><pre><code>使用隐私模式访问，大概率没问题</code></pre></blockquote></li><li><p><input checked="" disabled="" type="checkbox"> 图片多大太大，导致加载缓慢的问题。参考: <a href="https://gemini.google.com/share/320865e42713">https://gemini.google.com/share/320865e42713</a></p><ul><li><input checked="" disabled="" type="checkbox"> 配置图床(github repo: <a href="%5BSupremes/blog-images%5D(https://github.com/Supremes/blog-images)">blog-images</a>)，并使用CDN - <code>cdn.jsdelivr.net </code> 加速访问</li><li><input checked="" disabled="" type="checkbox"> 压缩图片大小</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 学习笔记</title>
      <link href="/posts/8508.html"/>
      <url>/posts/8508.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-架构"><a href="#MySQL-架构" class="headerlink" title="MySQL 架构"></a>MySQL 架构</h1><p><img src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/MySQL1.png" alt="img"></p><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>负责和客户端建立连接、获取权限、维持和管理连接。连接命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h $ip -P $port -u $user -p</span><br></pre></td></tr></table></figure><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><ol><li><strong>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</strong></li></ol><p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p><ol start="2"><li><strong>MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。</strong></li></ol><h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>词法、语法分析，分析你SQL语句中的各个字段，确保没有出错。比如识别SELECT 关键字，识别出表单名t.</p><p>select * from t;</p><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><ol><li>在表里面有多个索引的时候，决定使用哪个索引</li><li>在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;</span><br></pre></td></tr></table></figure><ul><li>既可以先从表 t1 里面取出 c&#x3D;10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。</li><li>也可以先从表 t2 里面取出 d&#x3D;20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。</li></ul><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><ol><li>判断执行权限</li><li>根据表的引擎定义，调用引擎接口去执行</li></ol><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><blockquote><p> 内容详见 - <a  href="/posts/356a30bc.html">MySQL-日志</a></p></blockquote><h2 id="redo-log-重做日志"><a href="#redo-log-重做日志" class="headerlink" title="redo log - 重做日志"></a>redo log - 重做日志</h2><p>采用WAL（Write - Ahead Logging）, 先写日志，后写磁盘。</p><p>详细介绍：</p><ul><li><a href="https://www.cnblogs.com/zlia/p/14508366.html">https://www.cnblogs.com/zlia/p/14508366.html</a></li><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/MySQL%e5%ae%9e%e6%88%9845%e8%ae%b2/02%20%20%e6%97%a5%e5%bf%97%e7%b3%bb%e7%bb%9f%ef%bc%9a%e4%b8%80%e6%9d%a1SQL%e6%9b%b4%e6%96%b0%e8%af%ad%e5%8f%a5%e6%98%af%e5%a6%82%e4%bd%95%e6%89%a7%e8%a1%8c%e7%9a%84%ef%bc%9f.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/MySQL%e5%ae%9e%e6%88%9845%e8%ae%b2/02%20%20%e6%97%a5%e5%bf%97%e7%b3%bb%e7%bb%9f%ef%bc%9a%e4%b8%80%e6%9d%a1SQL%e6%9b%b4%e6%96%b0%e8%af%ad%e5%8f%a5%e6%98%af%e5%a6%82%e4%bd%95%e6%89%a7%e8%a1%8c%e7%9a%84%ef%bc%9f.md</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/MySQL_RedoLog.webp" alt="img"></p><h2 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h2><p>存在于Server层。</p><h2 id="Undo-log"><a href="#Undo-log" class="headerlink" title="Undo log"></a>Undo log</h2><p>存储事务执行过程中数据修改前的<strong>旧值。<strong>目的在</strong>事务回滚</strong>时，能够利用这些旧值。</p><p>假设一个值从 1 被按顺序改成了 2、3、4，在<strong>回滚日志</strong>里面就会有类似下面的记录：</p><p><img src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/MySQL2.png" alt="img"></p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li>redo log是存储引擎特有的，bin log是在Server层实现的，也就是说所有引擎都可以使用。</li><li>redo log是物理日志，举个例子，比如你将某个值由1改成2，又将2改成3，那么最终物理日志呈现的只有3（而没有记录3的由来），只不过不是直接将3写入，可能是采用偏移量之类的操作方式（无奈我看不懂），bin log是逻辑日志，逻辑日志表示记录从1-2-3这样子的一个过程。</li><li>redo log是循环写的，大小是固定的，bin log是追加的方式写的，不会覆盖以前的日志。</li></ul><table><thead><tr><th><strong>特性</strong></th><th><strong>Redo Log (重做日志)</strong></th><th><strong>Bin Log (归档日志)</strong></th><th><strong>Undo Log (回滚日志)</strong></th></tr></thead><tbody><tr><td><strong>核心关键词</strong></td><td><strong>“恢复”</strong></td><td><strong>“复制”</strong></td><td><strong>“撤销”</strong></td></tr><tr><td><strong>比喻</strong></td><td>记账本的草稿 (防止断电忘事)</td><td>完整的账单明细 (给别人看)</td><td><strong>橡皮擦 &#x2F; Ctrl+Z</strong></td></tr><tr><td><strong>侧重点</strong></td><td>物理偏向 (页修改)</td><td>逻辑偏向 (SQL语义)</td><td><strong>逻辑反向</strong> (逆操作)</td></tr><tr><td><strong>主要作用</strong></td><td>崩溃恢复 (Crash Safe)<br><br>  <br><br>保证 <strong>D</strong> (持久性)</td><td>主从复制、数据恢复<br><br>  <br><br>保证数据一致性</td><td>事务回滚、MVCC<br><br>  <br><br>保证 <strong>A</strong> (原子性) 和 <strong>I</strong> (隔离性)</td></tr><tr><td><strong>写入时机</strong></td><td>事务进行中不断写</td><td>事务提交时一次性写</td><td>事务开始前&#x2F;修改前写</td></tr><tr><td><strong>释放时机</strong></td><td>落盘后覆盖 (循环写)</td><td>不删除 (追加写)</td><td>事务提交后，若无 MVCC 需求则标记删除 (Purge)</td></tr></tbody></table><h1 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h1><h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p>ACID，即对应原子性、一致性、隔离性、持久性。通过undo log来保证原子性，能够撤销事务内的所以操作来保证原子性，要么是全部都成功，通过redo log来保证持久性，会根据策略进行刷脏，通过锁+MVCC的方式来保证隔离性，而一致性指的是从一个正确的状态迁移到另外一个正确的状态下，其实就是通过事务中的AID来保证C。</p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>隔离级别越高，性能越低。如下的隔离级别逐次升高。</p><h3 id="读未提交-read-uncommited"><a href="#读未提交-read-uncommited" class="headerlink" title="读未提交 - read uncommited"></a>读未提交 - read uncommited</h3><p>当前事务可以读取到未提交的事务。这种级别会造成脏读、不可重复读、幻读</p><h3 id="读提交-read-commited"><a href="#读提交-read-commited" class="headerlink" title="读提交 - read commited"></a>读提交 - read commited</h3><p>当前事务能够读取已提交事务的修改，这种隔离级别会造成不可重复读、幻读</p><h3 id="可重复读-repeatable-read"><a href="#可重复读-repeatable-read" class="headerlink" title="可重复读 - repeatable read"></a>可重复读 - repeatable read</h3><p>当前事务一开始读的数据是什么样子，那在它提交之前一直都是这样子，即使多次读取。会有幻读问题，但是个人认为它<code>**不会造成幻读**</code>（通过MVCC + 锁的方式）；</p><h3 id="串行化-serializable"><a href="#串行化-serializable" class="headerlink" title="串行化 - serializable"></a>串行化 - serializable</h3><p>对于同一行记录，写操作会加写锁，读操作会加读锁，当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行</p><h2 id="各类读问题"><a href="#各类读问题" class="headerlink" title="各类读问题"></a>各类读问题</h2><h3 id="脏读（Dirty-Read）"><a href="#脏读（Dirty-Read）" class="headerlink" title="脏读（Dirty Read）"></a>脏读（Dirty Read）</h3><ul><li><strong>定义</strong>：脏读是指在一个事务处理过程中读取了另一个未提交事务修改的数据。也就是说，事务A读取了事务B正在修改但尚未提交的数据，之后如果事务B回滚，那么事务A读取的数据就是无效的、“脏”的数据。</li><li><strong>示例</strong>：假设有两个事务，事务A是一个查询操作，事务B是一个更新操作。事务B更新了数据库中某条记录的一个字段值，但还没提交。此时事务A查询这条记录，获取到了事务B修改后的字段值。随后，事务B由于某种原因回滚了，那么事务A之前读取到的字段值就不再有效，这种情况就是脏读。</li><li><strong>产生原因</strong>：主要是因为事务的隔离级别设置较低，允许一个事务读取另一个未提交事务的数据。在数据库并发操作中，如果没有适当的并发控制机制，就容易出现脏读现象。</li></ul><h3 id="不可重复读（Non-repeatable-Read）"><a href="#不可重复读（Non-repeatable-Read）" class="headerlink" title="不可重复读（Non - repeatable Read）"></a>不可重复读（Non - repeatable Read）</h3><ul><li><strong>定义</strong>：不可重复读是指在一个事务内，多次读取同一数据时，由于其他事务对该数据进行了修改或删除操作，导致每次读取的数据不一致。</li><li><strong>示例</strong>：事务A在开始时读取了数据库中某条记录的某个字段值为10。随后，事务B更新了这条记录的该字段值为20并提交。当事务A再次读取这条记录的该字段时，得到的值为20，与第一次读取的值不同，这种情况就是不可重复读。</li><li><strong>产生原因</strong>：这是由于事务的隔离级别没有完全限制其他事务对数据的修改操作。在多事务并发环境下，当一个事务允许其他事务在其执行过程中修改它正在读取的数据时，就可能出现不可重复读的情况。</li></ul><h3 id="幻读（Phantom-Read）"><a href="#幻读（Phantom-Read）" class="headerlink" title="幻读（Phantom Read）"></a>幻读（Phantom Read）</h3><ul><li><strong>定义</strong>：幻读是指在一个事务中，按照某个条件进行数据查询时，第一次查询和第二次查询得到的结果集数量不同。这通常是因为在两次查询之间，另一个事务插入或删除了满足查询条件的记录。</li><li><strong>示例</strong>：事务A查询数据库中年龄大于30岁的员工数量，得到结果为10人。在事务A执行期间，事务B插入了几条年龄大于30岁的新员工记录并提交。当事务A再次查询年龄大于30岁的员工数量时，得到的结果比第一次多，好像出现了“幻觉”一样，这种情况就是幻读。</li><li><strong>产生原因</strong>：主要是因为事务的隔离级别不能阻止其他事务插入或删除符合查询条件的记录。在并发事务环境下，当一个事务在执行过程中，其他事务对数据的插入或删除操作影响了该事务的查询结果集，就会产生幻读。</li></ul><h3 id="事务隔离级别与这三种情况的关系"><a href="#事务隔离级别与这三种情况的关系" class="headerlink" title="事务隔离级别与这三种情况的关系"></a>事务隔离级别与这三种情况的关系</h3><ul><li><strong>读未提交（Read Uncommitted）</strong>：这是最低的事务隔离级别，允许脏读、不可重复读和幻读。在这种隔离级别下，一个事务可以读取另一个未提交事务的数据，所以很容易出现上述三种情况。</li><li><strong>读已提交（Read Committed）</strong>：这种隔离级别可以避免脏读。在一个事务读取数据时，只能读取其他已提交事务的数据，但是仍然可能出现不可重复读和幻读。</li><li><strong>可重复读（Repeatable Read）</strong>：可以避免脏读和不可重复读。在一个事务执行期间，它所读取的数据不会被其他事务修改，但是可能会出现幻读。在一些数据库系统（如MySQL的InnoDB存储引擎）中，通过使用间隙锁等技术可以在一定程度上减少幻读的发生。</li><li><strong>串行化（Serializable）</strong>：这是最高的事务隔离级别，可以避免脏读、不可重复读和幻读。在这种隔离级别下，事务是串行执行的，相当于对并发事务进行了严格的限制，虽然保证了数据的一致性，但会严重影响系统的性能和并发处理能力。</li></ul><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>Multi Version Concurrency Control - 多版本并发控制，一种数据库并发控制的技术，用来实现各种事务隔离级别。</p><h2 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h2><p>读的是数据的历史版本。常用以实现不同事务之间的隔离。</p><p>MVCC 为每个事务提供了一个数据快照，事务在这个快照范围内读取数据。这个快照包含了在事务开始时已经提交的数据版本。通过快照读，事务可以避免受到其他事务在其执行过程中对数据进行修改的影响，从而实现了不同事务之间的隔离</p><p>SELECT 是快照读，如果加锁的话，便是当前读。</p><h2 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h2><p>读的是数据的最新版本。</p><p>常用于对数据实时性要求高的场景，比如<strong>增删改</strong>等用来<strong>更新数据</strong>的场景，都需要读取到数据的最新版本。</p><ul><li>更新数据 - UPDATE 、DELETE、INSERT</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>MVCC 的核心思想是为每个事务提供一个数据快照（snapshot）。当一个事务开始时，它会看到数据库在某个特定时刻的状态，并且在整个事务期间，这个状态对于该事务是相对固定的。这意味着，即使其他事务对数据进行了修改，当前事务看到的仍然是它开始时的数据版本。</li><li>数据库会为每个数据行保存多个版本，这些版本可以通过时间戳或者版本号来区分。每当数据被修改时，不是直接覆盖原来的数据，而是创建一个新的版本。例如，在一个简单的银行账户余额数据表中，当用户 A 进行取款操作修改余额数据时，数据库不会立即删除原来的余额记录，而是创建一个新的余额版本记录，并标记上相应的事务时间戳或者版本号。</li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>提高并发性能：不会因为锁的竞争而导致系统性能下降。每个事务看到的是自己的版本数据，读写操作不会阻塞</li><li>保证数据一致性和隔离性：MVCC 能够提供不同的事务隔离级别，通过合理设置版本号或时间戳的检查规则，可以实现如读已提交（Read Committed）、可重复读（Repeatable Read）等隔离级别。</li></ul><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>InnoDB使用B+树作为索引模型。</p><ul><li>非叶子节点不保存数据</li><li>叶子节点间使用 指针相连，并按照大小顺序排列</li></ul><h2 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h2><p>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为<strong>聚簇索引</strong>（clustered index）。非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为<strong>二级索引</strong>（secondary index）。</p><h2 id="如何选择索引"><a href="#如何选择索引" class="headerlink" title="如何选择索引"></a>如何选择索引</h2><ul><li>基于索引的“区分度”来选择，一个索引上不同的值越多，区分度越高。索引上不同的值的个数，我们称之为“基数”（cardinality），也就是说，这个基数越大，索引的区分度越好。</li></ul><h2 id="如何加索引"><a href="#如何加索引" class="headerlink" title="如何加索引"></a>如何加索引</h2><p>针对超长字符串，可以考虑选择如下其一方式建立索引：</p><ul><li>倒序存储+前缀索引</li><li>添加hash字段，为其建立索引，crc32</li></ul><h2 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h2><p>普通索引，也就是通过二级索引找到对应的主键，在通过主键找到所需要的数据，这个过程就叫做回表，如果直接通过二级索引就能找到数据的话是不需要回表的。</p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>如果查找的列本身就在二级索引上，那么就不要回表了，这样子的索引叫做覆盖索引，通常用来减少回表的次数以提高性能。</p><h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>使用多个字段组合的索引，假设有联合索引（a，b），那么在索引树中它会先根据a的大小进行排序，如果有相同值的a在按照b的大小进行排序。</p><h3 id="最左前缀"><a href="#最左前缀" class="headerlink" title="最左前缀"></a>最左前缀</h3><p>可以是联合索引的最左N个字段，比如说有联合索引（a，b，c），那么等值查询条件是a &#x3D; 1的时候会用到联合索引中的部分索引a，条件是a &#x3D; 1 and b &#x3D; 2的时候会用到联合索引中的部分索引（a，b），同理条件是a &#x3D; 1 and b &#x3D; 2 and c &#x3D; 3，而对于条件是a &#x3D; 1 and c &#x3D; 3的情况下会使用也只能用到联合索引中的部分索引a。</p><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><ol><li><strong>索引下推（Index Condition Pushdown，ICP）概述</strong></li></ol><ul><li><strong>定义</strong>：索引下推是一种数据库查询优化技术，主要应用于数据库引擎（如MySQL的InnoDB存储引擎）在处理联合索引查询时。它的基本思想是将原本需要在服务器层（MySQL Server）进行的部分条件判断下推到存储引擎层（InnoDB），在索引遍历过程中就进行条件过滤，从而减少不必要的数据回表操作，提高查询效率。</li><li><strong>背景</strong>：在没有索引下推之前，当使用联合索引进行查询时，存储引擎通过索引获取到满足部分索引列条件的数据行的主键（以InnoDB为例），然后将这些主键对应的完整数据行回表（回到数据表）读取，最后在服务器层对这些完整的数据行进行其他剩余条件的判断。这种方式可能会导致大量不必要的数据回表操作，浪费系统资源。</li></ul><ol start="2"><li><strong>索引下推的工作原理</strong></li></ol><ul><li><p>假设在一个<code>employees</code>表中有一个联合索引<code>idx_name_age</code>（包含<code>name</code>和<code>age</code>两个列），现在要执行一个查询<code>SELECT * FROM employees WHERE name LIKE &#39;J%&#39; AND age &gt; 30;</code>。</p></li><li><p><strong>传统方式</strong>：</p></li><li><p>存储引擎首先使用联合索引<code>idx_name_age</code>找到<code>name</code>以<code>J</code>开头的所有记录的主键值。</p></li><li><p>然后对这些主键值对应的记录进行回表操作，将完整的数据行读取到服务器层。</p></li><li><p>最后在服务器层判断这些记录的<code>age</code>是否大于30，筛选出满足条件的记录。</p></li><li><p><strong>索引下推方式</strong>：</p></li><li><p>存储引擎在遍历联合索引<code>idx_name_age</code>时，不仅会检查<code>name</code>列是否以<code>J</code>开头，还会同时检查<code>age</code>列是否大于30。只有当<code>name</code>和<code>age</code>条件都满足的索引记录对应的主键才会被用来进行回表操作，读取完整的数据行。这样就避免了许多不满足<code>age &gt; 30</code>条件的记录的回表操作，减少了数据读取量和系统开销。</p></li></ul><ol start="3"><li><strong>索引下推的优势</strong></li></ol><ul><li><strong>减少回表操作次数</strong>：通过在存储引擎层提前过滤掉不符合条件的数据，大大减少了回表操作的频率。回表操作通常涉及磁盘I&#x2F;O或者缓存读取，减少回表操作可以显著提高查询性能，尤其是在处理大量数据和复杂查询时。</li><li><strong>提高查询效率</strong>：由于减少了不必要的数据读取和处理，查询的整体效率得到提升。在高并发的数据库环境中，这种性能提升可以使系统能够更快速地响应大量的查询请求。</li></ul><ol start="4"><li><strong>索引下推的限制和注意事项</strong></li></ol><ul><li><strong>对索引的依赖</strong>：索引下推是基于索引进行操作的，只有在使用联合索引并且有可以下推的条件时才能发挥作用。如果查询条件没有涉及联合索引或者没有合适的下推条件，就无法利用索引下推。</li><li><strong>不同数据库引擎的支持情况</strong>：不是所有的数据库引擎都支持索引下推。目前MySQL的InnoDB存储引擎支持索引下推，但其他数据库引擎可能需要具体查看其文档来确定是否支持以及支持的程度。</li><li><strong>与其他优化技术的结合</strong>：在实际的数据库优化中，索引下推通常需要与其他优化技术（如合理的索引设计、查询语句优化等）结合使用，才能达到最佳的性能提升效果。例如，即使有索引下推，如果索引本身设计不合理（如索引列的顺序不符合查询习惯等），查询效率可能仍然不高。</li></ul><h2 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h2><p>B+树的叶子节点会按照从小到大的顺序排列，如果插入的主键要处于中间位置，那么需要移动后面的数据来腾出位置，而如果在插入之前数据页就已经满了的话，那么就需要将后面的部分数据移动至另外一个数据页上，这个过程就叫做页分裂。</p><h2 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a>页合并</h2><p>当相邻两个数据页由于删除了数据之后，整个的空间变小了，那么就会将两个数据页进行合并，以提高数据页空间的利用率。</p><h2 id="重建二级索引和重建主键索引"><a href="#重建二级索引和重建主键索引" class="headerlink" title="重建二级索引和重建主键索引"></a>重建二级索引和重建主键索引</h2><p>首先重建索引是为了让数据页的空间得到充分利用，也就省去了很多空间的浪费，对于重建二级索引来说是可以先删除掉索引在增加，对于重建主键索引的话如果先删除的话，它会使二级索引失效（由于重建主键索引，重新计算后的指针会发生变化），正确地重建主键索引是：ALTER TABLE T ENGINE &#x3D; INNODB，或者是迁移数据库，不过这种方式只适合离线的业务。</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>给整个数据库实例加 <strong>读锁 -</strong> <code>**Flush tables with read lock**</code>, 其他线程的增删读写会被阻塞，使用 <code>**unlock tables**</code>进行解除。</p><p>为什么使用全局锁而不要使用全库只读（set global readonly &#x3D; true）：一方面是readonly通常会被用来做其他的逻辑，比如说用来判断主备库，随意修改全局变量可能会影响；另外一方面使用全局锁的客户端如果崩溃了的话，MySQL会自动释放锁，整个库可以回到正常更新的状态，而将整个库设置为readonly之后，如果客户端发生异常，则数据库会一直保持readonly状态，导致整个库长时间处于不可写状态。</p><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><p>加表锁 - <code>lock tables t1 read/write</code></p><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><ul><li>二阶段锁协议：在事务中，只有提交(commit)或者回滚(rollback)时才是解锁阶段， 其余时间为加锁阶段。</li><li>发起死锁检测：<strong>innodb_deadlock_detect</strong>设置为on，默认情况下是on，缺点就是会耗费大量的CPU资源（发现死锁后主动回滚某一个事务，让其他事务得以继续执行）。</li></ul><h2 id="元数据锁-metadata-lock-MDL"><a href="#元数据锁-metadata-lock-MDL" class="headerlink" title="元数据锁 - metadata lock - MDL"></a>元数据锁 - metadata lock - MDL</h2><p>属于Server层的锁，表级锁，主要用于隔离DML和DDL操作之间的干扰，比如一个线程在查询数据的时候，另外一个线程肯定不能修改表结构，不然就乱套了，所以DML操作需要申请MDL读锁，而DDL操作需要申请MDL写锁，读读之间共享，读写之间互斥，写写之间互斥。</p><ul><li>DML：数据库操作语言</li><li>DDL：数据库定义语言</li><li>MDL 读锁 - 共享读锁：当一个事务只是读取数据库对象的元数据（如查询表的结构信息）时，会获取共享读锁。这种锁<strong>允许多个事务同时对同一对象的元数据进行读取操作</strong>，但<strong>不允许其他事务对该对象的元数据进行修改操作</strong>。</li><li>MDL 写锁- 排他锁：当一个事务需要修改数据库对象的元数据（如添加列、修改表结构等）时，会获取排他锁。这种锁会<strong>阻止其他事务对该对象的元数据进行读取或修改操作</strong>，直到该事务完成对元数据的修改并释放锁。</li></ul><h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><ul><li>脏页：指内存（缓存池）中的数据页与磁盘上的数据页不一致的情况。数据库表单的增删改等写操作，都会产生脏页。</li></ul><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ul><li><a href="https://zzk.cnblogs.com/s/blogpost?Keywords=blog:zlia%20mysql45&pageindex=1">https://zzk.cnblogs.com/s/blogpost?Keywords=blog%3Azlia%20mysql45&amp;pageindex=1</a></li><li><a href="https://www.cnblogs.com/zlia/p/14571050.html">https://www.cnblogs.com/zlia/p/14571050.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APNS</title>
      <link href="/posts/45153.html"/>
      <url>/posts/45153.html</url>
      
        <content type="html"><![CDATA[<p><strong>APNS</strong>、<strong>iPhone</strong>（设备）和 <strong>后台服务器（Server）</strong> 三者之间的关系和数据流。</p><p>以下是APNS的时序图，展示了设备、APNS和服务器之间的交互流程：<br>使用 code block - mermaid</p><div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>    sequenceDiagram    participant I as iPhone (设备)    participant A as APNS    participant S as Server (后台服务器)    autonumber        %% 设备注册推送并获取设备令牌    I-&gt;&gt;A: 注册推送通知 (registerForRemoteNotifications)    A--&gt;&gt;I: 返回设备令牌 (Device Token)    I-&gt;&gt;S: 发送设备令牌给后台服务器 (via HTTPS)    %% 设备与 APNS 建立长连接    I-&gt;&gt;A: 建立 TCP 长连接 (端口 5223&#x2F;443)    Note right of A: 长连接维持，设备主动发起    %% 推送通知流程    S-&gt;&gt;A: 发送推送请求 (HTTP&#x2F;2, 携带 Device Token)    Note right of S: 短连接，按需发起    A-&gt;&gt;I: 通过长连接推送通知给设备    Note right of I: 系统处理通知 (显示&#x2F;角标等)    %% 断网后重连    I--xA: 网络断开，长连接中断    I-&gt;&gt;A: 网络恢复，主动重连 (携带 Device Token)    Note right of A: APNS 更新连接状态    %% 再次推送    S-&gt;&gt;A: 发送新的推送请求    A-&gt;&gt;I: 通过新连接推送通知  </pre></div><blockquote><p>可以在 <a href="https://mermaid.live/">https://mermaid.live</a> 在线编辑和渲染Mermaid图表</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> APNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日记 - 2025-11-28</title>
      <link href="/posts/1251.html"/>
      <url>/posts/1251.html</url>
      
        <content type="html"><![CDATA[<p><code>fa-</code> 样式是指 <strong>Font Awesome</strong> 图标库的图标名称。从配置文件中可以看到，比如：</p><ul><li><code>fas fa-home</code> (首页图标)</li><li><code>fas fa-archive</code> (归档图标)</li><li><code>fas fa-tags</code> (标签图标)</li><li><code>fas fa-folder-open</code> (文件夹图标)</li><li><code>fas fa-server</code> (服务器图标)</li><li><code>fas fa-shield-alt</code> (盾牌图标)</li><li><code>fas fa-robot</code> (机器人图标)</li></ul><h2 id="📚-Font-Awesome-图标查找资源"><a href="#📚-Font-Awesome-图标查找资源" class="headerlink" title="📚 Font Awesome 图标查找资源"></a>📚 Font Awesome 图标查找资源</h2><h3 id="🌐-官方网站"><a href="#🌐-官方网站" class="headerlink" title="🌐 官方网站"></a>🌐 官方网站</h3><p><strong>Font Awesome 官方图标库：</strong></p><ul><li>🔗 <a href="https://fontawesome.com/icons">https://fontawesome.com/icons</a></li><li>🔗 <a href="https://fontawesome.com/v5/search">https://fontawesome.com/v5/search</a> (v5版本)</li><li>🔗 <a href="https://fontawesome.com/v6/search">https://fontawesome.com/v6/search</a> (v6版本)</li></ul><h3 id="🏷️-图标分类说明"><a href="#🏷️-图标分类说明" class="headerlink" title="🏷️ 图标分类说明"></a>🏷️ 图标分类说明</h3><p>Font Awesome 图标分为几个主要类别：</p><ol><li><strong><code>fas</code></strong> - Solid (实心图标)</li><li><strong><code>far</code></strong> - Regular (常规图标) </li><li><strong><code>fab</code></strong> - Brands (品牌图标)</li><li><strong><code>fal</code></strong> - Light (轻量图标，Pro版本)</li><li><strong><code>fad</code></strong> - Duotone (双色图标，Pro版本)</li></ol><h3 id="🔍-常用图标示例"><a href="#🔍-常用图标示例" class="headerlink" title="🔍 常用图标示例"></a>🔍 常用图标示例</h3><p><strong>技术类图标：</strong></p><ul><li><code>fas fa-code</code> (代码)</li><li><code>fas fa-database</code> (数据库)</li><li><code>fab fa-github</code> (GitHub)</li><li><code>fab fa-docker</code> (Docker)</li><li><code>fas fa-cloud</code> (云)</li></ul><p><strong>分类图标：</strong></p><ul><li><code>fas fa-laptop-code</code> (编程)</li><li><code>fas fa-network-wired</code> (网络)</li><li><code>fas fa-brain</code> (AI&#x2F;智能)</li><li><code>fas fa-mobile-alt</code> (移动设备)</li><li><code>fas fa-tools</code> (工具)</li></ul><p><strong>导航图标：</strong></p><ul><li><code>fas fa-home</code> (首页)</li><li><code>fas fa-user</code> (用户)</li><li><code>fas fa-envelope</code> (邮件)</li><li><code>fas fa-search</code> (搜索)</li></ul><h3 id="💡-使用方法"><a href="#💡-使用方法" class="headerlink" title="💡 使用方法"></a>💡 使用方法</h3><p>在 Hexo Butterfly 主题中，图标格式为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">菜单名:</span> <span class="string">/链接/</span> <span class="string">||</span> <span class="string">图标类别</span> <span class="string">图标名称</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">AI:</span> <span class="string">/categories/ai/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-robot</span></span><br><span class="line"><span class="string">编程:</span> <span class="string">/categories/coding/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-code</span></span><br><span class="line"><span class="string">数据库:</span> <span class="string">/categories/database/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-database</span></span><br></pre></td></tr></table></figure><h3 id="🛠️-实用工具"><a href="#🛠️-实用工具" class="headerlink" title="🛠️ 实用工具"></a>🛠️ 实用工具</h3><p>您也可以使用这些在线工具快速查找图标：</p><ul><li><strong>图标搜索：</strong> 在官网搜索框输入关键词（如 “robot”, “code”, “security”）</li><li><strong>图标预览：</strong> 可以直接在网站上看到图标效果</li><li><strong>复制代码：</strong> 点击图标后可以直接复制 HTML 类名</li></ul>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Obsidian Configuration</title>
      <link href="/posts/54351.html"/>
      <url>/posts/54351.html</url>
      
        <content type="html"><![CDATA[<h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><ul><li><strong>Excalidraw</strong></li><li><code>Hexo Toolkit </code></li><li><em>Shell commands</em></li></ul><p>为了让你找回 Typora 的感觉，请安装以下插件：</p><table><thead><tr><th><strong>插件名称</strong></th><th><strong>作用</strong></th><th><strong>推荐配置</strong></th></tr></thead><tbody><tr><td>Editing Toolbar</td><td><strong>核心推荐</strong>。在顶部增加类似 Word&#x2F;Typora 的格式工具栏。</td><td>必装，完美复刻 Typora 菜单。</td></tr><tr><td>Image Toolkit</td><td>点击图片全屏查看、缩放、滚轮放大。</td><td>解决 Obsidian 默认无法点击看大图的问题。</td></tr><tr><td>Easy Typing</td><td>优化中文输入体验，自动在中英文之间加空格。</td><td>强迫症福音。</td></tr><tr><td>Dataview</td><td>在首页生成一个“最近更新的文章”列表。</td><td>把 Obsidian 首页变成你的博客 Dashboard。</td></tr></tbody></table><h2 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h2><p>Obsidian 的默认主题是给程序员看的，太素了。</p><ul><li><p><strong>操作：</strong> <code>设置</code> -&gt; <code>外观 (Appearance)</code> -&gt; <code>主题 (Themes)</code> -&gt; <code>管理 (Manage)</code>。</p></li><li><p><strong>推荐主题（专治简陋）：</strong></p><ul><li><p><strong>Blue Topaz：</strong> （强烈推荐）这是国人开发的主题，功能极其强大，色彩丰富，默认就很漂亮，适合习惯 Typora 的用户。</p></li><li><p><strong>Minimal：</strong> 极简主义，Apple 风格，干净利落。</p></li><li><p><strong>Primary：</strong> 暖色调，字体排版非常舒服，像杂志一样。</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">table time-played, length, rating</span><br><span class="line">from &quot;games&quot;</span><br><span class="line">sort rating desc</span><br></pre></td></tr></table></figure><ul><li>Theme: Minimal</li><li>Plugin: Minimal Theme Settings<ul><li>Flexio</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Obsidian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI Agent 技术核心概念学习路线</title>
      <link href="/posts/51504.html"/>
      <url>/posts/51504.html</url>
      
        <content type="html"><![CDATA[<h3 id="LLM应用技术核心概念学习路线"><a href="#LLM应用技术核心概念学习路线" class="headerlink" title="LLM应用技术核心概念学习路线"></a><strong>LLM应用技术核心概念学习路线</strong></h3><p>这条路线遵循从“基础构件”到“核心能力”再到“高级模式”的逻辑。</p><hr><h4 id="第一阶段：理解基石——让计算机“懂得”含义（Embedding）"><a href="#第一阶段：理解基石——让计算机“懂得”含义（Embedding）" class="headerlink" title="第一阶段：理解基石——让计算机“懂得”含义（Embedding）"></a><strong>第一阶段：理解基石——让计算机“懂得”含义（Embedding）</strong></h4><ul><li><strong>核心问题</strong>：计算机只认识数字，我们如何让它们理解文字、图片、视频的“意思”？</li><li><strong>什么是 Embedding（嵌入）？</strong> <strong>比喻</strong>：想象一个“语义地图”。每个词（或句子、图片）都是这个地图上的一个点。含义相近的词（如“国王”和“皇帝”）在地图上的位置会非常接近；含义相反的词（如“国王”和“平民”）则相距甚远。 <strong>本质</strong>：Embedding 就是一套算法，将非结构化的数据（文字、图片等）转换成一串有意义的数字向量。这个向量就是数据点在“语义地图”上的<strong>坐标</strong>。 **为什么需要？**只有把数据变成数字坐标，计算机才能进行数学计算，从而比较相似性、进行分类、聚类等操作。<strong>这是后续所有技术的基础。</strong></li></ul><h4 id="第二阶段：实现检索——构建“外部记忆库”（向量数据库）"><a href="#第二阶段：实现检索——构建“外部记忆库”（向量数据库）" class="headerlink" title="第二阶段：实现检索——构建“外部记忆库”（向量数据库）"></a><strong>第二阶段：实现检索——构建“外部记忆库”（向量数据库）</strong></h4><ul><li><strong>核心问题</strong>：有了“语义地图”，但当数据量极其庞大时（比如整个公司知识库），如何快速找到与问题最相关的信息？</li><li><strong>为什么需要向量数据库？</strong> <strong>传统数据库的局限</strong>：它们擅长精确匹配（如“找到id&#x3D;1的用户”），但不擅长模糊查询（如“找到意思最接近‘可持续发展’的文档”）。 <strong>向量数据库的强项</strong>：它就是为“语义地图”量身定制的数据库。它专门做一件事——<strong>近似最近邻搜索</strong>。你给它一个问题的坐标（问题本身的向量），它能以极快的速度在整个海量向量库中，找到坐标最接近的几个点（即语义最相关的文本片段）。 <strong>本质</strong>：向量数据库是LLM的“外部记忆库”或“知识索引系统”，负责高效、精准地检索信息。</li></ul><h4 id="第三阶段：衡量相关性——定义“相似”的标准（Cosine-Similarity）"><a href="#第三阶段：衡量相关性——定义“相似”的标准（Cosine-Similarity）" class="headerlink" title="第三阶段：衡量相关性——定义“相似”的标准（Cosine Similarity）"></a><strong>第三阶段：衡量相关性——定义“相似”的标准（Cosine Similarity）</strong></h4><ul><li><strong>核心问题</strong>：在“语义地图”上，如何数学地定义两个点“相似”？是看它们的直线距离吗？</li><li><strong>Cosine Similarity（余弦相似度）到底在算个啥？</strong> <strong>比喻</strong>：不比“距离”，比“方向”。想象两个从原点出发的箭头。我们不关心箭头的长短（向量的绝对大小，比如文档的长短），只关心两个箭头指向的方向是否一致。 <strong>计算什么</strong>：它计算的是两个向量之间夹角的余弦值。夹角为0度（方向完全一致），余弦值为1，表示完全相似；夹角为90度（方向垂直），余弦值为0，表示不相关。 <strong>为什么在NLP中常用</strong>：因为它更关注语义上的方向性，而忽略文本长度的影响，这更符合我们判断“意思是否相似”的直觉。</li></ul><p><strong>👉 至此，你已经掌握了RAG的“检索”部分的核心技术栈：<code>文本 -&gt; Embedding -&gt; 向量数据库 -&gt; 余弦相似度检索</code>。</strong></p><hr><h4 id="第四阶段：构建应用——给LLM“开小灶”（RAG）"><a href="#第四阶段：构建应用——给LLM“开小灶”（RAG）" class="headerlink" title="第四阶段：构建应用——给LLM“开小灶”（RAG）"></a><strong>第四阶段：构建应用——给LLM“开小灶”（RAG）</strong></h4><ul><li><strong>核心问题</strong>：LLM内部知识老旧、会产生幻觉（胡说八道），如何让它能回答未知的、专业领域的问题？</li><li><strong>RAG（检索增强生成）的本质是什么？</strong> <strong>不只是“喂知识库”</strong>：你的理解非常到位。它的本质是<strong>将LLM的推理能力与外部知识源的动态检索能力相结合</strong>。 <strong>工作流程</strong>： <strong>检索</strong>：当用户提出问题时，<strong>不直接</strong>将问题扔给LLM。而是先用上面的技术栈（Embedding+向量数据库+相似度计算），从外部知识库中“精准地检索”出与问题最相关的几段信息（上下文）。 <strong>增强</strong>：将“<strong>原始问题 + 检索到的精准上下文</strong>”一起打包，作为一个新的、信息更丰富的提示词（Prompt）交给LLM。 <strong>生成</strong>：LLM基于这个包含了“标准答案”线索的Prompt来生成回答。 <strong>核心挑战与你的思考一致</strong>：如何“精准地检索”？如果检索到的信息不相关，LLM的回答就会跑偏。因此，检索器的质量（Embedding模型、向量数据库、排序算法）直接决定了RAG的天花板。 <strong>它解决了</strong>：知识更新问题（改知识库即可）、幻觉问题（答案有据可查）、溯源问题（可以注明答案来源）。</li></ul><hr><h4 id="第五阶段：升级交互——让LLM“学会使用工具”（Function-Calling-ReAct）"><a href="#第五阶段：升级交互——让LLM“学会使用工具”（Function-Calling-ReAct）" class="headerlink" title="第五阶段：升级交互——让LLM“学会使用工具”（Function Calling &amp; ReAct）"></a><strong>第五阶段：升级交互——让LLM“学会使用工具”（Function Calling &amp; ReAct）</strong></h4><ul><li><strong>核心问题</strong>：LLM无法感知实时信息（天气、股价），无法执行具体动作（发邮件、查数据库）。如何让它与外部世界互动？</li><li><strong>Function Calling（函数调用）的工作流程是怎样的？</strong> <strong>比喻</strong>：给LLM一个“工具清单”，上面列出了每个工具的名称、功能和用法说明（这就是所谓的“函数模式”或“工具模式”）。 <strong>工作流程</strong>： <strong>用户请求</strong>：用户提出一个需要工具的请求，如“今天北京天气怎么样？” <strong>LLM分析</strong>：LLM不会直接回答，而是分析请求，然后<strong>从“工具清单”中选择最合适的工具</strong>（如 <code>get_weather(location)</code>）。 <strong>输出调用指令</strong>：LLM<strong>不执行</strong>，而是<strong>返回一个结构化的调用请求</strong>，如 <code>{&quot;name&quot;: &quot;get_weather&quot;, &quot;arguments&quot;: {&quot;location&quot;: &quot;北京&quot;}}</code>。 <strong>程序执行</strong>：你的外部程序收到这个结构化请求，<strong>代为执行</strong>真正的函数调用（比如调用天气API）。 <strong>返回结果</strong>：将执行结果（如<code>{&quot;city&quot;: &quot;北京&quot;, &quot;temperature&quot;: &quot;25°C&quot;}</code>）再交回给LLM。 <strong>LLM组织回答</strong>：LLM将API返回的原始数据组织成自然语言回答用户：“今天北京天气晴朗，气温25摄氏度。” <strong>本质</strong>：一个<strong>决策-执行</strong>的<strong>单次回合</strong>。LLM负责“思考”该用什么工具、传入什么参数，外部系统负责“执行”。</li><li><strong>ReAct（Reasoning and Acting）模式是怎么让交互更进一步的？</strong> <strong>比喻</strong>：Function Calling 是LLM下达一个命令。而ReAct是LLM在<strong>模拟一个人解决复杂问题的完整思考过程</strong>，这个过程可能包含多个“思考-行动-观察”的循环。 <strong>工作流程</strong>：对于复杂问题（如“我们公司今年销售额最高的产品是什么，它的主要客户画像是什么？”）： <strong>Reason（思考）</strong>：LLM会<strong>先产生一段内部推理</strong>，例如：“要回答这个问题，我需要两步。首先，需要查询数据库找到销售额最高的产品ID。然后，再根据这个产品ID去查询客户画像数据。” <strong>Act（行动）</strong>：根据推理，LLM决定下一步行动，比如调用 <code>query_database(sql=&quot;SELECT ...&quot;)</code>函数。这一步类似Function Calling。 <strong>Observe（观察）</strong>：外部系统执行函数，返回结果（如产品ID是<code>P-1001</code>）。这个结果被反馈给LLM。 <strong>循环</strong>：LLM接收到观察结果，<strong>再次进行Reasoning</strong>：“好的，我已经拿到了产品ID是P-1001。接下来，我需要查询客户表…” 然后再次 <strong>Act</strong>，调用另一个函数… <strong>本质</strong>：一个<strong>多步推理的循环框架</strong>。它通过强制LLM展示“思维链”，使其规划能力更强，更能处理需要多步骤工具调用的复杂任务。</li></ul><h3 id="总结：你的学习路径图"><a href="#总结：你的学习路径图" class="headerlink" title="总结：你的学习路径图"></a><strong>总结：你的学习路径图</strong></h3><ol><li><strong>从Embedding开始</strong>：理解一切是如何从“将信息转化为语义空间坐标”开始的。</li><li><strong>学习向量数据库和相似度计算</strong>：理解如何在这个空间里进行高效、精准的检索。这是RAG的基石。</li><li><strong>深入理解RAG</strong>：掌握如何通过检索外部知识来增强LLM，解决其核心痛点。</li><li><strong>学习Function Calling</strong>：理解LLM与外部工具交互的基本单元。</li><li><strong>最终掌握ReAct模式</strong>：理解如何利用LLM的推理能力，串联多个Function Calling来解决复杂问题。</li></ol><p>这条路线清晰地展示了现代LLM应用是如何一步步被构建起来的：<strong>从静态的知识检索（RAG），到动态的工具使用（Function Calling），再到复杂的任务分解与规划（ReAct）</strong>。祝你学习顺利！</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI-Agent </tag>
            
            <tag> LLM </tag>
            
            <tag> RAG </tag>
            
            <tag> Function-Calling </tag>
            
            <tag> ReAct </tag>
            
            <tag> Embedding </tag>
            
            <tag> 向量数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MCP（Model Context Protocol）详解</title>
      <link href="/posts/27915.html"/>
      <url>/posts/27915.html</url>
      
        <content type="html"><![CDATA[<h2 id="What-is-the-MCP"><a href="#What-is-the-MCP" class="headerlink" title="What is the MCP?"></a>What is the MCP?</h2><ul><li>MCP (Model Context Protocol) is an <strong>open-source standard</strong> for connecting AI applications to external systems.</li><li>Using MCP, AI applications like Claude or ChatGPT can connect to <strong>data sources</strong> (e.g. local files, databases), <strong>tools</strong> (e.g. search engines, calculators) and <strong>workflows</strong> (e.g. specialized prompts)—enabling them to access key information and perform tasks.</li><li>Think of MCP like a USB-C port for AI applications. Just as USB-C provides a standardized way to connect electronic devices, MCP provides a standardized way to connect AI applications to external systems.</li></ul><p><img src="https://mintcdn.com/mcp/bEUxYpZqie0DsluH/images/mcp-simple-diagram.png?fit=max&auto=format&n=bEUxYpZqie0DsluH&q=85&s=35268aa0ad50b8c385913810e7604550" alt="img"></p><h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><p>Key participants in the MCP architecture are:</p><ul><li><strong>MCP Host</strong>: The AI application that coordinates and manages one or multiple MCP clients</li><li><strong>MCP Client</strong>: A component that maintains a connection to an MCP server and obtains context from an MCP server for the MCP host to use</li><li><strong>MCP Server</strong>: A program that provides context to MCP clients</li></ul><p><img src="/../Pics/WX20251124-172727@2x.png" alt="img"></p><h4 id="Data-Layer"><a href="#Data-Layer" class="headerlink" title="Data Layer"></a>Data Layer</h4><p>Defines the <a href="https://en.wikipedia.org/wiki/JSON-RPC#Implementations"><strong>JSON-RPC</strong></a> based protocol for client-server communication, including lifecycle management, and core primitives, such as tools, resources, prompts and notifications.</p><p>Core Primitives:</p><ul><li><strong>Tools</strong>: Executable functions that AI applications can invoke to perform actions (e.g., file operations, API calls, database queries)</li><li><strong>Resources</strong>: Data sources that provide contextual information to AI applications (e.g., file contents, database records, API responses)</li><li><strong>Prompts</strong>: Reusable templates that help structure interactions with language models (e.g., system prompts, few-shot examples)</li></ul><h4 id="Transport-Layer"><a href="#Transport-Layer" class="headerlink" title="Transport Layer"></a>Transport Layer</h4><p>Defines the communication mechanisms and channels that enable data exchange between clients and servers, including transport-specific connection establishment, message framing, and authorization.</p><ul><li><strong>STDIO</strong> : Uses standard input&#x2F;output streams for direct process communication between <strong>local processes</strong> on the same machine, providing optimal performance with no network overhead.</li><li><strong>Server-Sent Events (SSE)</strong> : This approach required two separate endpoints:<ol><li>An SSE endpoint (<code>/sse</code>) that established a persistent connection for the client to receive responses</li><li>A separate messages endpoint (<code>/sse/messages</code>) where clients would send request</li></ol></li><li><strong>Streamable HTTP</strong> : Offers a more elegant solution by enabling <strong>bidirectional communication through a single endpoint</strong>.</li></ul><p><img src="https://picx.zhimg.com/50/v2-987260a35809fece3edb804df7691c0a_720w.jpg?source=2c26e567" alt="img"></p><h2 id="Develop-a-MCP-Server"><a href="#Develop-a-MCP-Server" class="headerlink" title="Develop a MCP Server"></a>Develop a MCP Server</h2><ol><li>Integrate MCP SDK</li><li>Develop tools&#x2F;resources&#x2F;prompts as your business needs</li><li>Debug it with MCP Inspector</li></ol>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MCP </tag>
            
            <tag> Model Context Protocol </tag>
            
            <tag> AI </tag>
            
            <tag> Claude </tag>
            
            <tag> 协议标准 </tag>
            
            <tag> 开发指南 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objective-C 面向对象编程详解</title>
      <link href="/posts/57222.html"/>
      <url>/posts/57222.html</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h3 id="1-Category（分类）"><a href="#1-Category（分类）" class="headerlink" title="1. Category（分类）"></a>1. <strong>Category（分类）</strong></h3><p><strong>Category</strong> 是 Objective-C 中用于扩展已有类功能的一种机制，无需继承即可为类添加方法。它的主要用途是增强类的功能或将类的实现分模块组织。</p><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li><strong>无需子类化</strong>：可以在不修改原始类源码的情况下，为类添加新的方法。</li><li><strong>动态扩展</strong>：Category 在运行时动态地将方法添加到类中。</li><li><strong>模块化开发</strong>：可以将类的功能拆分成多个文件，便于团队协作或代码管理。</li><li><strong>限制</strong>：<ul><li>不能添加实例变量，只能添加方法。</li><li>如果 Category 中定义的方法与原始类或另一个 Category 中的方法同名，会覆盖原始方法（可能导致不可预测的行为）。</li><li>不能直接访问原始类的私有方法或变量。</li></ul></li></ul><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> 原类名 (<span class="title">CategoryName</span>)</span></span><br><span class="line"><span class="comment">// 声明新方法</span></span><br><span class="line">- (<span class="type">void</span>)newMethod;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> 原类名 (<span class="title">CategoryName</span>)</span></span><br><span class="line"><span class="comment">// 实现新方法</span></span><br><span class="line">- (<span class="type">void</span>)newMethod &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;This is a new method added by Category.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><ol><li><p><strong>扩展系统类</strong>：例如，为 <code>NSString</code> 添加一个自定义方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSString</span> (<span class="title">MyExtension</span>)</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)reverseString;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSString</span> (<span class="title">MyExtension</span>)</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)reverseString &#123;</span><br><span class="line">    <span class="built_in">NSMutableString</span> *reversed = [<span class="built_in">NSMutableString</span> stringWithCapacity:<span class="keyword">self</span>.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="keyword">self</span>.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        [reversed appendString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%C&quot;</span>, [<span class="keyword">self</span> characterAtIndex:i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reversed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [str reverseString]); <span class="comment">// 输出: olleH</span></span><br></pre></td></tr></table></figure></li><li><p><strong>代码组织</strong>：将大类的实现分成多个 Category，增强可读性和维护性。例如，<code>UIViewController</code> 可以按功能分为 <code>DataHandling</code> 和 <code>UIConfiguration</code> 两个 Category。</p></li><li><p><strong>修复或增强功能</strong>：在不修改第三方库的情况下，为其类添加功能。</p></li></ol><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ul><li><strong>方法冲突</strong>：如果多个 Category 或原始类定义了同名方法，运行时会选择其中一个（不可预测），应避免命名冲突。</li><li><strong>调试困难</strong>：Category 的方法覆盖可能导致调试复杂。</li><li><strong>最佳实践</strong>：为避免冲突，建议在方法名中加入前缀（如 <code>my_reverseString</code>）。</li></ul><hr><h3 id="2-Protocol（协议）"><a href="#2-Protocol（协议）" class="headerlink" title="2. Protocol（协议）"></a>2. <strong>Protocol（协议）</strong></h3><p><strong>Protocol</strong> 是 Objective-C 中定义一组方法规范的机制，类似于接口（interface）。它用于声明一组方法，供类实现，以保证类具有特定行为。</p><h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><ul><li><strong>抽象性</strong>：Protocol 仅定义方法签名，不提供实现。</li><li><strong>多类共享</strong>：多个类可以实现同一个 Protocol，实现代码共享或行为一致性。</li><li><strong>可选与必须</strong>：方法可以标记为 <code>@required</code>（默认，必须实现）或 <code>@optional</code>（可选实现）。</li><li><strong>类型检查</strong>：编译器可以检查类是否遵循某个 Protocol。</li></ul><h4 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">MyProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="comment">// 必须实现的方法</span></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line">- (<span class="type">void</span>)requiredMethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选实现的方法</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="type">void</span>)optionalMethod;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> &lt;<span class="title">MyProtocol</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line">- (<span class="type">void</span>)requiredMethod &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Required method implemented.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a>应用场景：</h4><ol><li><p><strong>委托模式（Delegate）</strong>：最常见的用途，例如 <code>UITableViewDelegate</code> 和 <code>UITableViewDataSource</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">MyDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line">- (<span class="type">void</span>)didCompleteTask;</span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="type">void</span>)progressUpdated:(<span class="type">float</span>)progress;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="type">id</span>&lt;MyDelegate&gt; delegate;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></li><li><p><strong>接口定义</strong>：定义一组标准接口，供不同类实现。例如，多个视图控制器实现同一个数据处理协议。</p></li><li><p><strong>类型安全</strong>：通过 Protocol 限制对象类型，确保对象支持特定方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span>&lt;MyProtocol&gt; obj = [[MyClass alloc] init];</span><br><span class="line">[obj requiredMethod]; <span class="comment">// 编译器确保方法存在</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a>注意事项：</h4><ul><li><strong>NSObject 协议</strong>：通常 Protocol 会继承 <code>&lt;NSObject&gt;</code> 协议，以确保对象支持基本方法（如 <code>respondsToSelector:</code>）。</li><li><strong>动态检查</strong>：使用 <code>conformsToProtocol:</code> 和 <code>respondsToSelector:</code> 检查对象是否遵循协议或实现某方法： <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([obj conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">MyProtocol</span>)]) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ([obj respondsToSelector:<span class="keyword">@selector</span>(optionalMethod)]) &#123;</span><br><span class="line">        [obj optionalMethod];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-Extension（类扩展）"><a href="#3-Extension（类扩展）" class="headerlink" title="3 Extension（类扩展）"></a>3 <strong>Extension（类扩展）</strong></h3><ul><li><strong>定义</strong>：类扩展是匿名的 Category，通常用于在类的实现文件中声明私有方法或属性。</li><li><strong>特点</strong>：<ul><li>可以在 <code>.m</code> 文件中声明私有方法或属性。</li><li>可以添加实例变量（与 Category 不同）。</li><li>仅在当前类实现文件可见，外部无法访问。</li></ul></li><li><strong>语法</strong>：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *privateProperty;</span><br><span class="line">- (<span class="type">void</span>)privateMethod;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line">- (<span class="type">void</span>)privateMethod &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;This is a private method.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></li><li><strong>用途</strong>：隐藏实现细节，声明私有接口，或为只读属性添加私有读写支持。</li></ul><h3 id="4-Dynamic-Runtime（运行时动态性）"><a href="#4-Dynamic-Runtime（运行时动态性）" class="headerlink" title="4  Dynamic Runtime（运行时动态性）"></a>4  <strong>Dynamic Runtime（运行时动态性）</strong></h3><ul><li>Objective-C 的运行时系统提供了强大的动态特性，支持以下功能：<ul><li><strong>方法交换（Method Swizzling）</strong>：在运行时替换方法实现，常用于调试或修改系统类行为。</li><li><strong>动态添加方法</strong>：通过 <code>class_addMethod</code> 动态为类添加方法。</li><li><strong>关联对象（Associated Objects）</strong>：通过 <code>objc_setAssociatedObject</code> 为 Category 添加“伪属性”。</li><li><strong>示例</strong>（添加关联对象）：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">MyCategory</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *associatedString;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">MyCategory</span>)</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">char</span> kAssociatedStringKey;</span><br><span class="line">- (<span class="type">void</span>)setAssociatedString:(<span class="built_in">NSString</span> *)string &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;kAssociatedStringKey, string, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSString</span> *)associatedString &#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, &amp;kAssociatedStringKey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></li><li><strong>用途</strong>：增强 Category 功能，实现动态行为修改。</li></ul></li></ul><hr><h3 id="5-Category-vs-Protocol-vs-其他方案对比"><a href="#5-Category-vs-Protocol-vs-其他方案对比" class="headerlink" title="5. Category vs Protocol vs 其他方案对比"></a>5. <strong>Category vs Protocol vs 其他方案对比</strong></h3><table><thead><tr><th>特性&#x2F;机制</th><th>Category</th><th>Protocol</th><th>Extension</th><th>Block</th></tr></thead><tbody><tr><td><strong>用途</strong></td><td>扩展类方法</td><td>定义接口规范</td><td>声明私有方法&#x2F;属性</td><td>回调和函数式编程</td></tr><tr><td><strong>添加实例变量</strong></td><td>否（可通过关联对象实现）</td><td>否</td><td>是</td><td>否</td></tr><tr><td><strong>代码复用</strong></td><td>高（直接扩展类）</td><td>中（需实现）</td><td>低（仅限当前类）</td><td>高（独立逻辑）</td></tr><tr><td><strong>动态性</strong></td><td>高（运行时添加方法）</td><td>中（运行时检查方法）</td><td>低（编译时确定）</td><td>高（捕获上下文）</td></tr><tr><td><strong>典型场景</strong></td><td>系统类扩展、代码模块化</td><td>委托模式、接口定义</td><td>私有接口、属性扩展</td><td>异步回调、事件处理</td></tr></tbody></table><hr><h3 id="6-总结与建议"><a href="#6-总结与建议" class="headerlink" title="6. 总结与建议"></a>6. <strong>总结与建议</strong></h3><ul><li><strong>Category</strong> 适合快速扩展类功能，特别是为系统类或第三方库添加方法，但需注意方法冲突。</li><li><strong>Protocol</strong> 适合定义标准接口，确保类行为一致，广泛用于委托模式。</li><li><strong>Extension</strong> 用于私有接口，适合隐藏实现细节。</li><li><strong>Block</strong> 提供轻量级回调，适合异步任务。</li><li><strong>运行时动态性</strong> 提供了强大的灵活性，但需谨慎使用以避免复杂性。</li></ul><p>根据具体需求选择合适的方案：</p><ul><li>如果需要扩展现有类，使用 <strong>Category</strong>。</li><li>如果需要定义行为规范，使用 <strong>Protocol</strong>。</li><li>如果需要私有方法或属性，使用 <strong>Extension</strong>。</li><li>如果需要动态或回调逻辑，考虑 <strong>Block</strong> 或 <strong>运行时特性</strong>。</li></ul><p>如需更具体示例或深入探讨某一机制，请告诉我！</p><h1 id="NSURL"><a href="#NSURL" class="headerlink" title="NSURL"></a>NSURL</h1><h2 id="NSURLProtocol"><a href="#NSURLProtocol" class="headerlink" title="NSURLProtocol"></a>NSURLProtocol</h2><p>In the context of <code>WKWebView</code>, requests are generally <strong>not</strong> handled by <code>NSURLProtocol</code>, especially for custom schemes or even for <code>http/https</code> in most cases. Apple restricts <code>NSURLProtocol</code> usage in <code>WKWebView</code> for security and performance reasons.</p><p><strong>However, requests can be handled by <code>NSURLProtocol</code> in these scenarios:</strong></p><ul><li>When using <code>NSURLConnection</code> or <code>NSURLSession</code> <strong>outside</strong> of <code>WKWebView</code>, and you register a custom <code>NSURLProtocol</code> class, all matching requests (e.g., <code>http</code>, <code>https</code>, or custom schemes if registered) will be intercepted by your protocol handler.</li><li>In <code>UIWebView</code> (deprecated), <code>NSURLProtocol</code> can intercept requests.</li><li>In <code>WKWebView</code>, only if you use a custom <code>NSURLSession</code> (not the web view’s internal networking), and you register a protocol class on that session’s configuration, then requests made by that session (not the web view) can be intercepted.</li></ul><p><strong>Summary:</strong><br>In <code>WKWebView</code>, requests are not forwarded to <code>NSURLProtocol</code>. Only network requests made by your own <code>NSURLSession</code> or <code>NSURLConnection</code> (outside of <code>WKWebView</code>) can be intercepted by <code>NSURLProtocol</code>.</p><hr><h2 id="WKURLSchemeHandler"><a href="#WKURLSchemeHandler" class="headerlink" title="WKURLSchemeHandler"></a>WKURLSchemeHandler</h2><ul><li><p>拦截处理自定义 scheme（非 https&#x2F;http） </p><blockquote><p>通过实现WKURLSchemeHandler protocol，可以拦截和处理 WKWebView 发起的特定 scheme（如 http&#x2F;https 以外的自定义协议）请求，实现自定义的网络请求逻辑</p></blockquote></li><li><p>apple 推荐的官方协议，用来处理自定义的 scheme</p></li><li><p><strong><code> https/http</code> 请求无法在 wkwebview 中被拦截处理</strong></p></li><li><p>WKWebview 不支持使用<code>NSURLProtocol</code>来拦截请求，forward 到<code>NSURLSession</code>是官方推荐可信任的做法</p></li></ul><hr><h2 id="NSURLSessionDelegate"><a href="#NSURLSessionDelegate" class="headerlink" title="NSURLSessionDelegate"></a>NSURLSessionDelegate</h2><ul><li><code>WKURLSchemeHandler</code> 拦截的请求，会被转发到<code>NSURLSession</code>， 并通过 NSURLSessionDelegate 进行处理。</li></ul><h1 id="UIViewController"><a href="#UIViewController" class="headerlink" title="UIViewController"></a>UIViewController</h1><p>UIViewController的生命周期函数介绍：</p><h2 id="主要生命周期方法"><a href="#主要生命周期方法" class="headerlink" title="主要生命周期方法"></a>主要生命周期方法</h2><h3 id="1-viewDidLoad"><a href="#1-viewDidLoad" class="headerlink" title="1. viewDidLoad"></a>1. <code>viewDidLoad</code></h3><ul><li><strong>调用时机</strong>：视图控制器的视图层次结构加载到内存中后调用</li><li><strong>用途</strong>：进行一次性初始化，如创建UI元素、设置初始状态</li><li><strong>特点</strong>：只调用一次</li></ul><h3 id="2-viewWillAppear"><a href="#2-viewWillAppear" class="headerlink" title="2. viewWillAppear:"></a>2. <code>viewWillAppear:</code></h3><ul><li><strong>调用时机</strong>：视图即将显示前调用</li><li><strong>用途</strong>：准备显示视图，如刷新数据、重置UI状态</li><li><strong>特点</strong>：每次视图显示前都会调用</li></ul><h3 id="3-viewDidAppear"><a href="#3-viewDidAppear" class="headerlink" title="3. viewDidAppear:"></a>3. <code>viewDidAppear:</code></h3><ul><li><strong>调用时机</strong>：视图已经显示后调用</li><li><strong>用途</strong>：启动动画、开始定时器、注册通知等</li><li><strong>特点</strong>：每次视图显示后都会调用</li></ul><h3 id="4-viewWillDisappear"><a href="#4-viewWillDisappear" class="headerlink" title="4. viewWillDisappear:"></a>4. <code>viewWillDisappear:</code></h3><ul><li><strong>调用时机</strong>：视图即将消失前调用</li><li><strong>用途</strong>：保存数据、暂停操作、验证输入等</li><li><strong>特点</strong>：每次视图消失前都会调用</li></ul><h3 id="5-viewDidDisappear"><a href="#5-viewDidDisappear" class="headerlink" title="5. viewDidDisappear:"></a>5. <code>viewDidDisappear:</code></h3><ul><li><strong>调用时机</strong>：视图已经消失后调用</li><li><strong>用途</strong>：停止定时器、取消网络请求、清理资源等</li><li><strong>特点</strong>：每次视图消失后都会调用</li></ul><h3 id="6-viewDidUnload-iOS-6之前"><a href="#6-viewDidUnload-iOS-6之前" class="headerlink" title="6. viewDidUnload (iOS 6之前)"></a>6. <code>viewDidUnload</code> (iOS 6之前)</h3><ul><li><strong>调用时机</strong>：内存不足时系统卸载视图</li><li><strong>用途</strong>：清理视图相关资源</li><li><strong>特点</strong>：iOS 6后已废弃</li></ul><h2 id="生命周期顺序"><a href="#生命周期顺序" class="headerlink" title="生命周期顺序"></a>生命周期顺序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建 → viewDidLoad → viewWillAppear → viewDidAppear</span><br><span class="line">     ↓</span><br><span class="line">显示中的视图</span><br><span class="line">     ↓</span><br><span class="line">viewWillDisappear → viewDidDisappear → 销毁</span><br></pre></td></tr></table></figure><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul><li><strong>viewDidLoad</strong>：创建UI、设置委托、初始化数据源</li><li><strong>viewWillAppear</strong>：刷新界面数据、重置状态</li><li><strong>viewDidAppear</strong>：开始网络请求、启动动画</li><li><strong>viewWillDisappear</strong>：保存用户输入、暂停活动</li><li><strong>viewDidDisappear</strong>：清理资源、停止后台任务</li></ul><h1 id="UIApplication"><a href="#UIApplication" class="headerlink" title="UIApplication"></a>UIApplication</h1><h2 id="UIViewController-和-UIApplication-的关系"><a href="#UIViewController-和-UIApplication-的关系" class="headerlink" title="UIViewController 和 UIApplication 的关系"></a>UIViewController 和 UIApplication 的关系</h2><h3 id="层次关系"><a href="#层次关系" class="headerlink" title="层次关系"></a>层次关系</h3><ul><li><strong>UIApplication</strong>：应用程序的单例对象，管理整个应用的生命周期</li><li><strong>UIViewController</strong>：管理单个视图的控制器，是UIApplication管理的视图层次结构的一部分</li></ul><h3 id="包含关系"><a href="#包含关系" class="headerlink" title="包含关系"></a>包含关系</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UIApplication</span><br><span class="line">├── UIWindow</span><br><span class="line">    ├── Root UIViewController</span><br><span class="line">        ├── Child UIViewController</span><br><span class="line">        └── Presented UIViewController</span><br></pre></td></tr></table></figure><h2 id="生命周期函数对应关系"><a href="#生命周期函数对应关系" class="headerlink" title="生命周期函数对应关系"></a>生命周期函数对应关系</h2><h3 id="UIApplication-生命周期方法（AppDelegate）"><a href="#UIApplication-生命周期方法（AppDelegate）" class="headerlink" title="UIApplication 生命周期方法（AppDelegate）"></a>UIApplication 生命周期方法（AppDelegate）</h3><h4 id="1-application-didFinishLaunchingWithOptions"><a href="#1-application-didFinishLaunchingWithOptions" class="headerlink" title="1. application:didFinishLaunchingWithOptions:"></a>1. <code>application:didFinishLaunchingWithOptions:</code></h4><ul><li><strong>对应UIViewController</strong>：在root view controller的<code>viewDidLoad</code>之前调用</li><li><strong>关系</strong>：应用启动完成 → 创建window和root view controller</li></ul><h4 id="2-applicationDidBecomeActive"><a href="#2-applicationDidBecomeActive" class="headerlink" title="2. applicationDidBecomeActive:"></a>2. <code>applicationDidBecomeActive:</code></h4><ul><li><strong>对应UIViewController</strong>：当前可见view controller的<code>viewWillAppear:</code>和<code>viewDidAppear:</code></li><li><strong>关系</strong>：应用变为活跃状态 → 视图控制器开始显示</li></ul><h4 id="3-applicationWillResignActive"><a href="#3-applicationWillResignActive" class="headerlink" title="3. applicationWillResignActive:"></a>3. <code>applicationWillResignActive:</code></h4><ul><li><strong>对应UIViewController</strong>：当前可见view controller的<code>viewWillDisappear:</code></li><li><strong>关系</strong>：应用即将失去焦点 → 视图即将不可交互</li></ul><h4 id="4-applicationDidEnterBackground"><a href="#4-applicationDidEnterBackground" class="headerlink" title="4. applicationDidEnterBackground:"></a>4. <code>applicationDidEnterBackground:</code></h4><ul><li><strong>对应UIViewController</strong>：当前可见view controller的<code>viewDidDisappear:</code></li><li><strong>关系</strong>：应用进入后台 → 视图完全不可见</li></ul><h4 id="5-applicationWillEnterForeground"><a href="#5-applicationWillEnterForeground" class="headerlink" title="5. applicationWillEnterForeground:"></a>5. <code>applicationWillEnterForeground:</code></h4><ul><li><strong>对应UIViewController</strong>：即将显示的view controller的<code>viewWillAppear:</code></li><li><strong>关系</strong>：应用即将回到前台 → 视图即将重新显示</li></ul><h4 id="6-applicationWillTerminate"><a href="#6-applicationWillTerminate" class="headerlink" title="6. applicationWillTerminate:"></a>6. <code>applicationWillTerminate:</code></h4><ul><li><strong>对应UIViewController</strong>：所有view controller的清理工作</li><li><strong>关系</strong>：应用即将终止 → 所有视图控制器被销毁</li></ul><h2 id="调用顺序示例"><a href="#调用顺序示例" class="headerlink" title="调用顺序示例"></a>调用顺序示例</h2><h3 id="应用启动"><a href="#应用启动" class="headerlink" title="应用启动"></a>应用启动</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. application:didFinishLaunchingWithOptions:</span><br><span class="line">2. viewDidLoad (root ViewController)</span><br><span class="line">3. viewWillAppear: (root ViewController) </span><br><span class="line">4. applicationDidBecomeActive:</span><br><span class="line">5. viewDidAppear: (root ViewController)</span><br></pre></td></tr></table></figure><h3 id="应用进入后台"><a href="#应用进入后台" class="headerlink" title="应用进入后台"></a>应用进入后台</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. applicationWillResignActive:</span><br><span class="line">2. viewWillDisappear: (current ViewController)</span><br><span class="line">3. applicationDidEnterBackground:</span><br><span class="line">4. viewDidDisappear: (current ViewController)</span><br></pre></td></tr></table></figure><h3 id="应用回到前台"><a href="#应用回到前台" class="headerlink" title="应用回到前台"></a>应用回到前台</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. applicationWillEnterForeground:</span><br><span class="line">2. viewWillAppear: (current ViewController)</span><br><span class="line">3. applicationDidBecomeActive:</span><br><span class="line">4. viewDidAppear: (current ViewController)</span><br></pre></td></tr></table></figure><h2 id="实际应用建议"><a href="#实际应用建议" class="headerlink" title="实际应用建议"></a>实际应用建议</h2><ul><li><strong>UIApplication级别</strong>：处理全局状态、推送通知、应用级别的数据保存</li><li><strong>UIViewController级别</strong>：处理界面相关的逻辑、用户交互、视图状态管理</li><li><strong>协调使用</strong>：在AppDelegate中可以通知当前的view controller应用状态变化</li></ul>]]></content>
      
      
      <categories>
          
          <category> 移动开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
            <tag> iOS </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> Category </tag>
            
            <tag> Protocol </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代身份认证与授权技术完全指南 - OAuth、JWT、SAML 等协议详解</title>
      <link href="/posts/64545.html"/>
      <url>/posts/64545.html</url>
      
        <content type="html"><![CDATA[<h1 id="认证和授权完全指南"><a href="#认证和授权完全指南" class="headerlink" title="认证和授权完全指南"></a>认证和授权完全指南</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在现代网络安全体系中，<strong>认证（Authentication）</strong> 和 <strong>授权（Authorization）</strong> 是保障系统安全的两大核心机制：</p><ul><li><strong>认证</strong>：验证用户身份（”你是谁？”）</li><li><strong>授权</strong>：确认访问权限（”你能做什么？”）</li></ul><p>本文将从协议和Token两个维度，系统性阐述认证授权的技术体系。</p><hr><h2 id="一、认证授权协议体系"><a href="#一、认证授权协议体系" class="headerlink" title="一、认证授权协议体系"></a>一、认证授权协议体系</h2><h3 id="1-OAuth-2-0-授权标准协议"><a href="#1-OAuth-2-0-授权标准协议" class="headerlink" title="1. OAuth 2.0 - 授权标准协议"></a>1. OAuth 2.0 - 授权标准协议</h3><p><strong>OAuth 2.0</strong> 是现代互联网授权的基石，专注于<strong>授权</strong>（资源访问权限的委派），而非直接处理用户身份认证。</p><h4 id="核心角色"><a href="#核心角色" class="headerlink" title="核心角色"></a>核心角色</h4><table><thead><tr><th>角色</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>资源所有者（Resource Owner）</td><td>拥有资源的用户</td><td>微信用户</td></tr><tr><td>客户端（Client）</td><td>请求访问资源的应用</td><td>第三方小程序</td></tr><tr><td>授权服务器（Authorization Server）</td><td>颁发Token的服务</td><td>微信授权服务器</td></tr><tr><td>资源服务器（Resource Server）</td><td>存储受保护资源的服务</td><td>微信用户信息API</td></tr></tbody></table><h4 id="四种授权模式"><a href="#四种授权模式" class="headerlink" title="四种授权模式"></a>四种授权模式</h4><ol><li><p><strong>授权码模式（Authorization Code）</strong></p><ul><li><strong>适用场景</strong>：Web应用（服务端安全）</li><li><strong>安全性</strong>：最高，推荐使用</li><li><strong>流程</strong>：用户授权 → 获取授权码 → 后端交换Token</li></ul></li><li><p><strong>隐式模式（Implicit）</strong></p><ul><li><strong>适用场景</strong>：SPA或原生App（客户端不安全）</li><li><strong>注意</strong>：OAuth 2.1已废弃，建议使用PKCE</li></ul></li><li><p><strong>密码模式（Resource Owner Password Credentials）</strong></p><ul><li><strong>适用场景</strong>：高度信任的客户端</li><li><strong>风险</strong>：直接暴露用户密码</li></ul></li><li><p><strong>客户端凭证模式（Client Credentials）</strong></p><ul><li><strong>适用场景</strong>：服务端间通信（无用户参与）</li><li><strong>特点</strong>：机器对机器的授权</li></ul></li></ol><h4 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h4><ul><li>第三方登录（微信、QQ、GitHub登录）</li><li>API访问控制</li><li>移动应用授权</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/OAuth.webp" alt="img"></p><h3 id="2-OpenID-Connect-OIDC-身份认证层"><a href="#2-OpenID-Connect-OIDC-身份认证层" class="headerlink" title="2. OpenID Connect (OIDC) - 身份认证层"></a>2. OpenID Connect (OIDC) - 身份认证层</h3><p><strong>OpenID Connect</strong> 在OAuth 2.0基础上扩展，专门解决<strong>身份认证</strong>问题，是OAuth 2.0 + 身份认证的完整解决方案。</p><h4 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h4><ul><li><strong>ID Token</strong>：JWT格式，包含用户身份信息（如姓名、邮箱、用户ID）</li><li><strong>UserInfo端点</strong>：通过Access Token获取用户详细信息</li><li><strong>标准化声明</strong>：定义了标准的用户属性字段</li></ul><h4 id="OIDC-流程"><a href="#OIDC-流程" class="headerlink" title="OIDC 流程"></a>OIDC 流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 用户访问客户端应用</span><br><span class="line">2. 重定向到OIDC提供商进行认证</span><br><span class="line">3. 用户授权后返回授权码</span><br><span class="line">4. 客户端交换授权码获取Token</span><br><span class="line">5. 返回Access Token + ID Token</span><br><span class="line">6. 通过UserInfo端点获取用户信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/OIDC.webp" alt="img"></p><h4 id="典型应用场景-1"><a href="#典型应用场景-1" class="headerlink" title="典型应用场景"></a>典型应用场景</h4><ul><li><strong>企业SSO</strong>：使用Google Workspace登录企业应用</li><li><strong>消费级SSO</strong>：使用Apple ID登录第三方应用</li><li><strong>跨域认证</strong>：多个子域名系统的统一登录</li></ul><h3 id="3-SAML-2-0-企业级身份联邦"><a href="#3-SAML-2-0-企业级身份联邦" class="headerlink" title="3. SAML 2.0 - 企业级身份联邦"></a>3. SAML 2.0 - 企业级身份联邦</h3><p><strong>SAML 2.0</strong> 是企业级<strong>认证与授权</strong>标准，基于XML实现跨域单点登录，在企业环境中广泛部署。</p><h4 id="核心架构"><a href="#核心架构" class="headerlink" title="核心架构"></a>核心架构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Identity Provider (IdP) ←→ Service Provider (SP)</span><br><span class="line">      ↓                           ↓</span><br><span class="line">   用户认证                    资源访问</span><br></pre></td></tr></table></figure><h4 id="关键组件"><a href="#关键组件" class="headerlink" title="关键组件"></a>关键组件</h4><ul><li><strong>断言（Assertion）</strong>：XML格式的安全声明，包含用户身份和权限信息</li><li><strong>身份提供者（IdP）</strong>：认证用户并生成SAML断言（如企业AD）</li><li><strong>服务提供者（SP）</strong>：依赖IdP的断言提供服务访问（如SaaS应用）</li></ul><h4 id="SAML-SSO-流程"><a href="#SAML-SSO-流程" class="headerlink" title="SAML SSO 流程"></a>SAML SSO 流程</h4><ol><li>用户访问SP应用</li><li>SP重定向到企业IdP</li><li>IdP验证用户身份</li><li>生成SAML断言并返回SP</li><li>SP验证断言并授权访问</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/SAML.webp" alt="img"></p><h4 id="企业应用场景"><a href="#企业应用场景" class="headerlink" title="企业应用场景"></a>企业应用场景</h4><ul><li><strong>Office 365集成</strong>：通过ADFS实现企业SSO</li><li><strong>SaaS应用集成</strong>：Salesforce、ServiceNow等企业应用</li><li><strong>混合云环境</strong>：本地AD与云服务的身份联邦</li></ul><h3 id="4-Kerberos-票据认证协议"><a href="#4-Kerberos-票据认证协议" class="headerlink" title="4. Kerberos - 票据认证协议"></a>4. Kerberos - 票据认证协议</h3><p><strong>Kerberos</strong> 是基于票据的网络认证协议，通过密钥分发中心（KDC）实现安全认证，有效防止中间人攻击。</p><h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><ul><li><strong>KDC（Key Distribution Center）</strong>：密钥分发中心</li><li><strong>TGT（Ticket-Granting Ticket）</strong>：用户首次认证后的长期票据</li><li><strong>服务票据（Service Ticket）</strong>：访问具体服务的临时票据</li></ul><h4 id="Kerberos-认证流程"><a href="#Kerberos-认证流程" class="headerlink" title="Kerberos 认证流程"></a>Kerberos 认证流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Client → AS (Authentication Server): AS_REQ</span><br><span class="line">AS → Client: AS_REP (TGT)</span><br><span class="line">Client → TGS (Ticket-Granting Server): TGS_REQ (TGT)</span><br><span class="line">TGS → Client: TGS_REP (Service Ticket)</span><br><span class="line">Client → Service: AP_REQ (Service Ticket)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/Kerberos.webp" alt="img"></p><h3 id="5-LDAP-目录服务协议"><a href="#5-LDAP-目录服务协议" class="headerlink" title="5. LDAP - 目录服务协议"></a>5. LDAP - 目录服务协议</h3><p><strong>LDAP（Lightweight Directory Access Protocol）</strong> 是访问和维护目录服务的标准协议，主要用于用户和组织信息的查询与管理。</p><h4 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h4><ul><li><strong>目录查询</strong>：用户、组织架构、权限信息查询</li><li><strong>身份验证</strong>：用户名密码验证</li><li><strong>属性管理</strong>：用户属性的增删改查</li></ul><h4 id="常见实现"><a href="#常见实现" class="headerlink" title="常见实现"></a>常见实现</h4><ul><li><strong>Microsoft Active Directory (AD)</strong>：Windows域环境的标准</li><li><strong>OpenLDAP</strong>：开源LDAP实现</li><li><strong>Apache Directory Server</strong>：Java实现的LDAP服务</li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>企业内部用户认证（VPN、邮箱、OA系统）</li><li>组织架构管理</li><li>权限控制和用户属性查询</li></ul><h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><ol><li><strong>安全性差：</strong> LDAP 主要是为受信任的内网设计的。虽然有 LDAPS (SSL)，但在公网暴露 LDAP 端口是非常危险的行为。</li><li><strong>Web 不友好：</strong> LDAP 是基于 TCP 的长连接二进制协议，不是 HTTP。浏览器里的 JavaScript 根本没法直接发 LDAP 请求。</li><li><strong>没有 Token 概念：</strong> LDAP 验证完就是验证完了，它不会给你发一个“令牌”让你去访问其他 API。而 OAuth&#x2F;OIDC 的核心就是那个 Token，可以在微服务之间传递。</li><li><strong>标准化不足：</strong> 虽然 LDAP 是标准，但不同厂商（AD vs OpenLDAP）的 Schema（字段定义）差异很大。OIDC&#x2F;SAML 在这方面屏蔽了底层差异。</li></ol><h4 id="LDAP-vs-SAML-OIDC-OAuth"><a href="#LDAP-vs-SAML-OIDC-OAuth" class="headerlink" title="LDAP vs. SAML &#x2F; OIDC &#x2F; OAuth"></a>LDAP vs. SAML &#x2F; OIDC &#x2F; OAuth</h4><ul><li><p><strong>本质区别：</strong></p><ul><li><strong>LDAP</strong> 是针对<strong>内网</strong>设计的、基于 TCP 的查询协议。它很古老，不适合在互联网上裸奔（容易被抓包，且防火墙不友好）。</li><li><strong>SAML&#x2F;OIDC</strong> 是基于 <strong>HTTP&#x2F;浏览器</strong> 的。它们是为了解决 LDAP 无法跨域、无法上云的问题而诞生的。</li></ul></li><li><p><strong>配合方式：</strong></p><ul><li>用户在浏览器用 OIDC 登录 -&gt; 请求发给 IdP（如 Keycloak） -&gt; Keycloak 通过 LDAP 协议去问后端的 AD：“密码对不对？” -&gt; AD 说“对” -&gt; Keycloak 签发 OIDC Token 给用户。</li></ul></li></ul><h4 id="LDAP-vs-Kerberos"><a href="#LDAP-vs-Kerberos" class="headerlink" title="LDAP vs. Kerberos"></a>LDAP vs. Kerberos</h4><p>这是一对<strong>焦不离孟的好基友</strong>，特别是在 Windows Active Directory (AD) 环境下。</p><ul><li><strong>关系：</strong><ul><li><strong>LDAP</strong> 负责<strong>查信息</strong>（这个人属于哪个组？他的邮箱是多少？）。</li><li><strong>Kerberos</strong> 负责<strong>验证密码</strong>（票据交换，证明你是你）。</li></ul></li><li><strong>区别：</strong><ul><li>LDAP 也可以验证密码（通过 <code>bind</code> 操作），但在 Windows 域环境中，登录过程主要是 Kerberos 在跑，登录成功后，系统会用 LDAP 去拉取你的个人策略、组信息等。</li><li>Kerberos 极其依赖内网环境和时间同步，<strong>出了局域网就基本废了</strong>，所以它也没法用于互联网 SSO。</li></ul></li></ul><h4 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h4><ul><li><strong>Windows域环境</strong>：AD域的默认认证机制</li><li><strong>Hadoop集群</strong>：大数据平台的安全认证</li><li><strong>企业网络</strong>：内网资源的安全访问</li></ul><h3 id="各协议对比"><a href="#各协议对比" class="headerlink" title="各协议对比"></a>各协议对比</h3><table><thead><tr><th><strong>协议</strong></th><th><strong>角色定位</strong></th><th><strong>典型“对话”内容</strong></th><th><strong>适用范围</strong></th><th><strong>是否存放数据?</strong></th></tr></thead><tbody><tr><td><strong>LDAP</strong></td><td><strong>大管家 (数据库)</strong></td><td>“帮我查下张三的部门” &#x2F; “密码对不对?”</td><td><strong>局域网深处</strong> (后端)</td><td><strong>是</strong> (核心数据源)</td></tr><tr><td><strong>Kerberos</strong></td><td><strong>内网保安</strong></td><td>“这是张三的票据(Ticket)，放行吗?”</td><td><strong>局域网</strong> (Windows域)</td><td>否 (依赖KDC)</td></tr><tr><td><strong>SAML</strong></td><td><strong>企业信使</strong></td><td>“我是IdP，我证明这个XML里的张三已登录”</td><td>互联网 &#x2F; 企业互信</td><td>否</td></tr><tr><td><strong>OIDC</strong></td><td><strong>现代护照</strong></td><td>“这是张三的ID Token(JWT)，你自己看”</td><td>互联网 &#x2F; App &#x2F; SPA</td><td>否</td></tr><tr><td><strong>OAuth</strong></td><td><strong>授权钥匙</strong></td><td>“我有令牌，让我进屋拿照片”</td><td>API 授权</td><td>否</td></tr></tbody></table><pre class="mermaid">graph TD    subgraph "前端应用层 (App / Web)"    A[现代 Web 应用]     B[第三方 SaaS 比如 Salesforce]    end    subgraph "中间件层 (IdP / 认证中心)"    C[SSO 平台 比如 Keycloak, Okta, ADFS]    end    subgraph "后端存储层 (Source of Truth)"    D[LDAP 目录服务 比如 AD, OpenLDAP]    E[SQL 数据库]    end    A -- "OIDC / OAuth" --> C    B -- "SAML" --> C    C -- "LDAP 协议" --> D</pre><hr><h2 id="二、Token技术体系"><a href="#二、Token技术体系" class="headerlink" title="二、Token技术体系"></a>二、Token技术体系</h2><h3 id="1-Access-Token-资源访问凭证"><a href="#1-Access-Token-资源访问凭证" class="headerlink" title="1. Access Token - 资源访问凭证"></a>1. Access Token - 资源访问凭证</h3><p><strong>Access Token</strong> 是客户端访问资源服务器的核心凭证，是OAuth 2.0体系的关键组件。</p><h4 id="Token格式对比"><a href="#Token格式对比" class="headerlink" title="Token格式对比"></a>Token格式对比</h4><table><thead><tr><th>类型</th><th>特点</th><th>验证方式</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>不透明Token</strong></td><td>随机字符串，无法解析</td><td>需调用授权服务器验证</td><td>高安全要求的企业环境</td></tr><tr><td><strong>JWT Token</strong></td><td>自包含，可本地解析</td><td>本地验证签名</td><td>微服务、分布式系统</td></tr></tbody></table><h4 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h4><ul><li><strong>短期有效</strong>：通常1小时内过期</li><li><strong>续期机制</strong>：配合Refresh Token实现自动续期</li><li><strong>撤销能力</strong>：支持主动撤销和黑名单机制</li></ul><h3 id="2-Refresh-Token-令牌续期机制"><a href="#2-Refresh-Token-令牌续期机制" class="headerlink" title="2. Refresh Token - 令牌续期机制"></a>2. Refresh Token - 令牌续期机制</h3><p><strong>Refresh Token</strong> 专门用于在Access Token过期后获取新的Access Token，实现长期会话管理。</p><h4 id="核心特性-1"><a href="#核心特性-1" class="headerlink" title="核心特性"></a>核心特性</h4><ul><li><strong>长期有效性</strong>：7-30天有效期，但可被撤销</li><li><strong>存储限制</strong>：仅在客户端和授权服务器间流转</li><li><strong>单次使用</strong>：使用后立即失效，返回新的Refresh Token（Rotation机制）</li></ul><h4 id="安全要求"><a href="#安全要求" class="headerlink" title="安全要求"></a>安全要求</h4><ul><li><strong>HTTPS传输</strong>：防止网络传输中被截获</li><li><strong>安全存储</strong>：客户端需安全存储（如Keychain、Keystore）</li><li><strong>撤销机制</strong>：支持用户主动撤销或异常检测自动撤销</li></ul><h3 id="3-ID-Token-身份信息载体"><a href="#3-ID-Token-身份信息载体" class="headerlink" title="3. ID Token - 身份信息载体"></a>3. ID Token - 身份信息载体</h3><p><strong>ID Token</strong> 是OpenID Connect的核心组件，以JWT格式承载用户身份信息。</p><h4 id="标准声明（Claims）"><a href="#标准声明（Claims）" class="headerlink" title="标准声明（Claims）"></a>标准声明（Claims）</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;iss&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://accounts.google.com&quot;</span><span class="punctuation">,</span>        <span class="comment">// 发行者</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span>                         <span class="comment">// 用户唯一标识</span></span><br><span class="line">  <span class="attr">&quot;aud&quot;</span><span class="punctuation">:</span> <span class="string">&quot;your-client-id&quot;</span><span class="punctuation">,</span>                     <span class="comment">// 目标客户端</span></span><br><span class="line">  <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1620000000</span><span class="punctuation">,</span>                           <span class="comment">// 过期时间</span></span><br><span class="line">  <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1619996400</span><span class="punctuation">,</span>                           <span class="comment">// 签发时间</span></span><br><span class="line">  <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user@example.com&quot;</span><span class="punctuation">,</span>                 <span class="comment">// 邮箱</span></span><br><span class="line">  <span class="attr">&quot;email_verified&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                      <span class="comment">// 邮箱验证状态</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span>                          <span class="comment">// 姓名</span></span><br><span class="line">  <span class="attr">&quot;picture&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://example.com/avatar.jpg&quot;</span>  <span class="comment">// 头像</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="安全特性"><a href="#安全特性" class="headerlink" title="安全特性"></a>安全特性</h4><ul><li><strong>数字签名</strong>：RS256&#x2F;ES256算法签名，防篡改</li><li><strong>时效性</strong>：短期有效（通常15-60分钟）</li><li><strong>完整性</strong>：包含完整的用户身份信息</li></ul><h3 id="4-JWT-自包含令牌标准"><a href="#4-JWT-自包含令牌标准" class="headerlink" title="4. JWT - 自包含令牌标准"></a>4. JWT - 自包含令牌标准</h3><p><strong>JWT（JSON Web Token）</strong> 是一种开放标准（RFC 7519），用于在各方之间安全地传输信息。</p><h4 id="三段式结构"><a href="#三段式结构" class="headerlink" title="三段式结构"></a>三段式结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Header.Payload.Signature</span><br></pre></td></tr></table></figure><h4 id="详细结构解析"><a href="#详细结构解析" class="headerlink" title="详细结构解析"></a>详细结构解析</h4><p><strong>Header（头部）</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;RS256&quot;</span><span class="punctuation">,</span>    <span class="comment">// 签名算法</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span><span class="punctuation">,</span>      <span class="comment">// 令牌类型</span></span><br><span class="line">  <span class="attr">&quot;kid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;key-id&quot;</span>    <span class="comment">// 密钥标识</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>Payload（负载）</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user123&quot;</span><span class="punctuation">,</span>           <span class="comment">// 主题（用户ID）</span></span><br><span class="line">  <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1646092800</span><span class="punctuation">,</span>          <span class="comment">// 签发时间</span></span><br><span class="line">  <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1646096400</span><span class="punctuation">,</span>          <span class="comment">// 过期时间</span></span><br><span class="line">  <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;read write&quot;</span><span class="punctuation">,</span>      <span class="comment">// 权限范围</span></span><br><span class="line">  <span class="attr">&quot;aud&quot;</span><span class="punctuation">:</span> <span class="string">&quot;api.example.com&quot;</span>    <span class="comment">// 受众</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>Signature（签名）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RSASHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  private_key</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="算法选择指南"><a href="#算法选择指南" class="headerlink" title="算法选择指南"></a>算法选择指南</h4><table><thead><tr><th>算法</th><th>类型</th><th>安全性</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>HS256</strong></td><td>对称加密</td><td>中等</td><td>内部微服务</td></tr><tr><td><strong>RS256</strong></td><td>非对称加密</td><td>高</td><td>跨域认证</td></tr><tr><td><strong>ES256</strong></td><td>椭圆曲线</td><td>高</td><td>移动端应用</td></tr></tbody></table><h4 id="安全注意事项"><a href="#安全注意事项" class="headerlink" title="安全注意事项"></a>安全注意事项</h4><ul><li><strong>密钥管理</strong>：定期轮换签名密钥</li><li><strong>算法验证</strong>：明确指定允许的签名算法</li><li><strong>时效控制</strong>：设置合理的过期时间</li><li><strong>敏感信息</strong>：避免在Payload中包含敏感数据</li></ul><h3 id="5-Session-Token-会话状态管理"><a href="#5-Session-Token-会话状态管理" class="headerlink" title="5. Session Token - 会话状态管理"></a>5. Session Token - 会话状态管理</h3><p><strong>Session Token</strong> 是传统的会话管理机制，通过服务端状态存储维护用户会话。</p><h4 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Client (SessionID) ←→ Server (Session Store)</span><br><span class="line">                           ↓</span><br><span class="line">                    Redis/Database/Memory</span><br></pre></td></tr></table></figure><h4 id="存储策略"><a href="#存储策略" class="headerlink" title="存储策略"></a>存储策略</h4><p><strong>服务端存储</strong></p><ul><li><strong>内存存储</strong>：性能最优，但不支持集群</li><li><strong>Redis集群</strong>：高性能分布式存储</li><li><strong>数据库存储</strong>：持久化但性能较低</li></ul><p><strong>客户端传输</strong></p><ul><li><strong>HTTP Cookie</strong>：自动传输，支持HttpOnly和Secure标志</li><li><strong>LocalStorage</strong>：手动管理，存在XSS风险</li></ul><h4 id="Session-vs-JWT-对比"><a href="#Session-vs-JWT-对比" class="headerlink" title="Session vs JWT 对比"></a>Session vs JWT 对比</h4><table><thead><tr><th>特性</th><th>Session Token</th><th>JWT</th></tr></thead><tbody><tr><td><strong>状态管理</strong></td><td>有状态（服务端存储）</td><td>无状态（自包含）</td></tr><tr><td><strong>扩展性</strong></td><td>需要共享存储</td><td>天然支持分布式</td></tr><tr><td><strong>性能</strong></td><td>需要查库验证</td><td>本地验证</td></tr><tr><td><strong>撤销能力</strong></td><td>立即撤销</td><td>需要黑名单机制</td></tr><tr><td><strong>存储开销</strong></td><td>服务端存储成本</td><td>网络传输成本</td></tr></tbody></table><h3 id="6-SAML-断言-XML安全声明"><a href="#6-SAML-断言-XML安全声明" class="headerlink" title="6. SAML 断言 - XML安全声明"></a>6. SAML 断言 - XML安全声明</h3><p><strong>SAML断言</strong> 是SAML 2.0协议的核心载体，以XML格式承载安全声明信息。</p><h4 id="断言类型"><a href="#断言类型" class="headerlink" title="断言类型"></a>断言类型</h4><p><strong>认证断言（Authentication Assertion）</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">saml:Assertion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">saml:AuthnStatement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">saml:AuthnContext</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">saml:AuthnContextClassRef</span>&gt;</span></span><br><span class="line">        urn:oasis:names:tc:SAML:2.0:ac:classes:Password</span><br><span class="line">      <span class="tag">&lt;/<span class="name">saml:AuthnContextClassRef</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">saml:AuthnContext</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">saml:AuthnStatement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">saml:Assertion</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>属性断言（Attribute Assertion）</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">saml:AttributeStatement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">saml:Attribute</span> <span class="attr">Name</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">saml:AttributeValue</span>&gt;</span>user@company.com<span class="tag">&lt;/<span class="name">saml:AttributeValue</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">saml:Attribute</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">saml:Attribute</span> <span class="attr">Name</span>=<span class="string">&quot;department&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">saml:AttributeValue</span>&gt;</span>Engineering<span class="tag">&lt;/<span class="name">saml:AttributeValue</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">saml:Attribute</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">saml:AttributeStatement</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>授权决策断言（Authorization Decision Assertion）</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">saml:AuthzDecisionStatement</span> <span class="attr">Resource</span>=<span class="string">&quot;https://app.company.com&quot;</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">Decision</span>=<span class="string">&quot;Permit&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">saml:Action</span>&gt;</span>Read<span class="tag">&lt;/<span class="name">saml:Action</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">saml:Action</span>&gt;</span>Write<span class="tag">&lt;/<span class="name">saml:Action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">saml:AuthzDecisionStatement</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="三、协议与Token协同架构"><a href="#三、协议与Token协同架构" class="headerlink" title="三、协议与Token协同架构"></a>三、协议与Token协同架构</h2><h3 id="1-OAuth-2-0-OpenID-Connect-组合"><a href="#1-OAuth-2-0-OpenID-Connect-组合" class="headerlink" title="1. OAuth 2.0 + OpenID Connect 组合"></a>1. OAuth 2.0 + OpenID Connect 组合</h3><p>这是现代应用最常用的认证授权组合，同时解决身份认证和资源授权问题。</p><h4 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h4><pre class="mermaid">sequenceDiagram    participant User as 用户    participant Client as 客户端应用    participant AuthServer as 认证服务器    participant Resource as 资源服务器    User->>Client: 访问应用    Client->>AuthServer: 重定向到认证页面    User->>AuthServer: 登录并授权    AuthServer->>Client: 返回授权码    Client->>AuthServer: 交换Token    AuthServer->>Client: 返回Access Token + ID Token    Client->>Resource: 使用Access Token访问资源    Client->>AuthServer: 使用Access Token获取UserInfo</pre><h4 id="技术优势"><a href="#技术优势" class="headerlink" title="技术优势"></a>技术优势</h4><ul><li><strong>职责分离</strong>：OAuth负责授权，OIDC负责认证</li><li><strong>标准化</strong>：广泛的行业支持和互操作性</li><li><strong>安全性</strong>：多层安全机制和最佳实践</li><li><strong>灵活性</strong>：支持多种客户端类型和场景</li></ul><h3 id="2-SAML-LDAP-企业集成"><a href="#2-SAML-LDAP-企业集成" class="headerlink" title="2. SAML + LDAP 企业集成"></a>2. SAML + LDAP 企业集成</h3><p>传统企业环境中，SAML和LDAP的组合提供了完整的企业身份管理解决方案。</p><h4 id="集成架构"><a href="#集成架构" class="headerlink" title="集成架构"></a>集成架构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Enterprise AD/LDAP ←→ SAML IdP ←→ SaaS Applications</span><br><span class="line">       ↓                ↓              ↓</span><br><span class="line">   用户目录        身份联邦        业务应用</span><br></pre></td></tr></table></figure><h4 id="集成流程"><a href="#集成流程" class="headerlink" title="集成流程"></a>集成流程</h4><ol><li><strong>用户认证</strong>：用户通过企业AD&#x2F;LDAP进行身份验证</li><li><strong>断言生成</strong>：IdP生成包含用户属性的SAML断言</li><li><strong>应用授权</strong>：SaaS应用验证SAML断言并授权访问</li><li><strong>属性同步</strong>：通过LDAP查询获取最新的用户属性</li></ol><h4 id="企业价值"><a href="#企业价值" class="headerlink" title="企业价值"></a>企业价值</h4><ul><li><strong>统一身份</strong>：一套用户目录管理所有应用</li><li><strong>合规要求</strong>：满足企业安全和合规标准</li><li><strong>成本效益</strong>：减少重复的身份管理工作</li></ul><hr><h2 id="四、安全最佳实践"><a href="#四、安全最佳实践" class="headerlink" title="四、安全最佳实践"></a>四、安全最佳实践</h2><h3 id="1-传输层安全"><a href="#1-传输层安全" class="headerlink" title="1. 传输层安全"></a>1. 传输层安全</h3><h4 id="HTTPS-强制要求"><a href="#HTTPS-强制要求" class="headerlink" title="HTTPS 强制要求"></a>HTTPS 强制要求</h4><ul><li><strong>所有Token传输</strong>必须使用HTTPS加密</li><li><strong>证书验证</strong>：确保SSL证书有效性和域名匹配</li><li><strong>HSTS策略</strong>：启用HTTP严格传输安全</li></ul><h4 id="Token传输方式"><a href="#Token传输方式" class="headerlink" title="Token传输方式"></a>Token传输方式</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ✅ 推荐：Authorization Header</span><br><span class="line"><span class="attribute">Authorization</span><span class="punctuation">: </span>Bearer eyJhbGciOiJSUzI1NiIs...</span><br><span class="line"></span><br><span class="line"># ❌ 避免：URL参数传递</span><br><span class="line">GET /api/user?access_token=eyJhbGciOiJSUzI1NiIs...</span><br></pre></td></tr></table></figure><h3 id="2-存储安全策略"><a href="#2-存储安全策略" class="headerlink" title="2. 存储安全策略"></a>2. 存储安全策略</h3><h4 id="浏览器端安全存储"><a href="#浏览器端安全存储" class="headerlink" title="浏览器端安全存储"></a>浏览器端安全存储</h4><table><thead><tr><th>存储方式</th><th>安全性</th><th>XSS风险</th><th>CSRF风险</th><th>推荐场景</th></tr></thead><tbody><tr><td><strong>HttpOnly Cookie</strong></td><td>高</td><td>免疫</td><td>需防护</td><td>传统Web应用</td></tr><tr><td><strong>Secure Cookie</strong></td><td>高</td><td>免疫</td><td>需防护</td><td>HTTPS环境</td></tr><tr><td><strong>LocalStorage</strong></td><td>低</td><td>高风险</td><td>免疫</td><td>不推荐存储敏感Token</td></tr><tr><td><strong>Memory</strong></td><td>最高</td><td>免疫</td><td>免疫</td><td>SPA短期存储</td></tr></tbody></table><h4 id="移动端安全存储"><a href="#移动端安全存储" class="headerlink" title="移动端安全存储"></a>移动端安全存储</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iOS - Keychain Services</span></span><br><span class="line"><span class="keyword">const</span> keychain = <span class="built_in">require</span>(<span class="string">&#x27;react-native-keychain&#x27;</span>);</span><br><span class="line">keychain.<span class="title function_">setInternetCredentials</span>(<span class="string">&#x27;server&#x27;</span>, <span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;token&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Android - Keystore</span></span><br><span class="line"><span class="keyword">import</span> &#123; encrypt, decrypt &#125; <span class="keyword">from</span> <span class="string">&#x27;react-native-keystore&#x27;</span>;</span><br><span class="line"><span class="title function_">encrypt</span>(<span class="string">&#x27;tokenKey&#x27;</span>, accessToken);</span><br></pre></td></tr></table></figure><h3 id="3-密钥管理体系"><a href="#3-密钥管理体系" class="headerlink" title="3. 密钥管理体系"></a>3. 密钥管理体系</h3><h4 id="密钥轮换策略"><a href="#密钥轮换策略" class="headerlink" title="密钥轮换策略"></a>密钥轮换策略</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">JWT签名密钥轮换:</span></span><br><span class="line">  <span class="string">频率:</span> <span class="string">每3-6个月</span></span><br><span class="line">  <span class="string">过程:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">生成新密钥</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">同时支持新旧密钥验证</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">逐步淘汰旧密钥</span></span><br><span class="line">  </span><br><span class="line"><span class="string">密钥存储:</span></span><br><span class="line">  <span class="string">开发环境:</span> <span class="string">环境变量</span></span><br><span class="line">  <span class="string">生产环境:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">AWS</span> <span class="string">KMS</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Azure</span> <span class="string">Key</span> <span class="string">Vault</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">HashiCorp</span> <span class="string">Vault</span></span><br></pre></td></tr></table></figure><h4 id="密钥管理最佳实践"><a href="#密钥管理最佳实践" class="headerlink" title="密钥管理最佳实践"></a>密钥管理最佳实践</h4><ul><li><strong>分离存储</strong>：密钥与应用代码分离</li><li><strong>访问控制</strong>：最小权限原则</li><li><strong>审计日志</strong>：记录所有密钥操作</li><li><strong>备份恢复</strong>：建立密钥备份和恢复机制</li></ul><h3 id="4-攻击防护机制"><a href="#4-攻击防护机制" class="headerlink" title="4. 攻击防护机制"></a>4. 攻击防护机制</h3><h4 id="重放攻击防护"><a href="#重放攻击防护" class="headerlink" title="重放攻击防护"></a>重放攻击防护</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;jti&quot;</span><span class="punctuation">:</span> <span class="string">&quot;unique-token-id&quot;</span><span class="punctuation">,</span>     <span class="comment">// JWT ID，防止重复使用</span></span><br><span class="line">  <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1646092800</span><span class="punctuation">,</span>            <span class="comment">// 签发时间</span></span><br><span class="line">  <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1646096400</span><span class="punctuation">,</span>            <span class="comment">// 过期时间</span></span><br><span class="line">  <span class="attr">&quot;nonce&quot;</span><span class="punctuation">:</span> <span class="string">&quot;random-value&quot;</span>       <span class="comment">// 随机数，OIDC中使用</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="常见攻击与防护"><a href="#常见攻击与防护" class="headerlink" title="常见攻击与防护"></a>常见攻击与防护</h4><table><thead><tr><th>攻击类型</th><th>防护措施</th><th>实现方式</th></tr></thead><tbody><tr><td><strong>Token劫持</strong></td><td>HTTPS + Secure Cookie</td><td>传输加密</td></tr><tr><td><strong>XSS攻击</strong></td><td>HttpOnly Cookie + CSP</td><td>存储隔离</td></tr><tr><td><strong>CSRF攻击</strong></td><td>SameSite Cookie + CSRF Token</td><td>跨站防护</td></tr><tr><td><strong>重放攻击</strong></td><td>时间戳 + Nonce + JTI</td><td>唯一性验证</td></tr></tbody></table><hr><h2 id="五、技术选型指南"><a href="#五、技术选型指南" class="headerlink" title="五、技术选型指南"></a>五、技术选型指南</h2><h3 id="场景化选型矩阵"><a href="#场景化选型矩阵" class="headerlink" title="场景化选型矩阵"></a>场景化选型矩阵</h3><table><thead><tr><th>应用场景</th><th>推荐协议</th><th>Token类型</th><th>优势</th><th>考虑因素</th></tr></thead><tbody><tr><td><strong>消费级应用</strong></td><td>OAuth 2.0 + OIDC</td><td>Access Token + ID Token</td><td>标准化、易集成</td><td>用户体验</td></tr><tr><td><strong>企业SSO</strong></td><td>SAML 2.0</td><td>SAML断言</td><td>成熟稳定、合规</td><td>复杂度较高</td></tr><tr><td><strong>移动应用</strong></td><td>OIDC + JWT</td><td>JWT + Refresh Token</td><td>离线可用、性能好</td><td>存储安全</td></tr><tr><td><strong>微服务架构</strong></td><td>JWT</td><td>自包含JWT</td><td>无状态、可扩展</td><td>密钥管理</td></tr><tr><td><strong>API网关</strong></td><td>OAuth 2.0</td><td>Bearer Token</td><td>细粒度控制</td><td>性能要求</td></tr></tbody></table><h3 id="现代化选型建议"><a href="#现代化选型建议" class="headerlink" title="现代化选型建议"></a>现代化选型建议</h3><h4 id="新项目推荐"><a href="#新项目推荐" class="headerlink" title="新项目推荐"></a>新项目推荐</h4><ol><li><strong>OAuth 2.1 + OIDC</strong>：现代应用的首选</li><li><strong>PKCE扩展</strong>：公共客户端必须启用</li><li><strong>JWT格式</strong>：Access Token使用JWT格式</li><li><strong>短期Token</strong>：Access Token 15-60分钟过期</li></ol><h4 id="企业级要求"><a href="#企业级要求" class="headerlink" title="企业级要求"></a>企业级要求</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">安全要求:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">SAML</span> <span class="number">2.0</span><span class="string">用于企业SSO</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">mTLS用于服务间通信</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">HSM用于密钥存储</span></span><br><span class="line"></span><br><span class="line"><span class="string">合规要求:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">GDPR:</span> <span class="string">数据保护和用户同意</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">SOX:</span> <span class="string">访问控制和审计</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">HIPAA:</span> <span class="string">医疗数据保护</span></span><br></pre></td></tr></table></figure><h3 id="实施路线图"><a href="#实施路线图" class="headerlink" title="实施路线图"></a>实施路线图</h3><h4 id="第一阶段：基础实施"><a href="#第一阶段：基础实施" class="headerlink" title="第一阶段：基础实施"></a>第一阶段：基础实施</h4><ul><li><input disabled="" type="checkbox"> 选择认证协议（OAuth 2.0 + OIDC）</li><li><input disabled="" type="checkbox"> 部署身份提供商（如Auth0、Okta）</li><li><input disabled="" type="checkbox"> 实现基础的登录登出功能</li><li><input disabled="" type="checkbox"> 配置HTTPS和基础安全策略</li></ul><h4 id="第二阶段：安全加固"><a href="#第二阶段：安全加固" class="headerlink" title="第二阶段：安全加固"></a>第二阶段：安全加固</h4><ul><li><input disabled="" type="checkbox"> 启用多因素认证（MFA）</li><li><input disabled="" type="checkbox"> 实施Token轮换和撤销</li><li><input disabled="" type="checkbox"> 配置安全存储和传输</li><li><input disabled="" type="checkbox"> 建立监控和审计机制</li></ul><h4 id="第三阶段：高级特性"><a href="#第三阶段：高级特性" class="headerlink" title="第三阶段：高级特性"></a>第三阶段：高级特性</h4><ul><li><input disabled="" type="checkbox"> 细粒度权限控制（RBAC&#x2F;ABAC）</li><li><input disabled="" type="checkbox"> 跨域SSO集成</li><li><input disabled="" type="checkbox"> 零信任架构实施</li><li><input disabled="" type="checkbox"> 持续安全评估</li></ul><h2 id="六、技术发展趋势"><a href="#六、技术发展趋势" class="headerlink" title="六、技术发展趋势"></a>六、技术发展趋势</h2><h3 id="新兴技术标准"><a href="#新兴技术标准" class="headerlink" title="新兴技术标准"></a>新兴技术标准</h3><h4 id="OAuth-2-1"><a href="#OAuth-2-1" class="headerlink" title="OAuth 2.1"></a>OAuth 2.1</h4><p>OAuth 2.1整合了OAuth 2.0的安全最佳实践，主要改进包括：</p><ul><li><strong>强制PKCE</strong>：所有公共客户端必须使用PKCE</li><li><strong>移除隐式流</strong>：不再支持隐式授权模式</li><li><strong>刷新令牌安全</strong>：强化Refresh Token的安全要求</li></ul><h4 id="WebAuthn-FIDO2"><a href="#WebAuthn-FIDO2" class="headerlink" title="WebAuthn (FIDO2)"></a>WebAuthn (FIDO2)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebAuthn注册示例</span></span><br><span class="line"><span class="keyword">const</span> credential = <span class="keyword">await</span> navigator.<span class="property">credentials</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">publicKey</span>: &#123;</span><br><span class="line">    <span class="attr">challenge</span>: <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="attr">rp</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;Example Corp&quot;</span> &#125;,</span><br><span class="line">    <span class="attr">user</span>: &#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="keyword">new</span> <span class="title class_">TextEncoder</span>().<span class="title function_">encode</span>(<span class="string">&quot;user123&quot;</span>),</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;user@example.com&quot;</span>,</span><br><span class="line">      <span class="attr">displayName</span>: <span class="string">&quot;John Doe&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">pubKeyCredParams</span>: [&#123;<span class="attr">alg</span>: -<span class="number">7</span>, <span class="attr">type</span>: <span class="string">&quot;public-key&quot;</span>&#125;],</span><br><span class="line">    <span class="attr">authenticatorSelection</span>: &#123;</span><br><span class="line">      <span class="attr">authenticatorAttachment</span>: <span class="string">&quot;platform&quot;</span>,</span><br><span class="line">      <span class="attr">userVerification</span>: <span class="string">&quot;required&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="零信任架构下的认证"><a href="#零信任架构下的认证" class="headerlink" title="零信任架构下的认证"></a>零信任架构下的认证</h3><h4 id="动态授权模型"><a href="#动态授权模型" class="headerlink" title="动态授权模型"></a>动态授权模型</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">零信任原则:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">永不信任，始终验证</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">最小权限访问</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">持续验证和监控</span></span><br><span class="line"></span><br><span class="line"><span class="string">实施策略:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">基于风险的自适应认证</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">上下文感知的访问控制</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">实时威胁检测和响应</span></span><br></pre></td></tr></table></figure><h3 id="标准参考文档"><a href="#标准参考文档" class="headerlink" title="标准参考文档"></a>标准参考文档</h3><h4 id="RFC标准"><a href="#RFC标准" class="headerlink" title="RFC标准"></a>RFC标准</h4><ul><li><strong>RFC 6749</strong>: OAuth 2.0 Authorization Framework</li><li><strong>RFC 7519</strong>: JSON Web Token (JWT)</li><li><strong>RFC 7636</strong>: Proof Key for Code Exchange (PKCE)</li><li><strong>RFC 8414</strong>: OAuth 2.0 Authorization Server Metadata</li></ul><h4 id="安全框架"><a href="#安全框架" class="headerlink" title="安全框架"></a>安全框架</h4><ul><li><strong>OWASP API Security Top 10</strong>: API安全最佳实践</li><li><strong>NIST Cybersecurity Framework</strong>: 网络安全框架</li><li><strong>ISO 27001</strong>: 信息安全管理体系标准</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>认证和授权技术体系正在快速发展，从传统的Session管理到现代的JWT和OAuth体系，再到新兴的零信任架构，技术选择需要综合考虑安全性、可用性、可扩展性等多个维度。</p><p><strong>关键要点：</strong></p><ol><li><strong>OAuth 2.0 + OIDC</strong> 是现代应用的主流选择</li><li><strong>JWT</strong> 在微服务架构中具有显著优势</li><li><strong>SAML</strong> 在企业环境中仍然重要</li><li><strong>安全性</strong> 始终是第一考虑因素</li><li><strong>标准化</strong> 有助于系统集成和维护</li></ol><p>选择合适的认证授权方案，需要基于具体的业务场景、技术架构和安全要求进行综合评估。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OAuth </tag>
            
            <tag> JWT </tag>
            
            <tag> SAML </tag>
            
            <tag> OIDC </tag>
            
            <tag> 认证 </tag>
            
            <tag> 授权 </tag>
            
            <tag> Token </tag>
            
            <tag> Kerberos </tag>
            
            <tag> LDAP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字证书与 PKI 技术详解</title>
      <link href="/posts/6104.html"/>
      <url>/posts/6104.html</url>
      
        <content type="html"><![CDATA[<h1 id="数字证书与-PKI-技术详解"><a href="#数字证书与-PKI-技术详解" class="headerlink" title="数字证书与 PKI 技术详解"></a>数字证书与 PKI 技术详解</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>数字证书是现代网络安全的基石，PKI (Public Key Infrastructure) 公钥基础设施则是管理这些证书的完整框架。本文将深入探讨 PKI 的核心概念、组件架构、证书格式标准以及自动化管理协议。</p><h2 id="PKI-Public-Key-Infrastructure-公钥基础设施"><a href="#PKI-Public-Key-Infrastructure-公钥基础设施" class="headerlink" title="PKI (Public Key Infrastructure) 公钥基础设施"></a>PKI (Public Key Infrastructure) 公钥基础设施</h2><h3 id="定义与核心价值"><a href="#定义与核心价值" class="headerlink" title="定义与核心价值"></a>定义与核心价值</h3><p><strong>PKI</strong> 是一个综合性的安全框架，专门用于管理数字证书和公钥加密的完整生命周期。它通过建立可信的数字身份体系，为现代网络通信提供身份验证、数据完整性和机密性保障。</p><h3 id="核心组件架构"><a href="#核心组件架构" class="headerlink" title="核心组件架构"></a>核心组件架构</h3><h4 id="1-CA-Certificate-Authority-证书颁发机构"><a href="#1-CA-Certificate-Authority-证书颁发机构" class="headerlink" title="1. CA (Certificate Authority) - 证书颁发机构"></a>1. CA (Certificate Authority) - 证书颁发机构</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">核心职能:</span> <span class="string">PKI</span> <span class="string">的信任根节点，负责数字证书的全生命周期管理</span></span><br><span class="line"><span class="string">主要职责:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">严格验证申请者身份和资质</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">颁发符合标准的数字证书</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">实时维护证书状态信息</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">及时发布证书撤销列表</span> <span class="string">(CRL)</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">管理证书有效期和续期流程</span></span><br></pre></td></tr></table></figure><h4 id="2-RA-Registration-Authority-注册机构"><a href="#2-RA-Registration-Authority-注册机构" class="headerlink" title="2. RA (Registration Authority) - 注册机构"></a>2. RA (Registration Authority) - 注册机构</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">定位:</span> <span class="string">CA</span> <span class="string">的授权代理，专注于证书申请前端处理</span></span><br><span class="line"><span class="string">核心功能:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">执行严格的身份验证流程</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">标准化证书申请处理程序</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">向</span> <span class="string">CA</span> <span class="string">转发已验证的合规申请</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">提供用户支持和咨询服务</span></span><br></pre></td></tr></table></figure><h4 id="3-证书存储与分发系统"><a href="#3-证书存储与分发系统" class="headerlink" title="3. 证书存储与分发系统"></a>3. 证书存储与分发系统</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">功能:</span> <span class="string">安全存储和高效分发已颁发证书</span></span><br><span class="line"><span class="string">实现方式:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">LDAP</span> <span class="string">目录服务</span> <span class="string">(企业环境首选)</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">关系型数据库</span> <span class="string">(高性能场景)</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Web</span> <span class="string">服务器</span> <span class="string">(公网访问)</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">分布式存储系统</span> <span class="string">(大规模部署)</span></span><br></pre></td></tr></table></figure><h4 id="4-证书状态验证系统"><a href="#4-证书状态验证系统" class="headerlink" title="4. 证书状态验证系统"></a>4. 证书状态验证系统</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">组件构成:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">CRL</span> <span class="string">(Certificate</span> <span class="string">Revocation</span> <span class="string">List)</span> <span class="bullet">-</span> <span class="string">传统撤销列表</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">OCSP</span> <span class="string">(Online</span> <span class="string">Certificate</span> <span class="string">Status</span> <span class="string">Protocol)</span> <span class="bullet">-</span> <span class="string">实时状态查询</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">证书透明度日志</span> <span class="string">(Certificate</span> <span class="string">Transparency)</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">自动化状态监控服务</span></span><br></pre></td></tr></table></figure><h3 id="PKI-架构关系"><a href="#PKI-架构关系" class="headerlink" title="PKI 架构关系"></a>PKI 架构关系</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PKI (公钥基础设施生态系统)</span><br><span class="line">├── CA (证书颁发机构) ← 信任锚点</span><br><span class="line">├── RA (注册机构) ← 身份验证网关</span><br><span class="line">├── 证书存储与分发系统 ← 数据管理层</span><br><span class="line">├── 证书状态验证系统 ← 安全监控层</span><br><span class="line">├── 密钥管理与托管系统 ← 密码学核心</span><br><span class="line">├── 策略引擎与合规框架 ← 治理层</span><br><span class="line">└── 用户接口与API服务 ← 应用接口层</span><br></pre></td></tr></table></figure><p><strong>组件协同关系</strong>:</p><ul><li><strong>CA</strong> 作为信任的根基，建立整个信任链条</li><li><strong>PKI</strong> 提供完整的治理框架和运营体系</li><li><strong>各组件协同工作</strong>，确保端到端的安全保障</li></ul><h3 id="信任模型架构"><a href="#信任模型架构" class="headerlink" title="信任模型架构"></a>信任模型架构</h3><h4 id="层次化信任模型-主流架构"><a href="#层次化信任模型-主流架构" class="headerlink" title="层次化信任模型 (主流架构)"></a>层次化信任模型 (主流架构)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Root CA (根证书颁发机构)</span><br><span class="line">├── Policy CA (策略证书颁发机构)</span><br><span class="line">│   ├── Issuing CA 1 (颁发证书颁发机构)</span><br><span class="line">│   │   ├── SSL/TLS Server Certificate</span><br><span class="line">│   │   └── Code Signing Certificate</span><br><span class="line">│   └── Issuing CA 2</span><br><span class="line">│       ├── Email Certificate</span><br><span class="line">│       └── User Authentication Certificate</span><br><span class="line">└── Cross-Certified CA (交叉认证证书颁发机构)</span><br><span class="line">    ├── Partner Organization Certificate</span><br><span class="line">    └── Federal Bridge Certificate</span><br></pre></td></tr></table></figure><h4 id="信任链验证流程"><a href="#信任链验证流程" class="headerlink" title="信任链验证流程"></a>信任链验证流程</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">验证步骤:</span></span><br><span class="line"><span class="number">1</span><span class="string">.</span> <span class="string">获取目标实体证书</span></span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="string">提取颁发者CA信息</span></span><br><span class="line"><span class="number">3</span><span class="string">.</span> <span class="string">递归验证上级CA证书</span></span><br><span class="line"><span class="number">4</span><span class="string">.</span> <span class="string">追溯至受信任根CA</span></span><br><span class="line"><span class="number">5</span><span class="string">.</span> <span class="string">验证整条链的数字签名</span></span><br><span class="line"><span class="number">6</span><span class="string">.</span> <span class="string">检查证书有效期和撤销状态</span></span><br><span class="line"><span class="number">7</span><span class="string">.</span> <span class="string">应用证书策略约束</span></span><br></pre></td></tr></table></figure><h3 id="证书生命周期管理"><a href="#证书生命周期管理" class="headerlink" title="证书生命周期管理"></a>证书生命周期管理</h3><h4 id="完整生命周期流程"><a href="#完整生命周期流程" class="headerlink" title="完整生命周期流程"></a>完整生命周期流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">密钥对生成 → 证书申请提交 → 身份验证审核 → </span><br><span class="line">证书颁发签名 → 证书分发部署 → 日常使用监控 → </span><br><span class="line">定期更新续期 → 必要时撤销销毁</span><br></pre></td></tr></table></figure><h4 id="各阶段详细说明"><a href="#各阶段详细说明" class="headerlink" title="各阶段详细说明"></a>各阶段详细说明</h4><ul><li><strong>密钥生成</strong>: 采用安全随机数生成器，确保密钥强度</li><li><strong>身份验证</strong>: 多因素验证，包括文档审核和域名控制验证</li><li><strong>证书颁发</strong>: 遵循 X.509 标准，嵌入必要的扩展字段</li><li><strong>使用监控</strong>: 实时监控证书使用情况和安全事件</li><li><strong>更新续期</strong>: 自动化或半自动化的证书更新流程</li><li><strong>撤销管理</strong>: 基于 CRL 和 OCSP 的实时撤销检查</li></ul><h3 id="主流-PKI-实现方案"><a href="#主流-PKI-实现方案" class="headerlink" title="主流 PKI 实现方案"></a>主流 PKI 实现方案</h3><h4 id="Microsoft-Active-Directory-Certificate-Services-AD-CS"><a href="#Microsoft-Active-Directory-Certificate-Services-AD-CS" class="headerlink" title="Microsoft Active Directory Certificate Services (AD CS)"></a>Microsoft Active Directory Certificate Services (AD CS)</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">特点:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Windows</span> <span class="string">Server</span> <span class="string">原生</span> <span class="string">PKI</span> <span class="string">解决方案</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">与</span> <span class="string">Active</span> <span class="string">Directory</span> <span class="string">深度集成</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">支持企业级证书模板和自动注册</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">内置</span> <span class="string">Web</span> <span class="string">注册界面和</span> <span class="string">SCEP</span> <span class="string">支持</span></span><br><span class="line"><span class="string">应用场景:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">企业内部</span> <span class="string">PKI</span> <span class="string">部署</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Windows</span> <span class="string">域环境证书管理</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">智能卡和</span> <span class="string">EFS</span> <span class="string">文件加密</span></span><br></pre></td></tr></table></figure><h4 id="Let’s-Encrypt-开源免费-CA"><a href="#Let’s-Encrypt-开源免费-CA" class="headerlink" title="Let’s Encrypt (开源免费 CA)"></a>Let’s Encrypt (开源免费 CA)</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">特点:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">基于</span> <span class="string">ACME</span> <span class="string">协议的自动化证书管理</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">免费提供</span> <span class="string">DV</span> <span class="string">(域名验证)</span> <span class="string">证书</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">90</span><span class="string">天短期证书，强制自动化更新</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">支持通配符证书和多域名证书</span></span><br><span class="line"><span class="string">应用场景:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">公网</span> <span class="string">HTTPS</span> <span class="string">网站加密</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">开发测试环境</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">小型企业和个人项目</span></span><br></pre></td></tr></table></figure><h4 id="企业级商业-PKI-解决方案"><a href="#企业级商业-PKI-解决方案" class="headerlink" title="企业级商业 PKI 解决方案"></a>企业级商业 PKI 解决方案</h4><ul><li><strong>Entrust PKI</strong>: 高安全等级，政府和金融行业首选</li><li><strong>DigiCert CertCentral</strong>: 全球领先的商业证书服务</li><li><strong>GlobalSign</strong>: 欧洲主导的国际化 PKI 服务商</li></ul><h2 id="数字证书格式标准"><a href="#数字证书格式标准" class="headerlink" title="数字证书格式标准"></a>数字证书格式标准</h2><h3 id="X-509-证书标准概述"><a href="#X-509-证书标准概述" class="headerlink" title="X.509 证书标准概述"></a>X.509 证书标准概述</h3><p>所有数字证书均基于 <strong>ITU-T X.509 标准</strong>，定义了证书的基本结构和字段。无论是 PKCS#1、PKCS#12、SCEP 还是 ACME 获取的证书，本质上都是 X.509 格式的不同封装和传输方式。</p><h3 id="PKCS-标准族系"><a href="#PKCS-标准族系" class="headerlink" title="PKCS 标准族系"></a>PKCS 标准族系</h3><p><strong>PKCS (Public-Key Cryptography Standards)</strong> 是由 RSA 实验室制定的公钥密码学标准系列，其中 PKCS#1 和 PKCS#12 是数字证书领域的重要标准。</p><h4 id="PKCS-1-格式证书-仅证书内容"><a href="#PKCS-1-格式证书-仅证书内容" class="headerlink" title="PKCS#1 格式证书 (仅证书内容)"></a>PKCS#1 格式证书 (仅证书内容)</h4><p><strong>核心特征</strong>:</p><ul><li><strong>内容</strong>: 仅包含 X.509 公钥证书，不包含私钥</li><li><strong>安全性</strong>: 可公开分发，用于身份验证和加密</li><li><strong>编码方式</strong>: 支持 DER (二进制) 和 PEM (Base64文本) 两种编码</li></ul><p><strong>常见文件扩展名</strong>:</p><table><thead><tr><th>扩展名</th><th>编码格式</th><th>主要用途</th><th>适用平台</th></tr></thead><tbody><tr><td><strong>.crt</strong></td><td>DER&#x2F;PEM</td><td>服务器证书、通用证书文件</td><td>跨平台通用</td></tr><tr><td><strong>.cer</strong></td><td>DER&#x2F;PEM</td><td>Windows 系统偏好格式</td><td>Windows主导</td></tr><tr><td><strong>.der</strong></td><td>DER</td><td>二进制编码证书</td><td>系统级应用</td></tr><tr><td><strong>.pem</strong></td><td>PEM</td><td>Base64文本证书、证书链</td><td>Linux&#x2F;Unix</td></tr></tbody></table><p><strong>实际应用示例</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 典型证书文件命名</span></span><br><span class="line">ssl-certificate.crt      <span class="comment"># Web服务器SSL证书</span></span><br><span class="line">root-ca.cer             <span class="comment"># 根证书颁发机构证书</span></span><br><span class="line">intermediate.der        <span class="comment"># 中间证书颁发机构证书</span></span><br><span class="line">certificate-chain.pem   <span class="comment"># 完整证书链文件</span></span><br><span class="line">client-auth.crt         <span class="comment"># 客户端认证证书</span></span><br></pre></td></tr></table></figure><h4 id="PKCS-12-格式证书-完整身份包"><a href="#PKCS-12-格式证书-完整身份包" class="headerlink" title="PKCS#12 格式证书 (完整身份包)"></a>PKCS#12 格式证书 (完整身份包)</h4><p><strong>核心特征</strong>:</p><ul><li><strong>内容</strong>: 证书 + 私钥 + 可选的证书链</li><li><strong>安全性</strong>: 密码保护的二进制容器格式</li><li><strong>用途</strong>: 完整数字身份的安全传输和存储</li></ul><p><strong>常见文件扩展名</strong>:</p><table><thead><tr><th>扩展名</th><th>主要平台</th><th>使用场景</th></tr></thead><tbody><tr><td><strong>.p12</strong></td><td>跨平台标准</td><td>标准 PKCS#12 格式</td></tr><tr><td><strong>.pfx</strong></td><td>Windows</td><td>Microsoft 个人信息交换格式</td></tr><tr><td><strong>.pkcs12</strong></td><td>Linux&#x2F;Unix</td><td>明确标识的 PKCS#12 格式</td></tr></tbody></table><p><strong>典型使用场景</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实际应用示例</span></span><br><span class="line">user-identity.p12        <span class="comment"># 用户个人数字身份</span></span><br><span class="line">client-certificate.pfx   <span class="comment"># 客户端双向认证证书</span></span><br><span class="line">device-identity.pkcs12   <span class="comment"># IoT设备身份证书</span></span><br><span class="line">code-signing.p12         <span class="comment"># 代码签名证书</span></span><br><span class="line">email-certificate.pfx    <span class="comment"># S/MIME邮件加密证书</span></span><br></pre></td></tr></table></figure><h4 id="格式对比总结"><a href="#格式对比总结" class="headerlink" title="格式对比总结"></a>格式对比总结</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">PKCS#1</span> <span class="string">证书:</span></span><br><span class="line">  <span class="string">包含内容:</span> <span class="string">仅</span> <span class="string">X.509</span> <span class="string">证书</span> <span class="string">(公钥)</span></span><br><span class="line">  <span class="string">私钥位置:</span> <span class="string">单独存储管理</span></span><br><span class="line">  <span class="string">安全等级:</span> <span class="string">中等</span> <span class="string">(证书可公开)</span></span><br><span class="line">  <span class="string">使用复杂度:</span> <span class="string">需要额外管理私钥</span></span><br><span class="line">  <span class="string">主要用途:</span> <span class="string">服务器证书、证书链验证</span></span><br><span class="line"></span><br><span class="line"><span class="string">PKCS#12</span> <span class="string">证书:</span></span><br><span class="line">  <span class="string">包含内容:</span> <span class="string">证书</span> <span class="string">+</span> <span class="string">私钥</span> <span class="string">+</span> <span class="string">证书链</span></span><br><span class="line">  <span class="string">私钥保护:</span> <span class="string">密码加密保护</span></span><br><span class="line">  <span class="string">安全等级:</span> <span class="string">高</span> <span class="string">(完整身份保护)</span></span><br><span class="line">  <span class="string">使用便利性:</span> <span class="string">一站式身份解决方案</span></span><br><span class="line">  <span class="string">主要用途:</span> <span class="string">客户端身份认证、数字签名</span></span><br></pre></td></tr></table></figure><h2 id="SCEP"><a href="#SCEP" class="headerlink" title="SCEP"></a>SCEP</h2><p>SCEP（Simple Certificate Enrollment Protocol，简单证书注册协议）证书是通过 SCEP 协议从 CA 获取的数字证书（也是 X.509 格式），包含公钥和私钥（设备本地生成，不由CA传输）。</p><ul><li>相较于P12证书要手动更新， SCEP证书，需要联网，根据配置参数申请证书，动态更新，支持自动续期，</li><li>场景：常用于企业内部，专注于设备身份验证（VPN 、WIFI）</li><li>使用者：企业 IT 管理员、设备管理。</li></ul><h2 id="ACME"><a href="#ACME" class="headerlink" title="ACME"></a>ACME</h2><p>ACME（Automatic Certificate Management Environmen）证书是通过 ACME 协议从 CA（如 Let’s Encrypt）获取的数字证书，通常是 X.509 格式，包含公钥和私钥（设备本地生成，不由CA传输），用于证明身份和加密通信。</p><ul><li>场景：专注于WEB安全，多用于网站的HTTPS验证</li><li>使用者：网站管理员、开发者。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PKI </tag>
            
            <tag> 数字证书 </tag>
            
            <tag> CA </tag>
            
            <tag> 加密 </tag>
            
            <tag> PKCS </tag>
            
            <tag> SCEP </tag>
            
            <tag> ACME </tag>
            
            <tag> X.509 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hibernate ORM 框架详解</title>
      <link href="/posts/22172.html"/>
      <url>/posts/22172.html</url>
      
        <content type="html"><![CDATA[<h1 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h1><p>Hibernate 是一个用于 Java 环境的开源对象关系映射（ORM）框架，XML 映射文件是 Hibernate 配置实体类和数据库表之间映射关系的重要方式。以下是 Hibernate XML 映射文件中常见标签的介绍：</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>在 Spring 框架中使用 Hibernate 作为 ORM 框架时，需要导入以下相关库（依赖项）。以下是基于 Maven 或 Gradle 的依赖配置，具体依赖取决于你使用的 Spring 版本、Hibernate 版本以及是否使用 JPA。</p><h3 id="1-核心-Dependencies"><a href="#1-核心-Dependencies" class="headerlink" title="1. 核心 Dependencies"></a>1. <strong>核心 D</strong>ependencies</h3><h4 id="Hibernate-Core"><a href="#Hibernate-Core" class="headerlink" title="Hibernate Core"></a>Hibernate Core</h4><p>Hibernate 的核心库，提供基本的 ORM 功能。</p><ul><li><strong>Maven</strong>:<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.6.15.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 替换为最新稳定版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>Gradle</strong>:<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.hibernate:hibernate-core:5.6.15.Final&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="Spring-ORM"><a href="#Spring-ORM" class="headerlink" title="Spring ORM"></a>Spring ORM</h4><p>Spring 提供的 ORM 模块，集成 Hibernate 并简化配置（如 <code>SessionFactory</code> 管理）。</p><ul><li><strong>Maven</strong>:<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-orm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 与你的 Spring 版本保持一致 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>Gradle</strong>:<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.springframework:spring-orm:5.3.27&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-数据库驱动"><a href="#2-数据库驱动" class="headerlink" title="2. 数据库驱动"></a>2. <strong>数据库驱动</strong></h3><p>需要根据你使用的数据库（如 MySQL、PostgreSQL 等）添加对应的 JDBC 驱动。例如：</p><ul><li><p><strong>MySQL 驱动</strong>:</p><ul><li><strong>Maven</strong>:<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 替换为最新版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>Gradle</strong>:<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;mysql:mysql-connector-java:8.0.33&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>PostgreSQL 驱动</strong>（示例）:</p><ul><li><strong>Maven</strong>:<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.postgresql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>postgresql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>42.7.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>Gradle</strong>:<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.postgresql:postgresql:42.7.3&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-可选依赖"><a href="#3-可选依赖" class="headerlink" title="3. 可选依赖"></a>3. <strong>可选依赖</strong></h3><h4 id="连接池（推荐）"><a href="#连接池（推荐）" class="headerlink" title="连接池（推荐）"></a>连接池（推荐）</h4><p>为了提高性能，通常使用数据库连接池（如 HikariCP、C3P0 或 DBCP）。Spring Boot 默认使用 HikariCP。</p><ul><li><strong>HikariCP</strong>:<ul><li><strong>Maven</strong>:<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zaxxer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HikariCP<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>Gradle</strong>:<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.zaxxer:HikariCP:5.0.1&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="如果使用-Spring-Boot"><a href="#如果使用-Spring-Boot" class="headerlink" title="如果使用 Spring Boot"></a>如果使用 Spring Boot</h4><p>Spring Boot 提供了 starter 依赖，简化配置：</p><ul><li><strong>Maven</strong>:<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 与你的 Spring Boot 版本一致 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>Gradle</strong>:<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-data-jpa:2.7.18&#x27;</span></span><br></pre></td></tr></table></figure><strong>说明</strong>：<code>spring-boot-starter-data-jpa</code> 已经包含了 Hibernate、Spring ORM 和 JPA 相关依赖，并默认配置 HikariCP。你还需要单独添加数据库驱动（如 MySQL）。</li></ul><h3 id="4-版本注意事项"><a href="#4-版本注意事项" class="headerlink" title="4. 版本注意事项"></a>4. <strong>版本注意事项</strong></h3><ul><li><strong>Hibernate 版本</strong>：推荐使用最新稳定版（截至 2025 年 4 月，5.6.x 或 6.x 系列）。Hibernate 6.x 要求 JDK 11+ 并有重大变更（如去掉 <code>hibernate-entitymanager</code> 包）。</li><li><strong>Spring 版本</strong>：确保 Spring 和 Hibernate 版本兼容。例如，Spring 5.x 通常与 Hibernate 5.x 搭配，Spring 6.x 与 Hibernate 6.x 更兼容。</li><li><strong>Spring Boot</strong>：如果使用 Spring Boot，<code>spring-boot-starter-data-jpa</code> 会自动管理兼容的 Hibernate 版本。</li></ul><h3 id="5-典型配置示例（非-Spring-Boot）"><a href="#5-典型配置示例（非-Spring-Boot）" class="headerlink" title="5. 典型配置示例（非 Spring Boot）"></a>5. <strong>典型配置示例（非 Spring Boot）</strong></h3><p>在 Spring 配置文件（如 <code>applicationContext.xml</code>）中配置 Hibernate：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zaxxer.hikari.HikariDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/yourdb&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;packagesToScan&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.example.model&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernateProperties&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.dialect&quot;</span>&gt;</span>org.hibernate.dialect.MySQL8Dialect<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.show_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.hbm2ddl.auto&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sessionFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-Spring-Boot-配置"><a href="#6-Spring-Boot-配置" class="headerlink" title="6. Spring Boot 配置"></a>6. <strong>Spring Boot 配置</strong></h3><p>如果使用 Spring Boot，只需在 <code>application.properties</code> 或 <code>application.yml</code> 中配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/yourdb</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">password</span></span><br><span class="line"><span class="attr">spring.jpa.hibernate.ddl-auto</span>=<span class="string">update</span></span><br><span class="line"><span class="attr">spring.jpa.show-sql</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.jpa.properties.hibernate.dialect</span>=<span class="string">org.hibernate.dialect.MySQL8Dialect</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>最小依赖</strong>：<code>hibernate-core</code>、<code>spring-orm</code>、数据库驱动。</li><li><strong>推荐（Spring Boot）</strong>：<code>spring-boot-starter-data-jpa</code> + 数据库驱动。</li><li><strong>JPA 场景</strong>：添加 <code>hibernate-entitymanager</code>（Hibernate 5.x）。</li><li><strong>连接池</strong>：建议使用 HikariCP。</li></ul><p>如果使用 Spring Boot，<code>spring-boot-starter-data-jpa</code> 是最简便的方式。如果是传统 Spring 项目，需手动添加 Hibernate 和 Spring ORM 依赖。确保版本兼容，并根据数据库类型选择合适的驱动。</p><p>如果你有具体场景（例如 Spring Boot 版本、数据库类型）或遇到配置问题，请提供更多细节，我可以进一步优化答案！</p><h2 id="XML-配置文件"><a href="#XML-配置文件" class="headerlink" title="XML 配置文件"></a>XML 配置文件</h2><h3 id=""><a href="#" class="headerlink" title="&lt;hibernate-mapping&gt;"></a><code>&lt;hibernate-mapping&gt;</code></h3><p>这是 Hibernate XML 映射文件的根标签，用于标识一个映射文档的开始和结束，它可以包含多个 <code>&lt;class&gt;</code> 标签。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 其他标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title="&lt;class&gt;"></a><code>&lt;class&gt;</code></h3><p><code>&lt;class&gt;</code> 标签用于定义 Java 类和数据库表之间的映射关系。</p><ul><li><p><code>name</code> 属性：指定 Java 类的全限定名。</p></li><li><p><code>table</code> 属性：指定对应的数据库表名。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;com.example.User&quot;</span> <span class="attr">table</span>=<span class="string">&quot;users&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 其他标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="-2"><a href="#-2" class="headerlink" title="&lt;id&gt;"></a><code>&lt;id&gt;</code></h3><p>  <code>&lt;id&gt;</code> 标签用于映射 Java 类中的主键属性到数据库表的主键列。</p><ul><li><p><code>name</code> 属性：指定 Java 类中的主键属性名。</p></li><li><p><code>column</code> 属性：指定数据库表中的主键列名。</p></li><li><p><code>type</code> 属性：指定属性的数据类型。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;long&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 主键生成策略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="-3"><a href="#-3" class="headerlink" title="&lt;generator&gt;"></a><code>&lt;generator&gt;</code></h3><p><code>&lt;generator&gt;</code> 标签用于指定主键的生成策略，通常嵌套在 <code>&lt;id&gt;</code> 标签内。常见的生成策略有：</p><ul><li><p><code>native</code>：根据数据库的支持自动选择合适的主键生成策略（如自增、序列等）。</p></li><li><p><code>increment</code>：由 Hibernate 自动生成一个递增的主键值。</p></li><li><p><code>uuid</code>：生成一个 UUID 作为主键值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="-4"><a href="#-4" class="headerlink" title="&lt;property&gt;"></a><code>&lt;property&gt;</code></h3><p><code>&lt;property&gt;</code> 标签用于映射 Java 类中的普通属性到数据库表的列。</p><ul><li><p><code>name</code> 属性：指定 Java 类中的属性名。</p></li><li><p><code>column</code> 属性：指定数据库表中的列名。</p></li><li><p><code>type</code> 属性：指定属性的数据类型。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="-5"><a href="#-5" class="headerlink" title="&lt;many-to-one&gt;"></a><code>&lt;many-to-one&gt;</code></h3><p><code>&lt;many-to-one&gt;</code> 标签用于映射多对一的关联关系，例如多个用户属于一个部门。</p><ul><li><p><code>name</code> 属性：指定 Java 类中关联对象的属性名。</p></li><li><p><code>column</code> 属性：指定数据库表中用于关联的外键列名。</p></li><li><p><code>class</code> 属性：指定关联对象的 Java 类全限定名。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">&quot;department&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Department&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="-6"><a href="#-6" class="headerlink" title="&lt;one-to-many&gt;"></a><code>&lt;one-to-many&gt;</code></h3><p><code>&lt;one-to-many&gt;</code> 标签用于映射一对多的关联关系，例如一个部门有多个用户。</p><ul><li><p><code>name</code> 属性：指定 Java 类中关联对象集合的属性名。</p></li><li><p><code>class</code> 属性：指定关联对象的 Java 类全限定名。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">name</span>=<span class="string">&quot;users&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.User&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="-7"><a href="#-7" class="headerlink" title="&lt;set&gt;"></a><code>&lt;set&gt;</code></h3><p><code>&lt;set&gt;</code> 标签用于映射 Java 类中的集合属性，通常与 <code>&lt;one-to-many&gt;</code> 或 <code>&lt;many-to-many&gt;</code> 关联使用。</p><ul><li><p><code>name</code> 属性：指定 Java 类中的集合属性名。</p></li><li><p><code>table</code> 属性：指定关联表名（在多对多关系中使用）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">&quot;users&quot;</span> <span class="attr">table</span>=<span class="string">&quot;user_department&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">&quot;com.example.User&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="-8"><a href="#-8" class="headerlink" title="&lt;Bag&gt;"></a><code>&lt;Bag&gt;</code></h3><p>在 Hibernate XML 映射文件里，<code>&lt;bag&gt;</code>标签用于映射 Java 类中的集合属性，它表示无序且可重复的集合，类似于 Java 里的<code>java.util.Collection</code>。下面为你详细介绍其用法和相关属性：</p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>&lt;bag&gt;</code>标签常被用于映射一对多或者多对多的关联关系。它一般和<code>&lt;key&gt;</code>、<code>&lt;one-to-many&gt;</code>或者<code>&lt;many-to-many&gt;</code>标签搭配使用。以下是个简单示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;com.example.Department&quot;</span> <span class="attr">table</span>=<span class="string">&quot;departments&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;long&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bag</span> <span class="attr">name</span>=<span class="string">&quot;employees&quot;</span> <span class="attr">table</span>=<span class="string">&quot;dept_emp&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Employee&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bag</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Department</code>类有一个<code>employees</code>属性，它是一个无序且可重复的<code>Employee</code>对象集合。<code>&lt;bag&gt;</code>标签定义了这个集合属性的映射，<code>&lt;key&gt;</code>标签指明了关联表中的外键列，<code>&lt;one-to-many&gt;</code>标签表明了一对多的关联关系。</p><h4 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h4><ul><li><p><strong><code>name</code></strong>：指定 Java 类中的集合属性名，就像上面例子中的<code>employees</code>。</p></li><li><p><strong><code>table</code></strong>：指定关联表名，在一对多或者多对多关系里使用。比如在多对多关系中，需要一个中间表来存储关联信息，<code>table</code>属性就指定了这个中间表的名称。</p></li><li><p><strong><code>cascade</code></strong>：定义级联操作，它确定了在对父对象执行某些操作（如保存、更新、删除）时，是否要对关联对象也执行相同操作。常见的值有<code>save-update</code>、<code>delete</code>、<code>all</code>等。示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bag</span> <span class="attr">name</span>=<span class="string">&quot;employees&quot;</span> <span class="attr">table</span>=<span class="string">&quot;dept_emp&quot;</span> <span class="attr">cascade</span>=<span class="string">&quot;save-update&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Employee&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bag</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>inverse</code></strong>：是一个布尔值，用来指定关联关系的控制权在哪一方。若设为<code>true</code>，则表示关联关系的维护由另一方负责；若设为<code>false</code>（默认值），则当前对象负责维护关联关系。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bag</span> <span class="attr">name</span>=<span class="string">&quot;employees&quot;</span> <span class="attr">table</span>=<span class="string">&quot;dept_emp&quot;</span> <span class="attr">inverse</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Employee&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bag</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>与<code>&lt;set&gt;</code>标签对比</p><p>和<code>&lt;set&gt;</code>标签不同，<code>&lt;bag&gt;</code>允许集合中有重复元素，而<code>&lt;set&gt;</code>要求元素唯一。所以，当你需要一个可包含重复元素的集合时，就可以使用<code>&lt;bag&gt;</code>标签。 </p><h3 id="-9"><a href="#-9" class="headerlink" title="&lt;discriminator&gt;"></a><code>&lt;discriminator&gt;</code></h3><p>在 Hibernate 的 XML 配置文件里，<code>&lt;discriminator&gt;</code>标签主要用于实现继承映射。当 Java 类存在继承关系时，该标签能够把这些具有继承关系的类映射到数据库的同一张表中，借助一个特定的列来区分不同的子类。下面为你详细介绍其使用方式和相关属性。</p><h4 id="基本使用场景"><a href="#基本使用场景" class="headerlink" title="基本使用场景"></a>基本使用场景</h4><p>在实际开发中，可能会有多个子类继承自同一个父类的情况。若把这些子类分别映射到不同的数据库表，会使数据库结构变得复杂。通过<code>&lt;discriminator&gt;</code>标签，可将所有子类的数据存储在同一张表中，再用一个特殊的列来辨别不同的子类。</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;com.example.Animal&quot;</span> <span class="attr">table</span>=<span class="string">&quot;animals&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;animal_id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;long&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">column</span>=<span class="string">&quot;animal_type&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">subclass</span> <span class="attr">name</span>=<span class="string">&quot;com.example.Dog&quot;</span> <span class="attr">discriminator-value</span>=<span class="string">&quot;dog&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Dog 类特有的属性映射 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">subclass</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">subclass</span> <span class="attr">name</span>=<span class="string">&quot;com.example.Cat&quot;</span> <span class="attr">discriminator-value</span>=<span class="string">&quot;cat&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Cat 类特有的属性映射 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">subclass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述示例中：</p><ul><li><code>Animal</code>是父类，<code>Dog</code>和<code>Cat</code>是它的子类。</li><li><code>&lt;discriminator&gt;</code>标签指定了一个名为<code>animal_type</code>的列，数据类型为字符串，用于区分不同的子类。</li><li><code>&lt;subclass&gt;</code>标签定义了子类的映射，<code>discriminator-value</code>属性指定了该子类在<code>animal_type</code>列中对应的值。</li></ul><h4 id="常用属性-1"><a href="#常用属性-1" class="headerlink" title="常用属性"></a>常用属性</h4><ul><li><strong><code>column</code></strong>：指定数据库表中用于区分不同子类的列名。在上面的例子中，<code>column=&quot;animal_type&quot;</code>表示使用<code>animal_type</code>列来存储子类的区分信息。</li><li><strong><code>type</code></strong>：指定区分列的数据类型，例如<code>string</code>、<code>integer</code>等。</li></ul><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>当 Hibernate 从数据库中查询数据时，会依据<code>&lt;discriminator&gt;</code>标签指定的列的值来判断应该将数据实例化为哪个子类的对象。比如，若<code>animal_type</code>列的值为<code>dog</code>，Hibernate 就会把数据实例化为<code>Dog</code>类的对象；若值为<code>cat</code>，则实例化为<code>Cat</code>类的对象。</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li><strong>简化数据库结构</strong>：避免为每个子类创建单独的表，减少了数据库表的数量，使数据库结构更加简洁。</li><li><strong>提高数据查询效率</strong>：因为所有子类的数据都存储在同一张表中，查询时无需进行复杂的表连接操作，提高了查询效率。</li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><strong>区分列的唯一性</strong>：<code>discriminator-value</code>属性的值必须唯一，否则会导致 Hibernate 在实例化对象时出现混淆。</li><li><strong>数据一致性</strong>：在插入数据时，要确保区分列的值与<code>&lt;subclass&gt;</code>标签中<code>discriminator-value</code>属性的值一致，以保证数据的一致性。</li></ul><h3 id="-10"><a href="#-10" class="headerlink" title="&lt;key&gt;"></a><code>&lt;key&gt;</code></h3><p><code>&lt;key&gt;</code> 标签用于指定关联表中的外键列，通常在 <code>&lt;set&gt;</code> 或 <code>&lt;list&gt;</code> 标签中使用。</p><ul><li><p><code>column</code> 属性：指定外键列名。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>这些标签是 Hibernate XML 映射文件中最常用的部分，通过合理使用它们，可以实现 Java 类和数据库表之间的灵活映射。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>Hibernate 是一个流行的 Java 持久层框架，它允许你通过对象关系映射（ORM）的方式来操作数据库。以下是 Hibernate 中一些常用的注解：</p><ol><li><p><strong>@Entity</strong>：用于标注实体类，表示该类对应数据库中的一张表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@Table</strong>：与 <code>@Entity</code> 一起使用，指定实体类所对应的数据库表名。如果不指定，默认使用类名作为表名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@Id</strong>：标记属性为主键。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure></li><li><p><strong>@GeneratedValue</strong>：定义主键的生成策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure><p>常见的生成策略有 <code>AUTO</code>, <code>IDENTITY</code>, <code>SEQUENCE</code>, 和 <code>TABLE</code>。</p></li><li><p><strong>@Column</strong>：用于描述实体类中的字段如何映射到数据库表中的列。可以指定列名、是否允许为空等属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Column(name = &quot;user_name&quot;, nullable = false, length = 30)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure></li><li><p><strong>@Transient</strong>：表示某个属性不会被持久化到数据库中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> String tempValue;</span><br></pre></td></tr></table></figure></li><li><p><strong>@ManyToOne</strong>, <strong>@OneToMany</strong>, <strong>@OneToOne</strong>, <strong>@ManyToMany</strong>：用于定义实体之间的关系。例如，<code>@ManyToOne</code> 表示多对一的关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn(name = &quot;department_id&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Department department;</span><br></pre></td></tr></table></figure></li><li><p><strong>@JoinColumn</strong>：用于指定连接列（外键），通常在定义关联关系时使用。</p></li><li><p><strong>@Embedded</strong>, <strong>@Embeddable</strong>：用于组合模式，<code>@Embeddable</code> 标记的类可以在其他实体中嵌入使用，而 <code>@Embedded</code> 用来嵌入这些可嵌入的对象。</p></li><li><p><strong>@Formula</strong>：用于定义基于SQL公式或子查询的虚拟属性。</p></li></ol><p>以上仅是部分常用的 Hibernate 注解，根据实际需要可能还会涉及到更多高级特性和注解。使用这些注解可以大大简化Java应用程序与数据库交互的代码。</p><h2 id="Session-和-SessionFactory"><a href="#Session-和-SessionFactory" class="headerlink" title="Session 和 SessionFactory"></a>Session 和 SessionFactory</h2><p>在 Hibernate 中，<code>Session</code> 和 <code>SessionFactory</code> 是核心组件，负责管理与数据库的交互以及对象持久化。它们与 Hibernate 的缓存机制密切相关，共同影响应用的性能和数据一致性。下面详细解释 <code>Session</code>、<code>SessionFactory</code>、缓存机制及其相关性。</p><hr><h3 id="1-Session"><a href="#1-Session" class="headerlink" title="1. Session"></a><strong>1. Session</strong></h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h4><p><code>Session</code> 是 Hibernate 的核心接口（<code>org.hibernate.Session</code>），用于执行数据库操作（如增删改查），是应用程序与数据库交互的主要入口。它封装了 JDBC 连接，管理实体对象的生命周期，并维护一个<strong>一级缓存</strong>（Persistence Context）。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h4><ul><li><strong>非线程安全</strong>：<code>Session</code> 设计为单线程使用，不应在多个线程间共享。每个线程或请求通常需要独立的 <code>Session</code>。</li><li><strong>短生命周期</strong>：<code>Session</code> 通常在一次数据库操作或事务中创建，用完后关闭，避免资源泄漏。</li><li><strong>一级缓存</strong>：<code>Session</code> 内部维护一个缓存，存储当前会话中的实体对象，减少数据库访问。</li><li><strong>代理 JDBC 连接</strong>：<code>Session</code> 通过底层的 JDBC 连接与数据库通信，但开发者无需直接操作 JDBC。</li></ul><h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a><strong>主要功能</strong></h4><ul><li><strong>CRUD 操作</strong>：保存（<code>save</code>）、更新（<code>update</code>）、删除（<code>delete</code>）、查询（<code>get</code>、<code>load</code>）。</li><li><strong>查询执行</strong>：支持 HQL（<code>createQuery</code>）、Criteria API、原生 SQL。</li><li><strong>事务管理</strong>：通过 <code>beginTransaction</code> 开启事务，管理数据库操作。</li><li><strong>缓存管理</strong>：维护一级缓存，自动处理脏检查（Dirty Checking）。</li></ul><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a><strong>常用方法</strong></h4><ul><li><code>save(Object)</code>：保存实体，返回标识符。</li><li><code>update(Object)</code>：更新实体。</li><li><code>merge(Object)</code>：合并 detached 状态的实体。</li><li><code>delete(Object)</code>：删除实体。</li><li><code>get(Class, Serializable)</code>：根据 ID 立即加载实体。</li><li><code>load(Class, Serializable)</code>：延迟加载实体。</li><li><code>createQuery(String)</code>：创建 HQL 查询。</li><li><code>flush()</code>：同步持久化上下文到数据库。</li><li><code>clear()</code>：清空一级缓存。</li><li><code>beginTransaction()</code>：开启事务。</li></ul><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a><strong>生命周期</strong></h4><ol><li>创建：通过 <code>SessionFactory.openSession()</code> 或 <code>SessionFactory.getCurrentSession()</code> 获取。</li><li>使用：执行数据库操作，管理实体。</li><li>关闭：调用 <code>close()</code> 释放资源（Spring 可自动管理）。</li></ol><hr><h3 id="2-SessionFactory"><a href="#2-SessionFactory" class="headerlink" title="2. SessionFactory"></a><strong>2. SessionFactory</strong></h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a><strong>定义</strong></h4><p><code>SessionFactory</code> 是 Hibernate 的工厂接口（<code>org.hibernate.SessionFactory</code>），负责创建 <code>Session</code> 实例。它是一个<strong>线程安全</strong>的全局对象，初始化时加载 Hibernate 配置和映射元数据。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a><strong>特点</strong></h4><ul><li><strong>线程安全</strong>：<code>SessionFactory</code> 可以在多个线程间共享，通常在应用启动时创建单一实例。</li><li><strong>重量级对象</strong>：创建 <code>SessionFactory</code> 开销大，因为它需要解析配置文件、映射元数据并建立数据库连接池。</li><li><strong>全局单例</strong>：整个应用通常只有一个 <code>SessionFactory</code>，除非使用多个数据库。</li><li><strong>配置中心</strong>：存储 Hibernate 配置（如数据库连接、方言、缓存设置）和实体映射信息。</li></ul><h4 id="主要功能-1"><a href="#主要功能-1" class="headerlink" title="主要功能"></a><strong>主要功能</strong></h4><ul><li>创建 <code>Session</code> 实例。</li><li>管理 Hibernate 配置和元数据。</li><li>提供对二级缓存（如果启用）的访问。</li></ul><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a><strong>常用方法</strong></h4><ul><li><code>openSession()</code>：创建新的 <code>Session</code>，需手动关闭。</li><li><code>getCurrentSession()</code>：获取当前线程绑定的 <code>Session</code>（需配置事务上下文，Spring 常用）。</li><li><code>close()</code>：关闭工厂，释放资源（通常在应用关闭时调用）。</li></ul><h4 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a><strong>生命周期</strong></h4><ol><li>初始化：应用启动时，通过 <code>Configuration</code> 或 Spring 配置创建 <code>SessionFactory</code>。</li><li>使用：提供 <code>Session</code> 实例，服务整个应用。</li><li>销毁：应用关闭时调用 <code>close()</code> 释放资源。</li></ol><hr><h3 id="3-Hibernate-缓存机制"><a href="#3-Hibernate-缓存机制" class="headerlink" title="3. Hibernate 缓存机制"></a><strong>3. Hibernate 缓存机制</strong></h3><p>Hibernate 提供两级缓存机制，用于减少数据库访问，提高性能：<strong>一级缓存</strong>（与 <code>Session</code> 相关）和<strong>二级缓存</strong>（与 <code>SessionFactory</code> 相关）。</p><h4 id="一级缓存（First-Level-Cache）"><a href="#一级缓存（First-Level-Cache）" class="headerlink" title="一级缓存（First-Level Cache）"></a><strong>一级缓存（First-Level Cache）</strong></h4><ul><li><strong>定义</strong>：一级缓存是 <code>Session</code> 级别的缓存，自动启用，存储当前 <code>Session</code> 内的实体对象。也被称为<strong>持久化上下文</strong>（Persistence Context）。</li><li><strong>作用</strong>：<ul><li>缓存实体对象，避免重复查询数据库。</li><li>实现脏检查，自动检测实体变化并同步到数据库。</li><li>管理实体状态（Managed、Detached、Transient）。</li></ul></li><li><strong>生命周期</strong>：与 <code>Session</code> 绑定，<code>Session</code> 关闭或调用 <code>clear()</code> 时缓存清空。</li><li><strong>特点</strong>：<ul><li>强制启用，无法禁用。</li><li>仅在同一 <code>Session</code> 内有效，不跨 <code>Session</code> 共享。</li><li>缓存的是实体对象的完整状态（包括关联对象）。</li></ul></li><li><strong>工作原理</strong>：<ul><li>当通过 <code>get()</code>、<code>load()</code> 或查询加载实体时，Hibernate 将实体放入一级缓存。</li><li>同一 <code>Session</code> 内重复查询相同实体时，直接从缓存返回，避免数据库访问。</li><li>在事务提交或 <code>flush()</code> 时，Hibernate 对比缓存中的实体与数据库状态，执行必要的 SQL 更新（脏检查）。</li></ul></li></ul><h4 id="二级缓存（Second-Level-Cache）"><a href="#二级缓存（Second-Level-Cache）" class="headerlink" title="二级缓存（Second-Level Cache）"></a><strong>二级缓存（Second-Level Cache）</strong></h4><ul><li><strong>定义</strong>：二级缓存是 <code>SessionFactory</code> 级别的缓存，可选启用，存储跨 <code>Session</code> 的实体数据或查询结果。</li><li><strong>作用</strong>：<ul><li>提高跨 <code>Session</code> 的查询性能，减少数据库访问。</li><li>适合频繁读取、不常修改的数据（如配置表、字典表）。</li></ul></li><li><strong>生命周期</strong>：与 <code>SessionFactory</code> 绑定，应用运行期间持续存在。</li><li><strong>特点</strong>：<ul><li>默认禁用，需显式配置（如 EHCache、Redis）。</li><li>可缓存实体、查询结果或集合。</li><li>跨 <code>Session</code> 和线程共享，需考虑并发一致性。</li></ul></li><li><strong>配置</strong>：<ul><li>启用二级缓存：设置 <code>hibernate.cache.use_second_level_cache=true</code>。</li><li>指定缓存提供者（如 <code>org.hibernate.cache.ehcache.EhCacheRegionFactory</code>）。</li><li>在实体上使用 <code>@Cache</code> 注解：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="查询缓存（Query-Cache）"><a href="#查询缓存（Query-Cache）" class="headerlink" title="查询缓存（Query Cache）"></a><strong>查询缓存（Query Cache）</strong></h4><ul><li><strong>定义</strong>：查询缓存是二级缓存的子集，用于缓存 HQL&#x2F;JPQL 查询的结果（仅缓存实体 ID 和简单数据）。</li><li><strong>作用</strong>：避免重复执行相同的查询。</li><li><strong>启用方式</strong>：<ul><li>设置 <code>hibernate.cache.use_query_cache=true</code>。</li><li>在查询时调用 <code>setCacheable(true)</code>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> session.createQuery(<span class="string">&quot;from User where name = :name&quot;</span>);</span><br><span class="line">query.setParameter(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">query.setCacheable(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>注意</strong>：查询缓存通常与二级缓存一起使用，因为查询结果的实体仍需从二级缓存加载。</li></ul><hr><h3 id="4-Session、SessionFactory-和缓存机制的相关性"><a href="#4-Session、SessionFactory-和缓存机制的相关性" class="headerlink" title="4. Session、SessionFactory 和缓存机制的相关性"></a><strong>4. Session、SessionFactory 和缓存机制的相关性</strong></h3><p><code>Session</code>、<code>SessionFactory</code> 和缓存机制在 Hibernate 中紧密协作，共同管理数据访问和性能优化。以下是它们之间的关系：</p><h4 id="Session-和-SessionFactory-1"><a href="#Session-和-SessionFactory-1" class="headerlink" title="Session 和 SessionFactory"></a><strong>Session 和 SessionFactory</strong></h4><ul><li><strong>创建关系</strong>：<code>SessionFactory</code> 是工厂，负责创建 <code>Session</code> 实例。每个 <code>Session</code> 都与 <code>SessionFactory</code> 关联，共享其配置（如数据库连接、方言）。</li><li><strong>配置共享</strong>：<code>SessionFactory</code> 持有 Hibernate 的全局配置（包括映射元数据、缓存设置），<code>Session</code> 使用这些配置执行具体操作。</li><li><strong>生命周期差异</strong>：<ul><li><code>SessionFactory</code> 是应用级别的单例，生命周期长。</li><li><code>Session</code> 是请求或事务级别的，生命周期短，创建和销毁频繁。</li></ul></li><li><strong>Spring 集成</strong>：在 Spring 中，<code>SessionFactory</code> 由容器管理，<code>Session</code> 通过 <code>getCurrentSession()</code> 或 Spring 的 <code>@Transactional</code> 自动管理。</li></ul><h4 id="Session-和一级缓存"><a href="#Session-和一级缓存" class="headerlink" title="Session 和一级缓存"></a><strong>Session 和一级缓存</strong></h4><ul><li><strong>直接关联</strong>：一级缓存是 <code>Session</code> 的内置功能，存储在 <code>Session</code> 的持久化上下文中。</li><li><strong>缓存作用</strong>：<ul><li>同一 <code>Session</code> 内，重复查询相同实体（如 <code>get(User.class, id)</code>）直接从一级缓存返回。</li><li>脏检查依赖一级缓存，Hibernate 在 <code>flush()</code> 或事务提交时对比缓存中的实体状态。</li></ul></li><li><strong>管理方式</strong>：<ul><li>调用 <code>Session.clear()</code> 清空一级缓存。</li><li>调用 <code>Session.evict(Object)</code> 移除特定实体。</li><li><code>Session</code> 关闭时，一级缓存自动失效。</li></ul></li><li><strong>示例</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.openSession();</span><br><span class="line"><span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> session.beginTransaction();</span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> session.get(User.class, <span class="number">1L</span>); <span class="comment">// 查询数据库，放入一级缓存</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> session.get(User.class, <span class="number">1L</span>); <span class="comment">// 直接从一级缓存返回</span></span><br><span class="line">tx.commit();</span><br><span class="line">session.close(); <span class="comment">// 一级缓存失效</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="SessionFactory-和二级缓存"><a href="#SessionFactory-和二级缓存" class="headerlink" title="SessionFactory 和二级缓存"></a><strong>SessionFactory 和二级缓存</strong></h4><ul><li><strong>管理关系</strong>：二级缓存由 <code>SessionFactory</code> 管理，跨 <code>Session</code> 共享。<code>SessionFactory</code> 负责初始化缓存提供者（如 EHCache）并维护缓存区域。</li><li><strong>缓存访问</strong>：<ul><li>当 <code>Session</code> 查询实体时，Hibernate 先检查一级缓存，若未命中，再检查二级缓存（若启用）。</li><li>如果二级缓存命中，Hibernate 从缓存加载实体，减少数据库访问。</li></ul></li><li><strong>配置依赖</strong>：二级缓存的配置（如缓存策略、提供者）在 <code>SessionFactory</code> 初始化时设置，影响所有 <code>Session</code>。</li><li><strong>示例</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Session</span> <span class="variable">session1</span> <span class="operator">=</span> sessionFactory.openSession();</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> session1.get(User.class, <span class="number">1L</span>); <span class="comment">// 查询数据库，放入二级缓存</span></span><br><span class="line">session1.close();</span><br><span class="line"></span><br><span class="line"><span class="type">Session</span> <span class="variable">session2</span> <span class="operator">=</span> sessionFactory.openSession();</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> session2.get(User.class, <span class="number">1L</span>); <span class="comment">// 从二级缓存加载</span></span><br><span class="line">session2.close();</span><br></pre></td></tr></table></figure></li></ul><h4 id="Session、SessionFactory-和查询缓存"><a href="#Session、SessionFactory-和查询缓存" class="headerlink" title="Session、SessionFactory 和查询缓存"></a><strong>Session、SessionFactory 和查询缓存</strong></h4><ul><li><strong>协作机制</strong>：<ul><li>查询缓存存储查询结果的元数据（如实体 ID），由 <code>SessionFactory</code> 管理。</li><li>实际实体数据仍需从二级缓存或数据库加载。</li><li><code>Session</code> 通过 <code>setCacheable(true)</code> 启用查询缓存，查询结果与 <code>SessionFactory</code> 的缓存区域关联。</li></ul></li><li><strong>依赖关系</strong>：查询缓存依赖二级缓存，必须同时启用二级缓存才能生效。</li></ul><h4 id="整体工作流程"><a href="#整体工作流程" class="headerlink" title="整体工作流程"></a><strong>整体工作流程</strong></h4><ol><li><strong>初始化</strong>：<code>SessionFactory</code> 在应用启动时创建，加载配置、映射和缓存设置（包括二级缓存）。</li><li><strong>创建 Session</strong>：应用通过 <code>SessionFactory</code> 创建 <code>Session</code>，每个 <code>Session</code> 维护独立的一级缓存。</li><li><strong>查询操作</strong>：<ul><li><code>Session</code> 首先检查一级缓存。</li><li>如果一级缓存未命中，检查二级缓存（若启用）。</li><li>如果二级缓存未命中，查询数据库，并将结果存入一级缓存和二级缓存（若启用）。</li></ul></li><li><strong>事务提交</strong>：<ul><li><code>Session</code> 执行脏检查，同步一级缓存中的变化到数据库。</li><li>二级缓存根据策略（如 <code>READ_WRITE</code>）更新。</li></ul></li><li><strong>关闭</strong>：<code>Session</code> 关闭，一级缓存失效；<code>SessionFactory</code> 和二级缓存保持有效，直到应用关闭。</li></ol><hr><h3 id="5-实践中的注意事项"><a href="#5-实践中的注意事项" class="headerlink" title="5. 实践中的注意事项"></a><strong>5. 实践中的注意事项</strong></h3><ol><li><p><strong>Session 管理</strong>：</p><ul><li>避免长时间持有 <code>Session</code>，防止内存泄漏。</li><li>在 Spring 中，使用 <code>@Transactional</code> 自动管理 <code>Session</code>（通过 <code>getCurrentSession()</code>）。</li><li>总是关闭 <code>Session</code>（<code>close()</code>），或依赖 Spring 管理。</li></ul></li><li><p><strong>SessionFactory 配置</strong>：</p><ul><li>确保 <code>SessionFactory</code> 单例，避免重复创建。</li><li>合理配置数据库连接池（如 HikariCP）和 Hibernate 属性（如 <code>hibernate.dialect</code>）。</li></ul></li><li><p><strong>缓存优化</strong>：</p><ul><li><strong>一级缓存</strong>：避免在单一 <code>Session</code> 内加载过多实体，防止内存溢出。</li><li><strong>二级缓存</strong>：仅缓存不常修改的数据，配置合适的并发策略（如 <code>READ_ONLY</code> 或 <code>READ_WRITE</code>）。</li><li><strong>查询缓存</strong>：谨慎使用，适合高频、参数固定的查询。</li></ul></li><li><p><strong>性能调试</strong>：</p><ul><li>开启 <code>hibernate.show_sql</code> 和 <code>hibernate.format_sql</code> 查看生成的 SQL。</li><li>使用 <code>statistics</code> 检查缓存命中率：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sessionFactory.getStatistics().setStatisticsEnabled(<span class="literal">true</span>);</span><br><span class="line">System.out.println(sessionFactory.getStatistics().getSecondLevelCacheHitCount());</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>常见问题</strong>：</p><ul><li><strong>LazyInitializationException</strong>：因 <code>Session</code> 关闭后访问延迟加载的关联对象，解决方法是提前加载或使用 Spring 的 <code>OpenSessionInView</code>。</li><li><strong>N+1 查询问题</strong>：因一级缓存未命中或关联对象逐个加载，解决方法是使用 <code>JOIN FETCH</code> 或批量加载。</li></ul></li></ol><hr><h3 id="6-示例代码：展示-Session、SessionFactory-和缓存"><a href="#6-示例代码：展示-Session、SessionFactory-和缓存" class="headerlink" title="6. 示例代码：展示 Session、SessionFactory 和缓存"></a><strong>6. 示例代码：展示 Session、SessionFactory 和缓存</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置 SessionFactory</span></span><br><span class="line"><span class="type">Configuration</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>().configure();</span><br><span class="line">config.addAnnotatedClass(User.class);</span><br><span class="line"><span class="type">SessionFactory</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> config.buildSessionFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Session 和一级缓存</span></span><br><span class="line"><span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.openSession();</span><br><span class="line"><span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> session.beginTransaction();</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> session.get(User.class, <span class="number">1L</span>); <span class="comment">// 查询数据库，放入一级缓存</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> session.get(User.class, <span class="number">1L</span>); <span class="comment">// 从一级缓存返回</span></span><br><span class="line">System.out.println(user1 == user2); <span class="comment">// true，同一对象</span></span><br><span class="line"></span><br><span class="line">tx.commit();</span><br><span class="line">session.close(); <span class="comment">// 一级缓存失效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二级缓存示例（需配置 EHCache 和 @Cache）</span></span><br><span class="line"><span class="type">Session</span> <span class="variable">session2</span> <span class="operator">=</span> sessionFactory.openSession();</span><br><span class="line"><span class="type">Transaction</span> <span class="variable">tx2</span> <span class="operator">=</span> session2.beginTransaction();</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> session2.get(User.class, <span class="number">1L</span>); <span class="comment">// 从二级缓存加载（若命中）</span></span><br><span class="line">tx2.commit();</span><br><span class="line">session2.close();</span><br><span class="line"></span><br><span class="line">sessionFactory.close(); <span class="comment">// 关闭 SessionFactory，二级缓存失效</span></span><br></pre></td></tr></table></figure><hr><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a><strong>7. 总结</strong></h3><ul><li><strong>Session</strong>：<ul><li>作用：管理数据库操作和一级缓存，非线程安全，短生命周期。</li><li>核心方法：<code>save</code>、<code>get</code>、<code>createQuery</code>、<code>flush</code>。</li></ul></li><li><strong>SessionFactory</strong>：<ul><li>作用：创建 <code>Session</code>，管理全局配置和二级缓存，线程安全，单例。</li><li>核心方法：<code>openSession</code>、<code>getCurrentSession</code>。</li></ul></li><li><strong>缓存机制</strong>：<ul><li><strong>一级缓存</strong>：<code>Session</code> 级别，自动启用，存储当前会话实体，负责脏检查。</li><li><strong>二级缓存</strong>：<code>SessionFactory</code> 级别，可选启用，跨 <code>Session</code> 共享，适合只读数据。</li><li><strong>查询缓存</strong>：缓存查询结果，依赖二级缓存。</li></ul></li><li><strong>相关性</strong>：<ul><li><code>SessionFactory</code> 创建 <code>Session</code>，提供配置和二级缓存。</li><li><code>Session</code> 维护一级缓存，执行操作，可能访问二级缓存。</li><li>缓存机制通过减少数据库访问优化性能，与 <code>Session</code> 和 <code>SessionFactory</code> 的生命周期紧密相关。</li></ul></li></ul><hr><h3 id="进一步学习建议"><a href="#进一步学习建议" class="headerlink" title="进一步学习建议"></a><strong>进一步学习建议</strong></h3><ol><li><strong>实践</strong>：搭建一个 Spring Boot + Hibernate 项目，测试一级缓存和二级缓存的效果。</li><li><strong>调试</strong>：使用 Hibernate 的 <code>Statistics</code> API 监控缓存命中率，优化查询。</li><li><strong>深入</strong>：学习关联映射（如 <code>@OneToMany</code>）和 <code>fetch</code> 策略，结合缓存优化性能。</li><li><strong>资源</strong>：参考 <a href="https://docs.jboss.org/hibernate/orm/5.6/userguide/html_single/Hibernate_User_Guide.html#caching">Hibernate 官方文档</a> 的缓存章节。</li></ol><p>如果你有具体场景（如缓存配置、性能问题、代码调试），请提供细节，我可以进一步提供定制化指导！</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>要熟悉使用 Hibernate 作为 ORM 框架，建议从理解其核心概念开始，逐步通过实践掌握常用类、接口和方法。以下是一个系统化的学习路径，以及 Hibernate 中常用的类、接口和方法的详细说明，帮助你快速上手。</p><hr><h3 id="学习路径：如何入手-Hibernate"><a href="#学习路径：如何入手-Hibernate" class="headerlink" title="学习路径：如何入手 Hibernate"></a><strong>学习路径：如何入手 Hibernate</strong></h3><ol><li><p><strong>理解核心概念</strong></p><ul><li><strong>ORM 原理</strong>：了解对象-关系映射，Hibernate 如何将 Java 对象映射到数据库表。</li><li><strong>Session 和 SessionFactory</strong>：掌握 Hibernate 的核心工作单元。</li><li><strong>事务管理</strong>：理解事务在 Hibernate 中的作用。</li><li><strong>一级缓存和查询</strong>：学习 Hibernate 如何缓存对象和执行查询。</li></ul></li><li><p><strong>搭建开发环境</strong></p><ul><li><strong>依赖配置</strong>：使用 Maven 或 Gradle 引入 Hibernate 依赖（参考之前的回答）。</li><li><strong>数据库准备</strong>：选择一个数据库（如 MySQL、H2），创建表结构。</li><li><strong>Spring 集成</strong>：推荐结合 Spring（或 Spring Boot）简化配置，Spring Boot 的 <code>spring-boot-starter-data-jpa</code> 是快速入门的首选。</li></ul></li><li><p><strong>实践基础操作</strong></p><ul><li><strong>创建实体类</strong>：使用注解（如 <code>@Entity</code>、<code>@Id</code>）定义 Java 类与数据库表的映射。</li><li><strong>配置 Hibernate</strong>：设置 <code>hibernate.cfg.xml</code> 或 <code>application.properties</code>（Spring Boot）。</li><li><strong>实现 CRUD</strong>：通过 <code>Session</code> 或 JPA 的 <code>EntityManager</code> 实现增删改查。</li><li><strong>练习查询</strong>：使用 HQL（Hibernate Query Language）或 Criteria API 编写查询。</li></ul></li><li><p><strong>深入高级功能</strong></p><ul><li><strong>关联映射</strong>：学习 <code>@OneToMany</code>、<code>@ManyToOne</code> 等关联关系。</li><li><strong>延迟加载</strong>：理解 <code>fetch</code> 策略（如 <code>FetchType.LAZY</code>）。</li><li><strong>事务管理</strong>：结合 Spring 的 <code>@Transactional</code> 管理事务。</li><li><strong>性能优化</strong>：探索一级缓存、二级缓存、批量操作。</li></ul></li><li><p><strong>通过项目巩固</strong></p><ul><li>构建一个简单的应用（如用户管理系统），包含实体、DAO、服务层和控制器。</li><li>使用 Spring Boot + Hibernate 实现 REST API，涵盖 CRUD 和关联查询。</li><li>调试常见问题（如 <code>LazyInitializationException</code>、N+1 查询问题）。</li></ul></li><li><p><strong>查阅官方资源</strong></p><ul><li><strong>Hibernate 文档</strong>：参考 <a href="https://hibernate.org/orm/documentation/">Hibernate 官方文档</a>。</li><li><strong>教程和社区</strong>：学习 Baeldung、Mkyong 等网站的 Hibernate 教程，参与 Stack Overflow 讨论。</li><li><strong>源码和示例</strong>：查看 Hibernate 的 GitHub 仓库或官方示例项目。</li></ul></li></ol><hr><h3 id="常用类、接口和方法"><a href="#常用类、接口和方法" class="headerlink" title="常用类、接口和方法"></a><strong>常用类、接口和方法</strong></h3><p>以下是 Hibernate 中最常用的类、接口及其核心方法，分为 **Hibernate 核心（Session 模式）**和 <strong>JPA 模式</strong>（Spring Boot 常用）。</p><h4 id="1-Hibernate-核心（Session-模式）"><a href="#1-Hibernate-核心（Session-模式）" class="headerlink" title="1. Hibernate 核心（Session 模式）"></a><strong>1. Hibernate 核心（Session 模式）</strong></h4><p>这些类和接口用于传统的 Hibernate 操作，基于 <code>Session</code> 和 <code>SessionFactory</code>。</p><h5 id="常用类和接口"><a href="#常用类和接口" class="headerlink" title="常用类和接口"></a><strong>常用类和接口</strong></h5><ol><li><p><strong><code>org.hibernate.Session</code></strong></p><ul><li><strong>作用</strong>：核心接口，管理实体对象的持久化操作，维护一级缓存。</li><li><strong>非线程安全</strong>，每个线程应有独立的 <code>Session</code>。</li><li><strong>获取方式</strong>：通过 <code>SessionFactory.openSession()</code> 获取。</li></ul></li><li><p><strong><code>org.hibernate.SessionFactory</code></strong></p><ul><li><strong>作用</strong>：线程安全的工厂类，负责创建 <code>Session</code>，初始化 Hibernate 配置。</li><li><strong>特点</strong>：全局单例，创建开销大，应用启动时初始化。</li></ul></li><li><p><strong><code>org.hibernate.Transaction</code></strong></p><ul><li><strong>作用</strong>：管理数据库事务，确保操作的原子性。</li><li><strong>获取方式</strong>：通过 <code>Session.beginTransaction()</code> 获取。</li></ul></li><li><p><strong><code>org.hibernate.query.Query</code></strong></p><ul><li><strong>作用</strong>：执行 HQL 或 SQL 查询，返回结果集。</li><li><strong>获取方式</strong>：通过 <code>Session.createQuery()</code> 创建。</li></ul></li></ol><h5 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a><strong>常用方法</strong></h5><ul><li><p><strong><code>Session</code> 方法</strong>：</p><ul><li><code>save(Object)</code>：保存实体，返回标识符。</li><li><code>update(Object)</code>：更新实体。</li><li><code>merge(Object)</code>：合并 detached 状态的实体。</li><li><code>delete(Object)</code>：删除实体。</li><li><code>get(Class, Serializable)</code>：根据 ID 立即加载实体。</li><li><code>load(Class, Serializable)</code>：延迟加载实体。</li><li><code>createQuery(String)</code>：创建 HQL 查询。</li><li><code>flush()</code>：同步持久化上下文到数据库。</li><li><code>clear()</code>：清空一级缓存。</li><li><code>beginTransaction()</code>：开启事务。</li></ul></li><li><p><strong><code>SessionFactory</code> 方法</strong>：</p><ul><li><code>openSession()</code>：创建新的 <code>Session</code>。</li><li><code>getCurrentSession()</code>：获取当前线程绑定的 <code>Session</code>（需配置事务上下文）。</li><li><code>close()</code>：关闭工厂，释放资源。</li></ul></li><li><p><strong><code>Transaction</code> 方法</strong>：</p><ul><li><code>commit()</code>：提交事务。</li><li><code>rollback()</code>：回滚事务。</li></ul></li><li><p><strong><code>Query</code> 方法</strong>：</p><ul><li><code>getResultList()</code>：返回查询结果列表。</li><li><code>getSingleResult()</code>：返回单个结果。</li><li><code>setParameter(String, Object)</code>：设置查询参数。</li><li><code>setMaxResults(int)</code>：限制结果数量。</li></ul></li></ul><h5 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SessionFactory</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>().configure().buildSessionFactory();</span><br><span class="line"><span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.openSession();</span><br><span class="line"><span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    tx = session.beginTransaction();</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    session.save(user); <span class="comment">// 保存</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">loaded</span> <span class="operator">=</span> session.get(User.class, user.getId()); <span class="comment">// 查询</span></span><br><span class="line">    tx.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tx != <span class="literal">null</span>) tx.rollback();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-JPA-模式（EntityManager-模式）"><a href="#2-JPA-模式（EntityManager-模式）" class="headerlink" title="2. JPA 模式（EntityManager 模式）"></a><strong>2. JPA 模式（EntityManager 模式）</strong></h4><p>在 Spring Boot 或现代项目中，通常使用 Hibernate 作为 JPA 实现，基于 <code>EntityManager</code>。</p><h5 id="常用类和接口-1"><a href="#常用类和接口-1" class="headerlink" title="常用类和接口"></a><strong>常用类和接口</strong></h5><ol><li><p><strong><code>javax.persistence.EntityManager</code>（或 <code>jakarta.persistence</code>）</strong></p><ul><li><strong>作用</strong>：JPA 的核心接口，类似 <code>Session</code>，管理实体的持久化操作。</li><li><strong>获取方式</strong>：通过 Spring 注入或 <code>EntityManagerFactory</code> 创建。</li></ul></li><li><p><strong><code>javax.persistence.EntityManagerFactory</code></strong></p><ul><li><strong>作用</strong>：创建 <code>EntityManager</code>，类似 <code>SessionFactory</code>。</li><li><strong>特点</strong>：线程安全，全局单例。</li></ul></li><li><p><strong><code>javax.persistence.Query</code></strong></p><ul><li><strong>作用</strong>：执行 JPQL（类似 HQL）或原生 SQL 查询。</li><li><strong>获取方式</strong>：通过 <code>EntityManager.createQuery()</code> 创建。</li></ul></li><li><p><strong><code>javax.persistence.EntityTransaction</code></strong></p><ul><li><strong>作用</strong>：管理 JPA 事务。</li><li><strong>获取方式</strong>：通过 <code>EntityManager.getTransaction()</code> 获取。</li></ul></li></ol><h5 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a><strong>常用方法</strong></h5><ul><li><p><strong><code>EntityManager</code> 方法</strong>：</p><ul><li><code>persist(Object)</code>：将实体设为持久化状态。</li><li><code>merge(Object)</code>：合并 detached 状态的实体。</li><li><code>remove(Object)</code>：删除实体。</li><li><code>find(Class, Object)</code>：根据 ID 查找实体。</li><li><code>createQuery(String)</code>：创建 JPQL 查询。</li><li><code>createNativeQuery(String)</code>：创建原生 SQL 查询。</li><li><code>flush()</code>：同步持久化上下文。</li><li><code>detach(Object)</code>：将实体从持久化上下文中分离。</li><li><code>getTransaction()</code>：获取事务对象。</li></ul></li><li><p><strong><code>EntityManagerFactory</code> 方法</strong>：</p><ul><li><code>createEntityManager()</code>：创建 <code>EntityManager</code>。</li><li><code>close()</code>：关闭工厂。</li></ul></li><li><p><strong><code>Query</code> 方法</strong>：</p><ul><li>类似 <code>Session</code> 的 <code>Query</code> 方法，如 <code>getResultList()</code>、<code>setParameter()</code>。</li></ul></li></ul><h5 id="Spring-Boot-示例（JPA）"><a href="#Spring-Boot-示例（JPA）" class="headerlink" title="Spring Boot 示例（JPA）"></a><strong>Spring Boot 示例（JPA）</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// Getters and Setters</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRepository</span> &#123;</span><br><span class="line">    <span class="meta">@PersistenceContext</span></span><br><span class="line">    <span class="keyword">private</span> EntityManager entityManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        entityManager.persist(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> entityManager.find(User.class, id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-常用注解"><a href="#3-常用注解" class="headerlink" title="3. 常用注解"></a><strong>3. 常用注解</strong></h4><p>Hibernate 依赖注解定义实体和映射关系，常用注解包括：</p><ul><li><strong><code>@Entity</code></strong>：标记类为实体。</li><li><strong><code>@Table(name)</code></strong>：指定数据库表名。</li><li><strong><code>@Id</code></strong>：标记主键。</li><li><strong><code>@GeneratedValue</code></strong>：定义主键生成策略（如 <code>AUTO</code>、<code>IDENTITY</code>）。</li><li><strong><code>@Column</code></strong>：映射字段到列，指定属性（如 <code>nullable</code>、<code>length</code>）。</li><li><strong><code>@OneToMany</code> &#x2F; <code>@ManyToOne</code> &#x2F; <code>@ManyToMany</code></strong>：定义关联关系。</li><li><strong><code>@JoinColumn</code></strong>：指定外键列。</li><li><strong><code>@Fetch</code></strong>：设置加载策略（<code>FetchType.LAZY</code> 或 <code>EAGER</code>）。</li><li><strong><code>@Transactional</code></strong>（Spring）：管理事务。</li></ul><hr><h3 id="实践建议：掌握-Hibernate-的步骤"><a href="#实践建议：掌握-Hibernate-的步骤" class="headerlink" title="实践建议：掌握 Hibernate 的步骤"></a><strong>实践建议：掌握 Hibernate 的步骤</strong></h3><ol><li><p><strong>从简单实体开始</strong>：</p><ul><li>创建一个简单的实体类（如 <code>User</code>），使用 <code>@Entity</code>、<code>@Id</code> 等注解。</li><li>配置 <code>hibernate.cfg.xml</code> 或 Spring Boot 的 <code>application.properties</code>。</li><li>实现基本的 CRUD 操作，熟悉 <code>Session</code> 或 <code>EntityManager</code>。</li></ul></li><li><p><strong>学习 HQL 和 JPQL</strong>：</p><ul><li>编写简单的 HQL 查询（如 <code>from User where name = :name</code>）。</li><li>使用 <code>Query</code> 设置参数和分页。</li></ul></li><li><p><strong>探索关联映射</strong>：</p><ul><li>创建两个实体（如 <code>User</code> 和 <code>Order</code>），使用 <code>@OneToMany</code> 建立关系。</li><li>测试级联操作（如 <code>CascadeType.ALL</code>）和延迟加载。</li></ul></li><li><p><strong>集成 Spring</strong>：</p><ul><li>使用 Spring 的 <code>@Repository</code> 和 <code>@Transactional</code> 管理 <code>Session</code> 或 <code>EntityManager</code>。</li><li>尝试 Spring Data JPA，简化 DAO 层代码。</li></ul></li><li><p><strong>调试和优化</strong>：</p><ul><li>开启 <code>hibernate.show_sql</code> 和 <code>hibernate.format_sql</code> 查看生成的 SQL。</li><li>解决常见问题，如 <code>LazyInitializationException</code> 或 N+1 查询。</li><li>学习使用 <code>@BatchSize</code> 或二级缓存优化性能。</li></ul></li></ol><hr><h3 id="推荐练习项目"><a href="#推荐练习项目" class="headerlink" title="推荐练习项目"></a><strong>推荐练习项目</strong></h3><ol><li><p><strong>用户管理系统</strong>：</p><ul><li>实体：<code>User</code>（ID、姓名、邮箱）、<code>Role</code>（ID、名称）。</li><li>功能：用户增删改查、角色分配（多对多关系）。</li><li>技术：Spring Boot + Hibernate + MySQL。</li></ul></li><li><p><strong>博客系统</strong>：</p><ul><li>实体：<code>Post</code>（ID、标题、内容）、<code>Comment</code>（ID、内容、Post）。</li><li>功能：发布帖子、添加评论（一对多关系）。</li><li>技术：Spring Boot + JPA + H2 数据库。</li></ul></li></ol><hr><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ul><li><strong>版本兼容</strong>：确保 Hibernate、Spring 和数据库驱动版本兼容（如 Hibernate 5.x 搭配 Spring 5.x）。</li><li><strong>事务管理</strong>：始终在事务中执行写操作，避免非事务性错误。</li><li><strong>资源释放</strong>：手动管理 <code>Session</code> 时，确保关闭（Spring 自动管理）。</li><li><strong>性能监控</strong>：关注生成的 SQL，避免 N+1 查询问题。</li></ul><hr><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><strong>入手方式</strong>：从配置环境、创建简单实体开始，逐步学习 CRUD、HQL 和关联映射，结合 Spring 实践。</li><li><strong>核心类&#x2F;接口</strong>：<code>Session</code>、<code>SessionFactory</code>（Hibernate 模式）或 <code>EntityManager</code>、<code>EntityManagerFactory</code>（JPA 模式）。</li><li><strong>核心方法</strong>：<code>save</code>、<code>get</code>、<code>createQuery</code>（Session）或 <code>persist</code>、<code>find</code>、<code>createQuery</code>（EntityManager）。</li><li><strong>实践重点</strong>：搭建小项目，熟悉注解、查询和事务管理。</li></ul><p>如果你有具体问题（如配置示例、某个方法的用法、调试错误），请提供更多细节，我可以进一步指导！</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Hibernate </tag>
            
            <tag> ORM </tag>
            
            <tag> JPA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka 深度学习笔记</title>
      <link href="/posts/1562.html"/>
      <url>/posts/1562.html</url>
      
        <content type="html"><![CDATA[<h2 id="📖-简介"><a href="#📖-简介" class="headerlink" title="📖 简介"></a>📖 简介</h2><p>Apache Kafka 是一个分布式流处理平台,最初由 LinkedIn 开发。早期版本使用 Scala 编写并运行在 JVM 上,后续版本逐渐迁移至 Java 实现。</p><h2 id="🔑-核心概念"><a href="#🔑-核心概念" class="headerlink" title="🔑 核心概念"></a>🔑 核心概念</h2><h3 id="副本机制"><a href="#副本机制" class="headerlink" title="副本机制"></a>副本机制</h3><ul><li><p><strong>Leader Replica（主副本）</strong></p><ul><li>负责处理所有客户端的读写请求</li><li>维护消息的写入顺序和偏移量等元数据</li></ul></li><li><p><strong>Follower Replica（从副本）</strong></p><ul><li>从 Leader 同步最新数据</li><li>提供数据冗余和高可用保障</li><li>不对外提供读写服务</li></ul></li></ul><h3 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h3><p>Kafka 使用高效的日志存储机制来持久化消息：</p><ul><li><p><strong>顺序 I&#x2F;O 追加写入</strong></p><ul><li>消息以追加方式顺序写入日志文件</li><li>充分利用磁盘顺序读写的高性能特性</li></ul></li><li><p><strong>Log Segment 分段管理</strong></p><ul><li>将日志按照 Log Segment 进行分段</li><li>定时清理过期的 Segment 来释放磁盘空间</li></ul></li></ul><hr><h2 id="📚-核心术语"><a href="#📚-核心术语" class="headerlink" title="📚 核心术语"></a>📚 核心术语</h2><table><thead><tr><th>术语</th><th>英文</th><th>说明</th></tr></thead><tbody><tr><td><strong>消息</strong></td><td>Record</td><td>Kafka 处理的主要对象</td></tr><tr><td><strong>主题</strong></td><td>Topic</td><td>承载消息的逻辑容器，用于区分不同的业务</td></tr><tr><td><strong>分区</strong></td><td>Partition</td><td>一个有序不变的消息序列，每个主题可以有多个分区</td></tr><tr><td><strong>消息位移</strong></td><td>Offset</td><td>分区中每条消息的位置信息，单调递增且不变</td></tr><tr><td><strong>副本</strong></td><td>Replica</td><td>消息的多个拷贝，分为 Leader 和 Follower 副本</td></tr><tr><td><strong>生产者</strong></td><td>Producer</td><td>向主题发布新消息的应用程序</td></tr><tr><td><strong>消费者</strong></td><td>Consumer</td><td>从主题订阅消息的应用程序</td></tr><tr><td><strong>消费者位移</strong></td><td>Consumer Offset</td><td>表征消费者消费进度</td></tr><tr><td><strong>消费者组</strong></td><td>Consumer Group</td><td>多个消费者实例组成的组，同时消费多个分区以实现高吞吐</td></tr><tr><td><strong>重平衡</strong></td><td>Rebalance</td><td>消费者组内某个实例挂掉后，其他实例自动重新分配订阅分区的过程</td></tr></tbody></table><h3 id="高级概念"><a href="#高级概念" class="headerlink" title="高级概念"></a>高级概念</h3><ul><li><p><strong>刷盘（Flush）</strong></p><ul><li>将内存中的数据持久化到磁盘的过程</li><li>消息先写入内存缓冲区，再根据策略刷写到磁盘</li><li>保证数据持久性，即使服务器重启也不会丢失</li></ul></li><li><p><strong>副本因子（Replication Factor）</strong></p><ul><li>定义每个分区有多少个副本</li><li>例如副本因子为 3，意味着 1 个 Leader + 2 个 Follower</li></ul></li><li><p><strong>Purgatory（炼狱）</strong></p><ul><li>用于处理延迟操作的内部机制</li><li>处理不能立即完成，需要等待条件满足的操作</li><li>例如事务相关操作</li></ul></li></ul><hr><h2 id="🚀-部署配置"><a href="#🚀-部署配置" class="headerlink" title="🚀 部署配置"></a>🚀 部署配置</h2><h3 id="Broker-参数配置"><a href="#Broker-参数配置" class="headerlink" title="Broker 参数配置"></a>Broker 参数配置</h3><h4 id="存储配置"><a href="#存储配置" class="headerlink" title="存储配置"></a>存储配置</h4><p><strong><code>log.dirs</code></strong>（推荐）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">log.dirs</span>=<span class="string">/home/kafka/data1,/home/kafka/data2,/home/kafka/data3</span></span><br></pre></td></tr></table></figure><ul><li>建议将各个目录挂载到不同的物理磁盘</li><li><strong>优势</strong>：提升读写性能 + 实现故障转移</li></ul><p><strong><code>log.dir</code></strong></p><ul><li>单个路径配置，补充 <code>log.dirs</code> 使用</li></ul><h4 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h4><p><strong><code>listeners</code></strong></p><ul><li>告诉外部连接者使用什么协议连接</li><li>格式：<code>&lt;protocol&gt;://&lt;host&gt;:&lt;port&gt;</code></li><li>示例：<code>PLAINTEXT://localhost:9092</code></li></ul><p><strong><code>advertised.listeners</code></strong></p><ul><li>Broker 对外发布的监听器地址</li><li>客户端实际连接的地址</li></ul><p><strong>自定义协议配置</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">listeners</span>=<span class="string">CONTROLLER://localhost:9992</span></span><br><span class="line"><span class="attr">listener.security.protocol.map</span>=<span class="string">CONTROLLER:PLAINTEXT</span></span><br></pre></td></tr></table></figure><h4 id="Topic-管理"><a href="#Topic-管理" class="headerlink" title="Topic 管理"></a>Topic 管理</h4><table><thead><tr><th>参数</th><th>推荐值</th><th>说明</th></tr></thead><tbody><tr><td><code>auto.create.topics.enable</code></td><td><strong>false</strong></td><td>禁止自动创建 Topic，避免线上未知问题</td></tr><tr><td><code>unclean.leader.election.enable</code></td><td><strong>false</strong></td><td>禁止不干净的 Leader 选举，防止数据丢失</td></tr><tr><td><code>auto.leader.rebalance.enable</code></td><td><strong>false</strong></td><td>禁止定期 Leader 选举，避免频繁切换</td></tr></tbody></table><h4 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h4><p><strong>消息保留时间</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">log.retention.hours</span>=<span class="string">168    # 7天</span></span><br><span class="line"><span class="attr">log.retention.minutes</span>=<span class="string">10080</span></span><br><span class="line"><span class="attr">log.retention.ms</span>=<span class="string">604800000  # 优先级最高</span></span><br></pre></td></tr></table></figure><p><strong>消息大小限制</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">message.max.bytes</span>=<span class="string">1048576   # 1MB</span></span><br><span class="line"><span class="attr">log.retention.bytes</span>=<span class="string">-1      # 无限制</span></span><br></pre></td></tr></table></figure><h3 id="Topic-级别参数"><a href="#Topic-级别参数" class="headerlink" title="Topic 级别参数"></a>Topic 级别参数</h3><p>Topic 参数优先级高于 Broker 全局参数：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 消息保留时间</span></span><br><span class="line"><span class="attr">retention.ms</span>=<span class="string">604800000  # 7天</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 磁盘空间配额</span></span><br><span class="line"><span class="attr">retention.bytes</span>=<span class="string">-1      # 无限制</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 最大消息大小</span></span><br><span class="line"><span class="attr">max.message.bytes</span>=<span class="string">1048576</span></span><br></pre></td></tr></table></figure><h3 id="JVM-参数调优"><a href="#JVM-参数调优" class="headerlink" title="JVM 参数调优"></a>JVM 参数调优</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 堆内存配置（推荐 6GB）</span></span><br><span class="line"><span class="built_in">export</span> KAFKA_HEAP_OPTS=<span class="string">&quot;-Xms6g -Xmx6g&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># GC 配置</span></span><br><span class="line"><span class="built_in">export</span> KAFKA_JVM_PERFORMANCE_OPTS=<span class="string">&quot;-XX:+UseG1GC -XX:MaxGCPauseMillis=20&quot;</span></span><br></pre></td></tr></table></figure><hr><h2 id="🎯-分区策略"><a href="#🎯-分区策略" class="headerlink" title="🎯 分区策略"></a>🎯 分区策略</h2><p>决定生产者将消息发送到哪个分区的算法。</p><h3 id="自定义分区策略"><a href="#自定义分区策略" class="headerlink" title="自定义分区策略"></a>自定义分区策略</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 Partitioner 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomPartitioner</span> <span class="keyword">implements</span> <span class="title class_">org</span>.apache.kafka.clients.producer.Partitioner &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(String topic, Object key, <span class="type">byte</span>[] keyBytes, </span></span><br><span class="line"><span class="params">                        Object value, <span class="type">byte</span>[] valueBytes, Cluster cluster)</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义分区逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置参数：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">partitioner.class</span>=<span class="string">com.example.CustomPartitioner</span></span><br></pre></td></tr></table></figure><h3 id="内置分区策略"><a href="#内置分区策略" class="headerlink" title="内置分区策略"></a>内置分区策略</h3><h4 id="1-轮询策略（Round-Robin）"><a href="#1-轮询策略（Round-Robin）" class="headerlink" title="1. 轮询策略（Round-Robin）"></a>1. 轮询策略（Round-Robin）</h4><p><strong>特点</strong>：</p><ul><li>Kafka 默认策略</li><li>消息均匀分配到所有分区</li><li>最佳负载均衡表现</li></ul><p><strong>适用场景</strong>：</p><ul><li>无需保证消息顺序</li><li>追求负载均衡</li></ul><h4 id="2-随机策略（Random）"><a href="#2-随机策略（Random）" class="headerlink" title="2. 随机策略（Random）"></a>2. 随机策略（Random）</h4><p><strong>特点</strong>：</p><ul><li>随机选择分区</li><li>理论上也能实现负载均衡</li><li>但效果不如轮询策略</li></ul><h4 id="3-按键保序策略（Key-Ordering）"><a href="#3-按键保序策略（Key-Ordering）" class="headerlink" title="3. 按键保序策略（Key-Ordering）"></a>3. 按键保序策略（Key-Ordering）</h4><p><strong>特点</strong>：</p><ul><li>相同 Key 的消息进入同一分区</li><li>保证相同 Key 的消息顺序</li></ul><p><strong>实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line"><span class="keyword">return</span> Math.abs(key.hashCode()) % partitions.size();</span><br></pre></td></tr></table></figure><p><strong>适用场景</strong>：</p><ul><li>需要保证相同 Key 的消息顺序</li><li>例如：同一用户的操作日志</li></ul><hr><h2 id="🎮-Kafka-控制器"><a href="#🎮-Kafka-控制器" class="headerlink" title="🎮 Kafka 控制器"></a>🎮 Kafka 控制器</h2><h3 id="角色定位"><a href="#角色定位" class="headerlink" title="角色定位"></a>角色定位</h3><p>Kafka 集群中只能有<strong>一台 Broker</strong> 充当控制器（Controller）角色。</p><h3 id="主要职责"><a href="#主要职责" class="headerlink" title="主要职责"></a>主要职责</h3><h4 id="1-分区分配"><a href="#1-分区分配" class="headerlink" title="1. 分区分配"></a>1. 分区分配</h4><p>控制器负责决定每个分区的副本分布：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：Topic 有 2 个分区，副本因子为 2</span><br><span class="line">- 分区1: Leader→Broker1, Follower→Broker2</span><br><span class="line">- 分区2: Leader→Broker2, Follower→Broker1</span><br></pre></td></tr></table></figure><h4 id="2-Leader-副本选举"><a href="#2-Leader-副本选举" class="headerlink" title="2. Leader 副本选举"></a>2. Leader 副本选举</h4><ul><li>当 Leader 副本所在 Broker 宕机时</li><li>控制器从 ISR（In-Sync Replicas）中选举新的 Leader</li></ul><h4 id="3-主题管理"><a href="#3-主题管理" class="headerlink" title="3. 主题管理"></a>3. 主题管理</h4><ul><li>接受来自管理工具或 API 的请求</li><li>处理主题的创建和删除操作</li></ul><h4 id="4-集群监控与协调"><a href="#4-集群监控与协调" class="headerlink" title="4. 集群监控与协调"></a>4. 集群监控与协调</h4><ul><li>通过心跳机制检测 Broker 存活状态</li><li>节点失联时重新分配分区和副本</li></ul><h3 id="控制器选举"><a href="#控制器选举" class="headerlink" title="控制器选举"></a>控制器选举</h3><p><strong>选举机制</strong>：</p><ol><li>Broker 启动时尝试在 ZooKeeper 中创建 <code>/controller</code> 节点</li><li>第一个成功创建节点的 Broker 成为控制器</li><li>其他 Broker 通过 Watch 机制监控控制器状态</li></ol><p><strong>Failover 机制</strong>：</p><ul><li>ZooKeeper 检测到控制器节点失效</li><li>删除 <code>/controller</code> 节点</li><li>存活的 Broker 重新竞选新的控制器</li></ul><hr><h2 id="🔒-消息交付可靠性"><a href="#🔒-消息交付可靠性" class="headerlink" title="🔒 消息交付可靠性"></a>🔒 消息交付可靠性</h2><p>Kafka 提供三种消息交付可靠性保障：</p><h3 id="1-最多一次（At-Most-Once）"><a href="#1-最多一次（At-Most-Once）" class="headerlink" title="1. 最多一次（At Most Once）"></a>1. 最多一次（At Most Once）</h3><ul><li><strong>特征</strong>：消息可能丢失，但绝不重复</li><li><strong>场景</strong>：日志收集等对数据完整性要求不高的场景</li></ul><h3 id="2-至少一次（At-Least-Once）"><a href="#2-至少一次（At-Least-Once）" class="headerlink" title="2. 至少一次（At Least Once）"></a>2. 至少一次（At Least Once）</h3><ul><li><strong>特征</strong>：消息不会丢失，但可能重复</li><li><strong>默认</strong>：Kafka 默认提供此级别保障</li><li><strong>场景</strong>：大多数业务场景</li></ul><h3 id="3-精确一次（Exactly-Once）"><a href="#3-精确一次（Exactly-Once）" class="headerlink" title="3. 精确一次（Exactly Once）"></a>3. 精确一次（Exactly Once）</h3><ul><li><strong>特征</strong>：消息不丢失也不重复</li><li><strong>实现</strong>：通过幂等性 + 事务机制</li><li><strong>场景</strong>：金融交易等对数据准确性要求极高的场景</li></ul><hr><h2 id="❓-常见问题"><a href="#❓-常见问题" class="headerlink" title="❓ 常见问题"></a>❓ 常见问题</h2><h3 id="Q1-为什么-Kafka-不允许从副本读取数据？"><a href="#Q1-为什么-Kafka-不允许从副本读取数据？" class="headerlink" title="Q1: 为什么 Kafka 不允许从副本读取数据？"></a>Q1: 为什么 Kafka 不允许从副本读取数据？</h3><p>与 MySQL 主从复制不同，Kafka 的从副本不对外提供读服务。原因如下：</p><h4 id="1-一致性模型差异"><a href="#1-一致性模型差异" class="headerlink" title="1. 一致性模型差异"></a>1. 一致性模型差异</h4><p><strong>Kafka</strong>：</p><ul><li>基于日志的消息传递模型</li><li>强调消息顺序和实时性</li><li>从副本可能存在同步延迟，导致数据不一致</li></ul><p><strong>MySQL</strong>：</p><ul><li>ACID 事务模型</li><li>从库应用完 Binlog 后数据一致</li><li>可以安全地提供读服务</li></ul><h4 id="2-设计目标不同"><a href="#2-设计目标不同" class="headerlink" title="2. 设计目标不同"></a>2. 设计目标不同</h4><p><strong>Kafka</strong>：</p><ul><li>专注于高吞吐量的消息写入和顺序读取</li><li>允许从副本读取会增加复杂性</li></ul><p><strong>MySQL</strong>：</p><ul><li>支持复杂查询和事务处理</li><li>读写分离可以分担主库压力</li></ul><h4 id="3-故障恢复复杂性"><a href="#3-故障恢复复杂性" class="headerlink" title="3. 故障恢复复杂性"></a>3. 故障恢复复杂性</h4><p><strong>Kafka</strong>：</p><ul><li>从副本提供读服务时，故障切换更复杂</li><li>需要处理正在进行的读操作</li></ul><p><strong>MySQL</strong>：</p><ul><li>从库故障恢复相对简单</li><li>重新同步 Binlog 即可</li></ul><h3 id="Q2-Kafka-如何保证消息顺序性？"><a href="#Q2-Kafka-如何保证消息顺序性？" class="headerlink" title="Q2: Kafka 如何保证消息顺序性？"></a>Q2: Kafka 如何保证消息顺序性？</h3><h4 id="1-分区有序"><a href="#1-分区有序" class="headerlink" title="1. 分区有序"></a>1. 分区有序</h4><ul><li>每个分区内的消息严格有序</li><li>全局有序需要使用单分区（牺牲并发性）</li></ul><h4 id="2-同步发送"><a href="#2-同步发送" class="headerlink" title="2. 同步发送"></a>2. 同步发送</h4><p>配置 <code>acks=all</code> 保证消息持久性：</p><table><thead><tr><th>acks 值</th><th>说明</th><th>可靠性</th><th>性能</th></tr></thead><tbody><tr><td><strong>0</strong></td><td>不等待确认，立即返回</td><td>❌ 最低</td><td>✅ 最高</td></tr><tr><td><strong>1</strong></td><td>等待 Leader 确认</td><td>⚠️ 中等</td><td>⚠️ 中等</td></tr><tr><td><strong>all</strong></td><td>等待所有 ISR 确认</td><td>✅ 最高</td><td>❌ 最低</td></tr></tbody></table><h4 id="3-消息偏移量"><a href="#3-消息偏移量" class="headerlink" title="3. 消息偏移量"></a>3. 消息偏移量</h4><ul><li>每个消息有唯一的 Offset</li><li>消费者按 Offset 顺序消费</li><li>保证消费顺序与生产顺序一致</li></ul><h3 id="Q3-Kafka-消息如何存储？"><a href="#Q3-Kafka-消息如何存储？" class="headerlink" title="Q3: Kafka 消息如何存储？"></a>Q3: Kafka 消息如何存储？</h3><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Topic</span><br><span class="line">└── Partition</span><br><span class="line">    └── Log Segment</span><br><span class="line">        ├── .log    # 消息数据</span><br><span class="line">        └── .index  # 索引文件</span><br></pre></td></tr></table></figure><h4 id="存储特性"><a href="#存储特性" class="headerlink" title="存储特性"></a>存储特性</h4><ul><li><strong>格式</strong>：优化的日志格式</li><li><strong>不可变</strong>：消息一旦写入不可修改</li><li><strong>顺序追加</strong>：新消息追加到日志末尾</li><li><strong>分段管理</strong>：Log Segment 便于管理和清理</li></ul><hr><h2 id="💡-生产环境最佳实践"><a href="#💡-生产环境最佳实践" class="headerlink" title="💡 生产环境最佳实践"></a>💡 生产环境最佳实践</h2><h3 id="关键参数配置"><a href="#关键参数配置" class="headerlink" title="关键参数配置"></a>关键参数配置</h3><h4 id="auto-create-topics-enable-false"><a href="#auto-create-topics-enable-false" class="headerlink" title="auto.create.topics.enable &#x3D; false"></a>auto.create.topics.enable &#x3D; false</h4><p><strong>理由</strong>：</p><ul><li>避免因拼写错误自动创建 Topic</li><li>例如：<code>test</code> 误写为 <code>tst</code>，会自动创建 <code>tst</code> Topic</li><li>大公司应由运维统一管理 Topic</li></ul><h4 id="unclean-leader-election-enable-false"><a href="#unclean-leader-election-enable-false" class="headerlink" title="unclean.leader.election.enable &#x3D; false"></a>unclean.leader.election.enable &#x3D; false</h4><p><strong>场景</strong>：所有高质量副本都挂掉了，怎么办？</p><p><strong>选择</strong>：</p><ul><li><code>false</code>：坚持原则，分区不可用（保证数据完整性）</li><li><code>true</code>：降级服务，允许落后副本成为 Leader（可能丢数据）</li></ul><p><strong>推荐</strong>：生产环境设置为 <code>false</code></p><h4 id="auto-leader-rebalance-enable-false"><a href="#auto-leader-rebalance-enable-false" class="headerlink" title="auto.leader.rebalance.enable &#x3D; false"></a>auto.leader.rebalance.enable &#x3D; false</h4><p><strong>问题</strong>：定期换 Leader 的代价很高</p><ul><li>所有客户端需要切换连接</li><li>没有实质性能收益</li><li>可能影响服务稳定性</li></ul><p><strong>推荐</strong>：生产环境设置为 <code>false</code></p><hr><h2 id="📚-参考资料"><a href="#📚-参考资料" class="headerlink" title="📚 参考资料"></a>📚 参考资料</h2><ul><li><a href="https://kafka.apache.org/documentation/">Apache Kafka 官方文档</a></li><li><a href="https://www.confluent.io/resources/kafka-the-definitive-guide/">Kafka: The Definitive Guide</a></li><li><a href="https://time.geekbang.org/column/intro/100029201">Kafka 核心技术与实战</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP 事务失效与底层代理机制深度总结</title>
      <link href="/posts/60441.html"/>
      <url>/posts/60441.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-AOP-事务失效与底层代理机制深度总结"><a href="#Spring-AOP-事务失效与底层代理机制深度总结" class="headerlink" title="Spring AOP 事务失效与底层代理机制深度总结"></a>Spring AOP 事务失效与底层代理机制深度总结</h1><h2 id="1-核心问题：为什么自调用导致事务失效？"><a href="#1-核心问题：为什么自调用导致事务失效？" class="headerlink" title="1. 核心问题：为什么自调用导致事务失效？"></a>1. 核心问题：为什么自调用导致事务失效？</h2><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>在同一个类中，方法 A 调用方法 B（<code>this.methodB()</code>），即使方法 B 上加了 <code>@Transactional</code> 注解，事务依然不生效。</p><h3 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h3><p>Spring AOP 的默认实现基于 <strong>代理模式 (Proxy Pattern)</strong>。Spring 容器中注入的 Bean 实际上是一个 <strong>代理对象 (Proxy)</strong>，它持有你编写的 <strong>目标对象 (Target)</strong>。</p><ul><li><strong>生效路径</strong>：外部调用 $\rightarrow$ Proxy $\rightarrow$ 事务拦截器 (Interceptor) $\rightarrow$ Target。</li><li><strong>失效路径</strong>：Target 内部调用 $\rightarrow$ <code>this.methodB()</code> $\rightarrow$ Target。</li></ul><p>此时，<code>this</code> 指针指向的是<strong>目标对象本身</strong>。代码执行流直接在目标对象内部流转，完全<strong>绕过</strong>了外层的代理对象及其持有的事务拦截器。</p><h3 id="形象比喻"><a href="#形象比喻" class="headerlink" title="形象比喻"></a>形象比喻</h3><ul><li><strong>Proxy (代理)</strong>：大楼门口的<strong>安检员</strong>。</li><li><strong>Target (目标)</strong>：大楼里的<strong>员工</strong>。</li><li><strong>外部访问</strong>：访客找员工，必须经过安检（事务生效）。</li><li><strong>内部自调用</strong>：员工之间互找，直接在楼里见面，不需要跑出去再过一次安检（事务失效）。</li></ul><hr><h2 id="2-解决方案-按架构师推荐度排序"><a href="#2-解决方案-按架构师推荐度排序" class="headerlink" title="2. 解决方案 (按架构师推荐度排序)"></a>2. 解决方案 (按架构师推荐度排序)</h2><table><thead><tr><th><strong>方案</strong></th><th><strong>具体做法</strong></th><th><strong>评价</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>1. 架构重构 (Refactoring)</strong></td><td>将需要事务的方法提取到<strong>独立的 Service</strong> 中，通过 Bean 注入调用。</td><td>⭐⭐⭐⭐⭐ (强烈推荐)</td><td>符合单一职责原则 (SRP)，代码结构最清晰。</td></tr><tr><td><strong>2. 自我注入 (Self-Injection)</strong></td><td>在类中注入自身 (<code>@Lazy</code> 解决循环依赖)，调用 <code>self.methodB()</code>。</td><td>⭐⭐⭐ (可用)</td><td>业务逻辑紧密耦合，不适合拆分文件时。</td></tr><tr><td><strong>3. AopContext</strong></td><td>使用 <code>AopContext.currentProxy()</code> 强转获取当前代理对象。</td><td>⭐ (不推荐)</td><td>代码侵入性强，与 Spring API 强耦合。</td></tr><tr><td><strong>4. AspectJ</strong></td><td>放弃代理模式，使用字节码织入 (Weaving)。</td><td>N&#x2F;A (特殊需求)</td><td>追求极致性能或必须在 private&#x2F;自调用中生效时。</td></tr></tbody></table><hr><h2 id="3-深度辨析：JDK-动态代理-vs-CGLIB"><a href="#3-深度辨析：JDK-动态代理-vs-CGLIB" class="headerlink" title="3. 深度辨析：JDK 动态代理 vs CGLIB"></a>3. 深度辨析：JDK 动态代理 vs CGLIB</h2><p><img src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/SpringAOP.webp" alt="SpringAOP"></p><h3 id="常见误区"><a href="#常见误区" class="headerlink" title="常见误区"></a>常见误区</h3><blockquote><p><strong>误区</strong>：”JDK Proxy 会导致自调用失效，换成 CGLIB 就能解决了。”</p><p><strong>真相</strong>：<strong>错误的。</strong> 无论是 JDK Proxy 还是 CGLIB，只要是基于<strong>代理模式</strong>，自调用都会失效。因为它们底层架构都是 <code>Proxy</code> 持有 <code>Target</code>。</p></blockquote><h3 id="技术对比表"><a href="#技术对比表" class="headerlink" title="技术对比表"></a>技术对比表</h3><table><thead><tr><th><strong>维度</strong></th><th><strong>JDK 动态代理</strong></th><th><strong>CGLIB (Code Generation Library)</strong></th></tr></thead><tbody><tr><td><strong>实现机制</strong></td><td>基于 <strong>接口 (Interface)</strong></td><td>基于 <strong>继承 (Subclass)</strong></td></tr><tr><td><strong>类关系</strong></td><td>代理类与目标类是 <strong>兄弟关系</strong></td><td>代理类是目标类的 <strong>子类</strong></td></tr><tr><td><strong>核心限制</strong></td><td>目标类 <strong>必须实现接口</strong></td><td>目标类或方法 <strong>不能是 Final</strong></td></tr><tr><td><strong>调用方式</strong></td><td><strong>反射</strong> (<code>Method.invoke</code>)</td><td><strong>FastClass 索引</strong> (直接调用)</td></tr><tr><td><strong>自调用支持</strong></td><td>❌ 不支持</td><td>❌ 不支持</td></tr><tr><td><strong>Spring 默认</strong></td><td>旧版本 (有接口时默认)</td><td><strong>Spring Boot 2.0+ 默认</strong></td></tr></tbody></table><hr><h2 id="4-性能黑科技：CGLIB-的-FastClass-机制"><a href="#4-性能黑科技：CGLIB-的-FastClass-机制" class="headerlink" title="4. 性能黑科技：CGLIB 的 FastClass 机制"></a>4. 性能黑科技：CGLIB 的 FastClass 机制</h2><p>CGLIB 在运行时之所以高效，是因为它通过 <strong>FastClass</strong> 机制规避了 Java 反射 API 的开销。</p><h3 id="FastClass-原理"><a href="#FastClass-原理" class="headerlink" title="FastClass 原理"></a>FastClass 原理</h3><p>CGLIB 在生成代理类时，会利用 ASM 字节码技术额外生成一个 <code>FastClass</code>。它相当于把”反射查找”变成了”硬编码的索引跳转”。</p><p><strong>伪代码逻辑：</strong></p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// FastClass 就像一个巨大的 switch-case，建立了 方法签名 -&gt; 索引 的映射</span><br><span class="line">public Object invoke(int index, Object target, Object[] args) &#123;</span><br><span class="line">    MyService service = (MyService) target;</span><br><span class="line">    // 直接调用，没有反射的 invoke() 开销</span><br><span class="line">    switch (index) &#123;</span><br><span class="line">        case 1: return service.login(); </span><br><span class="line">        case 2: return service.logout();</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-FastClass"><a href="#总结-FastClass" class="headerlink" title="总结 FastClass"></a>总结 FastClass</h3><ul><li><strong>本质</strong>：<strong>空间换时间</strong>。通过生成更多的字节码类，建立索引。</li><li><strong>优势</strong>：<strong>运行时 (Runtime)</strong> 调用速度极快，接近原生 Java 方法调用，不仅省去了反射的安全检查，还能享受 JVM 的内联优化。</li><li><strong>劣势</strong>：<strong>启动时间</strong>稍慢（需要生成和加载字节码）。</li></ul><hr><h2 id="5-架构师建议-“The-Spring-Way”"><a href="#5-架构师建议-“The-Spring-Way”" class="headerlink" title="5. 架构师建议 (“The Spring Way”)"></a>5. 架构师建议 (“The Spring Way”)</h2><ol><li><strong>首选重构</strong>：遇到自调用失效，首先反思类的职责是否过重。将事务逻辑拆分到不同 Service 是最优雅的解法。</li><li><strong>拥抱 CGLIB</strong>：在 Spring Boot 2.x&#x2F;3.x 时代，默认使用 CGLIB 是最佳实践（稳定、高效、无需接口），除非你有特殊的 JDK 原生洁癖。</li><li><strong>避坑 Final</strong>：使用 Spring 管理的 Bean（尤其是涉及 AOP&#x2F;事务的），<strong>严禁</strong>将类或方法设为 <code>final</code>，否则 CGLIB 无法生成子类代理，会导致启动报错或 AOP 失效。</li><li><strong>理解原理</strong>：不要盲目背诵“CGLIB 比 JDK 快”，要理解它是通过“启动时的复杂”换取了“运行时的简单”。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> AOP </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

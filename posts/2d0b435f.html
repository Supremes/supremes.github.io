<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Spring MVC | Supremes</title><meta name="author" content="Supremes"><meta name="copyright" content="Supremes"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="SpringMVC 工作原理引言Spring MVC 框架作为 Java Web 应用程序开发中广泛采用的框架，以其分层和松耦合的架构而闻名。这种架构清晰地分离了表示层、持久层和控制层，使得开发人员能够独立地处理各个模块，并将其组合成专业的 Web 应用程序。遵循 MVC 标准开发的 Web 应用程序更易于扩展、更新和管理，因为松耦合的分层结构使得在特定层进行修改变得更加便捷 1。本报告旨在深入探">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring MVC">
<meta property="og:url" content="https://supremes.github.io/posts/2d0b435f.html">
<meta property="og:site_name" content="Supremes">
<meta property="og:description" content="SpringMVC 工作原理引言Spring MVC 框架作为 Java Web 应用程序开发中广泛采用的框架，以其分层和松耦合的架构而闻名。这种架构清晰地分离了表示层、持久层和控制层，使得开发人员能够独立地处理各个模块，并将其组合成专业的 Web 应用程序。遵循 MVC 标准开发的 Web 应用程序更易于扩展、更新和管理，因为松耦合的分层结构使得在特定层进行修改变得更加便捷 1。本报告旨在深入探">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/SpringMVC.webp">
<meta property="article:published_time" content="2025-12-04T20:51:26.000Z">
<meta property="article:modified_time" content="2025-12-04T21:04:00.000Z">
<meta property="article:author" content="Supremes">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/SpringMVC.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Spring MVC",
  "url": "https://supremes.github.io/posts/2d0b435f.html",
  "image": "https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/SpringMVC.webp",
  "datePublished": "2025-12-04T20:51:26.000Z",
  "dateModified": "2025-12-04T21:04:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "Supremes",
      "url": "https://supremes.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/favicon/favicon.ico"><link rel="canonical" href="https://supremes.github.io/posts/2d0b435f.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":10},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring MVC',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Spring/"><i class="fa-fw fas fa-leaf"></i><span> Spring</span></a></li><li><a class="site-page child" href="/tags/Interview/"><i class="fa-fw fas fa-book"></i><span> 面试</span></a></li><li><a class="site-page child" href="/categories/database/"><i class="fa-fw fas fa-database"></i><span> 数据库</span></a></li><li><a class="site-page child" href="/categories/algorithm/"><i class="fa-fw fas fa-code"></i><span> 算法</span></a></li><li><a class="site-page child" href="/categories/security/"><i class="fa-fw fas fa-shield-alt"></i><span> 网络安全</span></a></li><li><a class="site-page child" href="/categories/message-queue/"><i class="fa-fw fas fa-envelope"></i><span> 消息队列</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/about_me"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/about/my_notes"><i class="fa-fw fas fa-note-sticky"></i><span> 备忘录</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/SpringMVC.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Supremes</span></a><a class="nav-page-title" href="/"><span class="site-name">Spring MVC</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Spring/"><i class="fa-fw fas fa-leaf"></i><span> Spring</span></a></li><li><a class="site-page child" href="/tags/Interview/"><i class="fa-fw fas fa-book"></i><span> 面试</span></a></li><li><a class="site-page child" href="/categories/database/"><i class="fa-fw fas fa-database"></i><span> 数据库</span></a></li><li><a class="site-page child" href="/categories/algorithm/"><i class="fa-fw fas fa-code"></i><span> 算法</span></a></li><li><a class="site-page child" href="/categories/security/"><i class="fa-fw fas fa-shield-alt"></i><span> 网络安全</span></a></li><li><a class="site-page child" href="/categories/message-queue/"><i class="fa-fw fas fa-envelope"></i><span> 消息队列</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/about_me"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/about/my_notes"><i class="fa-fw fas fa-note-sticky"></i><span> 备忘录</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Spring MVC</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-04T20:51:26.000Z" title="发表于 2025-12-04 20:51 20:51:26">2025-12-04 20:51</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-04T21:04:00.000Z" title="更新于 2025-12-04 21:04 21:04:00">2025-12-04 21:04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Spring/">Spring</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="SpringMVC-工作原理"><a href="#SpringMVC-工作原理" class="headerlink" title="SpringMVC 工作原理"></a>SpringMVC 工作原理</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Spring MVC 框架作为 Java Web 应用程序开发中广泛采用的框架，以其分层和松耦合的架构而闻名。这种架构清晰地分离了表示层、持久层和控制层，使得开发人员能够独立地处理各个模块，并将其组合成专业的 Web 应用程序。遵循 MVC 标准开发的 Web 应用程序更易于扩展、更新和管理，因为松耦合的分层结构使得在特定层进行修改变得更加便捷 1。本报告旨在深入探讨 Spring MVC 框架内 HTTP 请求的完整生命周期，从客户端发起请求到最终响应返回，详细阐述其内部的工作原理。</p>
<h2 id="理解模型-视图-控制器（MVC）模式"><a href="#理解模型-视图-控制器（MVC）模式" class="headerlink" title="理解模型-视图-控制器（MVC）模式"></a>理解模型-视图-控制器（MVC）模式</h2><p>模型-视图-控制器（MVC）是一种广泛应用于软件工程中的架构模式，旨在分离应用程序的不同关注点，从而提高代码的可维护性和可重用性 3。在 MVC 模式中，应用程序被划分为三个核心组件：</p>
<ul>
<li><strong>模型（Model）：</strong> 模型负责封装应用程序的数据和业务逻辑 2。它是应用程序的核心，管理着数据的存储、检索和处理 4。模型独立于用户界面，当模型中的数据发生变化时，它会通知视图进行更新 4。</li>
<li><strong>视图（View）：</strong> 视图负责呈现模型中的数据，并将其转化为用户可以理解的格式，例如 HTML、JSON 等 2。视图是被动组件，它从模型中获取数据并进行显示，不包含任何业务逻辑 4。</li>
<li><strong>控制器（Controller）：</strong> 控制器充当模型和视图之间的中介 2。它接收用户的输入（通常来自浏览器），并根据输入调用模型来执行相应的业务逻辑 4。处理完成后，控制器会选择合适的视图来显示模型中的数据 4。</li>
</ul>
<p>Spring MVC 框架正是基于 MVC 设计模式构建的，它通过一个核心组件——DispatcherServlet（前端控制器）来管理整个请求处理流程 2。DispatcherServlet 接收所有传入的 HTTP 请求，并将其分发给适当的处理器进行处理，从而实现了 MVC 模式在 Web 应用程序中的应用 2。</p>
<h2 id="核心调度器-DispatcherServlet"><a href="#核心调度器-DispatcherServlet" class="headerlink" title="核心调度器 DispatcherServlet"></a>核心调度器 DispatcherServlet</h2><p>DispatcherServlet 在 Spring MVC 框架中扮演着前端控制器的关键角色，它负责拦截所有进入应用程序的 HTTP 请求 1。作为应用程序的唯一入口点，DispatcherServlet 并不直接处理请求，而是将请求的处理委派给其他组件，从而实现请求的统一管理和调度 5。</p>
<p>DispatcherServlet 的初始化和生命周期管理由 Web 服务器（如 Tomcat）负责。在基于 XML 的配置中，DispatcherServlet 通常在 <code>web.xml</code> 文件中声明和映射 1。对于基于 Java 的配置，则可以通过 <code>WebConfiguration</code> 类进行配置 1。为了确保在服务器启动时 DispatcherServlet 被初始化，通常会配置 <code>&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</code> 5。DispatcherServlet 拥有自己的 <code>WebApplicationContext</code>，它是根应用程序上下文的子上下文，这种层级结构有助于清晰地分离 Web 相关的 Bean 和应用程序范围内的 Bean 5。通过在 <code>web.xml</code> 中将 DispatcherServlet 的 servlet 映射配置为 <code>&quot;/&quot;</code>，可以使得所有发往应用程序的请求都由该 DispatcherServlet 处理 1。</p>
<h2 id="请求导航：请求处理流程"><a href="#请求导航：请求处理流程" class="headerlink" title="请求导航：请求处理流程"></a>请求导航：请求处理流程</h2><p>Spring MVC 框架处理 HTTP 请求的过程可以细分为以下几个关键步骤 1：</p>
<ol>
<li><strong>客户端请求：</strong> 用户在浏览器中输入 Web URL，发起对特定页面的请求 1。</li>
<li><strong>DispatcherServlet 拦截：</strong> 所有的客户端请求首先被前端控制器 DispatcherServlet 拦截 1。这一步标志着 Spring MVC 框架开始介入请求的处理过程 1。</li>
<li><strong>HandlerMapping：</strong> DispatcherServlet 使用 HandlerMapping 组件来查找与当前请求 URL 相匹配的控制器（Handler） 1。HandlerMapping 就像一个路由器，它根据请求的特征（如 URL）将请求导向负责处理它的特定控制器 1。</li>
<li><strong>控制器调用：</strong> 一旦找到合适的控制器，DispatcherServlet 就将请求分发给该控制器进行处理 1。</li>
<li><strong>控制器处理：</strong> 控制器接收到请求后，会执行相应的业务逻辑，与模型（负责业务逻辑和数据）进行交互，并准备好要展示给视图的数据 1。这是应用程序中处理特定请求的核心逻辑所在 1。</li>
<li><strong>ModelAndView 返回：</strong> 控制器处理完请求后，通常会返回一个 ModelAndView 对象。该对象包含了模型数据（需要展示的数据）以及视图的逻辑名称 1。ModelAndView 对象充当了数据和视图展示方式的载体 1。</li>
<li><strong>视图解析：</strong> DispatcherServlet 接收到 ModelAndView 对象后，会使用 ViewResolver 组件根据视图的逻辑名称来查找实际的视图实现（例如，一个 JSP 文件） 2。ViewResolver 的作用在于将抽象的视图名称与具体的视图技术连接起来，提供了框架的灵活性 4。</li>
<li><strong>视图渲染：</strong> DispatcherServlet 将模型数据传递给解析得到的视图进行渲染 1。视图使用模型中的数据生成最终的 HTML 响应，该响应将被发送回客户端 1。</li>
<li><strong>响应返回客户端：</strong> 最终，渲染后的视图作为 HTTP 响应返回给用户的浏览器，用户在浏览器中看到请求的结果 1。</li>
</ol>
<p><strong>Spring MVC 请求处理流程</strong></p>
<table>
<thead>
<tr>
<th><strong>步骤</strong></th>
<th><strong>涉及组件</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>客户端</td>
<td>用户发起 HTTP 请求。</td>
</tr>
<tr>
<td>2</td>
<td>DispatcherServlet</td>
<td>拦截所有进入应用程序的请求。</td>
</tr>
<tr>
<td>3</td>
<td>HandlerMapping</td>
<td>确定处理该请求的控制器。</td>
</tr>
<tr>
<td>4</td>
<td>控制器</td>
<td>接收并处理请求。</td>
</tr>
<tr>
<td>5</td>
<td>控制器</td>
<td>与模型交互，准备数据。</td>
</tr>
<tr>
<td>6</td>
<td>控制器</td>
<td>返回包含模型数据和视图逻辑名称的 ModelAndView 对象。</td>
</tr>
<tr>
<td>7</td>
<td>ViewResolver</td>
<td>将视图逻辑名称解析为实际的视图对象。</td>
</tr>
<tr>
<td>8</td>
<td>视图</td>
<td>使用模型数据渲染响应。</td>
</tr>
<tr>
<td>9</td>
<td>DispatcherServlet</td>
<td>将渲染后的响应返回给客户端。</td>
</tr>
</tbody></table>
<h2 id="将请求映射到处理器：HandlerMapping-的作用"><a href="#将请求映射到处理器：HandlerMapping-的作用" class="headerlink" title="将请求映射到处理器：HandlerMapping 的作用"></a>将请求映射到处理器：HandlerMapping 的作用</h2><p>HandlerMapping 接口定义了将请求映射到处理器对象的契约 13。Spring MVC 提供了多种 HandlerMapping 接口的实现，大致可以分为继承自 <code>AbstractHandlerMethodMapping</code> 和 <code>AbstractUrlHandlerMapping</code> 的两类 16。</p>
<p><code>RequestMappingHandlerMapping</code> 是最常用的实现，它将 <code>@Controller</code> 类中带有 <code>@RequestMapping</code> 注解的方法映射为请求处理器 13。在应用程序初始化阶段，<code>RequestMappingHandlerMapping</code> 会扫描带有 <code>@Controller</code> 和 <code>@RequestMapping</code> 注解的类，并根据这些注解构建请求映射 2。它使用 <code>RequestMappingInfo</code> 对象来表示映射关系，该对象封装了请求匹配的各种条件，如路径、请求头、参数、HTTP 方法和媒体类型 16。<code>getMappingForMethod</code> 方法负责根据处理器方法上的 <code>@RequestMapping</code> 注解创建 <code>RequestMappingInfo</code> 对象 16。<code>@RequestMapping</code> 注解提供了一种灵活且声明式的方式，可以根据多种条件将特定的 HTTP 请求映射到控制器方法 2。</p>
<p><code>BeanNameUrlHandlerMapping</code> 是默认的 <code>HandlerMapping</code> 实现，它将 URL 路径映射到与 URL 路径同名的 Bean（Bean 的名称以 “&#x2F;“ 开头） 13。它支持直接名称匹配和使用 “*” 进行的模式匹配 13。这种方式提供了一种基于约定的映射方法，Bean 的名称直接对应于 URL 路径 13。</p>
<p><code>SimpleUrlHandlerMapping</code> 允许通过 Spring 配置中的 <code>Properties</code> 对象或 <code>Map</code> 显式地配置 URL 到处理器的映射（处理器可以是 Bean 实例或 Bean 名称） 13。这种方式提供了一种更具声明性的方式在配置文件中定义映射规则，为复杂的路由场景提供了灵活性 13。</p>
<p><code>@RequestMapping</code> 以及其他派生注解（如 <code>@GetMapping</code>、<code>@PostMapping</code> 等）简化了在控制器类中定义请求映射的过程 2。这些注解使得代码更易读和维护 2。</p>
<p>HandlerMapping 最终会返回一个 <code>HandlerExecutionChain</code> 对象，该对象包含了找到的处理器以及一个有序的拦截器列表 14。<code>HandlerExecutionChain</code> 允许在主要处理器执行前后执行拦截器，从而实现横切关注点的处理 14。可以使用 <code>order</code> 属性来设置不同 HandlerMapping 实现的优先级 13。</p>
<p><strong>常见的 HandlerMapping 实现</strong></p>
<table>
<thead>
<tr>
<th><strong>HandlerMapping 实现</strong></th>
<th><strong>描述</strong></th>
<th><strong>主要注解&#x2F;配置</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>RequestMappingHandlerMapping</code></td>
<td>将请求映射到带有 <code>@RequestMapping</code> 注解的控制器方法。</td>
<td><code>@Controller</code>, <code>@RequestMapping</code>, <code>@GetMapping</code>, <code>@PostMapping</code> 等。</td>
</tr>
<tr>
<td><code>BeanNameUrlHandlerMapping</code></td>
<td>将 URL 映射到名称以 “&#x2F;“ 开头的同名 Bean。</td>
<td>Bean 的名称作为 URL 路径。</td>
</tr>
<tr>
<td><code>SimpleUrlHandlerMapping</code></td>
<td>通过配置显式地将 URL 映射到处理器 Bean 或 Bean 名称。</td>
<td>Spring 配置文件中的属性或 Map。</td>
</tr>
</tbody></table>
<h2 id="执行业务逻辑：控制器处理"><a href="#执行业务逻辑：控制器处理" class="headerlink" title="执行业务逻辑：控制器处理"></a>执行业务逻辑：控制器处理</h2><p>DispatcherServlet 在确定了合适的控制器后，会将请求分发给该控制器进行处理 1。控制器中的方法会根据请求的 HTTP 方法（如 GET、POST 等）执行相应的业务逻辑 1。控制器通常会定义处理特定 HTTP 方法的方法，确保应用程序能够对不同类型的请求做出适当的响应 1。</p>
<p>在控制器方法执行过程中，Spring MVC 提供了灵活的参数解析和数据绑定机制 10。Spring MVC 允许使用任何对象作为命令或表单对象，而无需实现框架特定的接口 25。<code>@RequestParam</code> 注解用于将查询参数或表单数据映射到方法参数，尤其适用于基本数据类型 28。使用 <code>@RequestParam</code> 可以简化在控制器方法签名中直接访问请求参数的过程 28。数据绑定机制能够根据参数名称和类型自动将请求数据转换为 Java 对象 28。Spring 的数据绑定机制简化了将 HTTP 请求数据转换为可用的 Java 对象的过程，减少了样板代码 28。<code>@ModelAttribute</code> 注解可用于将请求参数绑定到方法参数或方法返回值，并将其作为命名的模型属性暴露给视图 21。<code>@ModelAttribute</code> 有助于实现双向数据绑定，方便表单数据与模型对象之间的映射 21。<code>DataBinder</code> 类支持构造器绑定和属性绑定，用于使用请求数据填充对象 27。较新版本的 Spring 中引入的构造器绑定提供了一种更安全的方式，通过调用构造函数并传入请求数据来绑定预期的参数 29。数据绑定过程中发生的类型不匹配会被视为验证错误，从而允许在应用程序层面进行处理 25。Spring 灵活的数据绑定能够优雅地处理常见的错误，使得开发者可以向用户提供有用的反馈 25。较新版本的 Spring 还支持直接在控制器方法参数上使用 <code>@Constraint</code> 注解进行方法验证，不再需要在类级别使用 <code>@Validated</code> 27。内置的方法验证简化了控制器方法中输入参数的验证过程，提高了代码的清晰度并减少了手动编写验证逻辑的需求 27。</p>
<h2 id="传递数据和视图信息：ModelAndView"><a href="#传递数据和视图信息：ModelAndView" class="headerlink" title="传递数据和视图信息：ModelAndView"></a>传递数据和视图信息：ModelAndView</h2><p>ModelAndView 对象是一个容器，它同时持有模型数据和要渲染的视图的名称 1。控制器在处理完请求后，通常会创建并返回 ModelAndView 对象 1。模型数据以键值对的形式存储在 Map 中，键是属性名称，值是要在视图中显示的数据 1。视图名称是一个逻辑标识符，ViewResolver 会将其解析为实际的视图技术 1。</p>
<p>控制器使用 ModelAndView 对象来同时返回模型数据和视图的逻辑名称 1。ModelAndView 对象可以通过构造函数传入视图名称，然后添加模型属性，也可以先创建一个空的 ModelAndView 对象，再分别设置模型属性和视图名称 17。它为控制器提供了一种便捷的方式来传递响应所需的数据以及指示应该使用哪个视图来呈现响应 1。</p>
<p>除了使用 ModelAndView，还有其他方式可以将模型数据传递给视图，例如将 <code>Model</code> 或 <code>ModelMap</code> 作为方法参数 17。<code>Model</code> 和 <code>ModelMap</code> 是用于向视图传递数据的接口&#x2F;类，它们由 Spring 直接注入到控制器方法中 17。当使用 <code>Model</code> 或 <code>ModelMap</code> 时，控制器方法通常只返回视图的逻辑名称作为字符串 17。Spring 提供了多种向视图传递数据的方式，开发者可以根据控制器的需求和偏好选择最合适的方法 17。</p>
<h2 id="解析视图：ViewResolver-的功能"><a href="#解析视图：ViewResolver-的功能" class="headerlink" title="解析视图：ViewResolver 的功能"></a>解析视图：ViewResolver 的功能</h2><p>ViewResolver 接口负责将控制器返回的视图逻辑名称映射到实际的 View 对象 2。它使得在浏览器中渲染模型数据成为可能，而无需将实现绑定到特定的视图技术 21。ViewResolver 接口定义了 <code>resolveViewName(String viewName, Locale locale)</code> 方法 23。</p>
<p><code>InternalResourceViewResolver</code> 用于将视图名称解析为内部资源，如位于 <code>WEB-INF</code> 目录下的 JSP 文件 21。它通过配置前缀（例如 <code>/WEB-INF/views/</code>）和后缀（例如 <code>.jsp</code>）来定位视图文件 22。此解析器常用于使用 JSP 作为视图技术的传统 Java Web 应用程序 21。</p>
<p><code>XmlViewResolver</code> 使用在 XML 文件中定义的视图 Bean 定义来解析视图名称 21。它允许配置具有特定类（例如 <code>JstlView</code>）和 URL 的视图 Bean 21。这种方式提供了一种配置驱动的视图解析方法，允许在同一应用程序中使用不同的视图技术 21。</p>
<p><code>ResourceBundleViewResolver</code> 使用属性文件来解析视图名称，视图配置在属性文件中以键值对的形式定义 21。此解析器适用于以更外部化的方式管理视图配置，可能有助于国际化或特定于环境的设置 21。</p>
<p>还有其他常用的解析器，如用于 Velocity 模板的 <code>VelocityViewResolver</code> 和用于 FreeMarker 模板的 <code>FreeMarkerViewResolver</code> 7。Spring MVC 支持与各种流行的模板引擎集成，为开发者提供了广泛的视图层选择 7。</p>
<p>Spring MVC 支持配置多个视图解析器，并使用 <code>setOrder()</code> 方法设置它们的优先级 21。通过配置具有特定顺序的多个视图解析器，Spring 可以尝试不同的解析器，直到找到匹配的视图，从而允许在同一应用程序中基于视图名称模式使用不同的视图技术 21。</p>
<p><strong>常见的 ViewResolver 实现</strong></p>
<table>
<thead>
<tr>
<th><strong>ViewResolver 实现</strong></th>
<th><strong>描述</strong></th>
<th><strong>典型配置</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>InternalResourceViewResolver</code></td>
<td>将视图名称解析为内部资源（如 JSP 文件）。</td>
<td>配置前缀（如 <code>/WEB-INF/views/</code>）和后缀（如 <code>.jsp</code>）。</td>
</tr>
<tr>
<td><code>XmlViewResolver</code></td>
<td>使用在 XML 文件中定义的视图 Bean 来解析视图名称。</td>
<td>配置包含视图 Bean 定义的 XML 文件路径。</td>
</tr>
<tr>
<td><code>ResourceBundleViewResolver</code></td>
<td>使用属性文件中的配置来解析视图名称。</td>
<td>配置属性文件的基本名称。</td>
</tr>
<tr>
<td><code>VelocityViewResolver</code></td>
<td>将视图名称解析为 Velocity 模板。</td>
<td>配置 Velocity 模板的路径和后缀。</td>
</tr>
<tr>
<td><code>FreeMarkerViewResolver</code></td>
<td>将视图名称解析为 FreeMarker 模板。</td>
<td>配置 FreeMarker 模板的路径和后缀。</td>
</tr>
</tbody></table>
<h2 id="渲染响应：视图组件"><a href="#渲染响应：视图组件" class="headerlink" title="渲染响应：视图组件"></a>渲染响应：视图组件</h2><p>选定的视图负责渲染模型数据，生成最终的响应 1。视图接收模型数据（通过 <code>Model</code>、<code>ModelMap</code> 或 <code>ModelAndView</code> 添加的属性），并将其与视图模板合并 1。不同的视图技术（JSP、Thymeleaf、FreeMarker 等）有各自的语法和机制来访问模板中的模型数据 1。例如，在 JSP 中，通常使用表达式语言（EL），如 <code>${attributeName}</code> 17。渲染过程最终会生成 HTML（或其他内容类型），并作为响应发送回客户端的浏览器 1。</p>
<p>Spring MVC 支持多种视图技术及其集成 1。JSP（JavaServer Pages）是一种传统的视图技术，Spring MVC 对其提供了良好的支持 1。Thymeleaf 是一种现代的服务器端 Java 模板引擎，它提供了自然的模板 5。FreeMarker 和 Velocity 是其他可以与 Spring MVC 集成的模板引擎 7。此外，Spring MVC 还支持将视图渲染为 JSON 或 XML 格式，用于构建 RESTful API 4。Spring MVC 在视图层面的灵活性使其能够适应各种 Web 应用程序和 API 的构建需求 4。</p>
<h2 id="拦截请求：使用-HandlerInterceptor"><a href="#拦截请求：使用-HandlerInterceptor" class="headerlink" title="拦截请求：使用 HandlerInterceptor"></a>拦截请求：使用 HandlerInterceptor</h2><p>HandlerInterceptor 接口允许在请求到达处理器之前（<code>preHandle</code>）、处理器执行之后但在视图渲染之前（<code>postHandle</code>）、以及整个请求完成之后（<code>afterCompletion</code>）对请求进行拦截和处理 13。</p>
<ul>
<li><code>preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</code> 方法在处理器执行之前被调用；返回 <code>true</code> 以继续处理，返回 <code>false</code> 则停止处理 19。此方法常用于执行身份验证、授权检查和日志记录等操作，这些操作需要在主要的请求处理逻辑之前完成 19。</li>
<li><code>postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</code> 方法在处理器成功执行之后但在视图渲染之前被调用；可以修改 ModelAndView 对象 19。这允许根据处理器执行的结果修改模型或视图，例如添加通用属性或更改视图名称 19。</li>
<li><code>afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</code> 方法在整个请求处理完成之后被调用，无论处理成功与否；常用于执行清理任务和记录日志 19。即使在请求处理过程中发生错误，此方法也能确保必要的清理操作或最终的日志记录语句得到执行 19。</li>
</ul>
<p>HandlerInterceptor 的常见用例包括记录请求详细信息和响应时间 19、实现身份验证和授权检查以保护应用程序资源 19、通过记录请求开始和结束时间来执行性能监控 19 以及修改请求或响应头 19。</p>
<p>HandlerInterceptor 需要在 Spring MVC 框架中注册才能在请求处理生命周期中被调用 19。通常通过实现 <code>WebMvcConfigurer</code> 接口并覆盖 <code>addInterceptors</code> 方法来配置 HandlerInterceptor 19。</p>
<p><strong>HandlerInterceptor 方法</strong></p>
<table>
<thead>
<tr>
<th><strong>方法名称</strong></th>
<th><strong>调用时机</strong></th>
<th><strong>主要目的</strong></th>
<th><strong>返回值&#x2F;参数</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>preHandle</code></td>
<td>在处理器执行之前</td>
<td>执行预处理，如身份验证、授权、日志记录等；可以决定是否继续处理请求。</td>
<td><code>boolean</code> (true 继续，false 停止)；<code>HttpServletRequest</code>, <code>HttpServletResponse</code>, <code>Object handler</code></td>
</tr>
<tr>
<td><code>postHandle</code></td>
<td>在处理器执行之后，视图渲染之前</td>
<td>修改 ModelAndView 对象，添加额外的模型属性或修改视图名称。</td>
<td><code>void</code>；<code>HttpServletRequest</code>, <code>HttpServletResponse</code>, <code>Object handler</code>, <code>ModelAndView modelAndView</code></td>
</tr>
<tr>
<td><code>afterCompletion</code></td>
<td>在整个请求处理完成之后</td>
<td>执行清理任务，如释放资源、记录请求完成时间、处理异常等。</td>
<td><code>void</code>；<code>HttpServletRequest</code>, <code>HttpServletResponse</code>, <code>Object handler</code>, <code>Exception ex</code> (可选)</td>
</tr>
</tbody></table>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Spring MVC 框架的工作原理围绕着中央调度器 DispatcherServlet 展开，它与 HandlerMapping、Controller、ModelAndView、ViewResolver 和 View 等组件协同工作，共同处理客户端发起的 Web 请求。DispatcherServlet 接收所有请求，HandlerMapping 负责将请求映射到合适的控制器，控制器处理业务逻辑并返回包含模型数据和视图名称的 ModelAndView 对象，ViewResolver 将视图名称解析为实际的视图，最后视图使用模型数据渲染响应并返回给客户端。HandlerInterceptor 则提供了在请求处理的不同阶段进行拦截和处理的能力。</p>
<p>使用 Spring MVC 框架具有诸多优势。首先，MVC 模式实现了清晰的关注点分离 2。其次，组件之间的松耦合使得应用程序更易于维护和测试 1。框架提供了高度的灵活性和可扩展性，这得益于其可配置的组件和接口 1。Spring MVC 支持各种视图技术 2，并提供了强大的数据绑定和验证机制 25。通过 HandlerInterceptor，可以方便地实现面向切面的功能 19。此外，Spring MVC 还与 Spring 框架的其他功能（如依赖注入和 AOP）无缝集成 3，并有助于快速应用程序开发 2。这些特性使得 Spring MVC 成为构建健壮、可维护和可扩展的 Java Web 应用程序的首选框架之一。</p>
<h1 id="Spring-MVC-面试题"><a href="#Spring-MVC-面试题" class="headerlink" title="Spring MVC 面试题:"></a>Spring MVC 面试题:</h1><p><strong>什么是 Spring MVC 框架？</strong></p>
<ul>
<li><strong>答案：</strong> Spring MVC 是基于模型-视图-控制器（MVC）设计模式的 Web 框架，用于构建 Web 应用程序。</li>
</ul>
<p><strong>Spring MVC 的工作原理是什么？</strong></p>
<ul>
<li><strong>答案：</strong> 客户端请求由前端控制器（DispatcherServlet）处理，然后通过处理器映射器（HandlerMapping）找到相应的控制器，控制器处理请求并返回模型和视图。</li>
</ul>
<p><strong>Spring MVC 中的控制器是如何工作的？</strong></p>
<ul>
<li><strong>答案：</strong> 控制器接收并处理客户端请求，然后返回一个包含模型数据的逻辑视图名称。</li>
</ul>
<p><strong>Spring MVC 的核心组件有哪些？</strong></p>
<ul>
<li><strong>答案：</strong> 包括 DispatcherServlet、Controller、HandlerMapping、ViewResolver 等。</li>
</ul>
<p><strong>解释一下 Spring MVC 中的 DispatcherServlet。</strong></p>
<ul>
<li><strong>答案：</strong> DispatcherServlet 是 Spring MVC 的前端控制器，负责接收并分发客户端的请求。</li>
</ul>
<p><strong>Spring MVC 中的 Model、View、Controller 是什么？</strong></p>
<ul>
<li><strong>答案：</strong> Model 用于封装数据，View 负责展示数据，Controller 处理用户请求并返回适当的模型和视图。</li>
</ul>
<p> <strong>如何处理表单提交和参数绑定？</strong></p>
<ul>
<li><strong>答案：</strong> 使用@ModelAttribute 注解进行参数绑定，使用<a href="form:form">form:form</a>标签处理表单提交。</li>
</ul>
<p><strong>Spring MVC 中的拦截器是什么，有什么作用？</strong></p>
<ul>
<li><strong>答案：</strong> 拦截器用于在请求处理前或处理后执行一些额外的逻辑，例如身份验证、日志记录等。</li>
</ul>
<p><strong>什么是 RESTful Web 服务，Spring MVC 如何支持 RESTful 风格？</strong></p>
<ul>
<li><strong>答案：</strong> RESTful 是一种 Web 服务设计风格，Spring MVC 通过注解（@RequestMapping）和 HTTP 方法来支持 RESTful 风格。</li>
</ul>
<p><strong>Spring MVC 中的@ModelAttribute 和@SessionAttributes 有什么区别？</strong><br>    - <strong>答案：</strong> @ModelAttribute 用于绑定请求参数到模型中，@SessionAttributes 用于将模型中的属性暂时存储在会话中。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Interview/">面试</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/SpringMVC.webp" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/750d7523.html" title="Spring Cloud"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/SpringCloud.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Spring Cloud</div></div><div class="info-2"><div class="info-item-1">Spring Cloud 是一个广泛用于构建微服务架构的框架集合，涵盖了服务发现、配置管理、负载均衡、熔断器、API 网关、消息总线等多个方面。以下是一个系统的 Spring Cloud 学习路线，适合初学者循序渐进地掌握其核心内容。  1. 基础准备在学习 Spring Cloud 之前，需要打好以下基础：  Java 基础：熟悉 Java 编程语言，包括面向对象编程、集合框架、异常处理等。 Spring Boot：Spring Cloud 基于 Spring Boot 构建，需掌握 Spring Boot 的核心概念，如自动配置、依赖注入、RESTful API 开发、Spring Data JPA 等。 微服务架构：了解微服务的基本概念、优缺点，以及与传统单体应用的区别。 HTTP 和 REST：掌握 HTTP 协议和 RESTful 服务设计原则。 Maven 或 Gradle：熟悉项目构建工具，学会管理依赖和构建项目。   2. Spring Cloud 核心组件学习Spring Cloud 由多个子项目组成，每个子项目解决微服务架构中的特定问题。以下是核心组件及其推荐...</div></div></div></a><a class="pagination-related" href="/posts/fed01c2.html" title="Spring 过滤器"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/Spring%E8%BF%87%E6%BB%A4%E5%99%A8.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Spring 过滤器</div></div><div class="info-2"><div class="info-item-1">Filter 和 InterceptorFilter 过滤器 Servlet 容器维度的，拦截 Servlet 的请求。 通过 Filter 接口实现的  Servlet 容器： Tomcat、Jetty。遵循 Java Servlet 规范，通常包括 HTTP 服务器，处理 web 请求和响应。 Interceptor 拦截器 Spring 容器维度的，对 Spring MVC 的请求进行拦截。 通过实现 HandlerInterceptor 接口实现的，并通过 Spring 的配置进行注册。  PS：Spring 框架嵌入到 Servlet 容器中，利用 spring 容器管理应用程序中的其他组件:  Spring Beans： 在 Spring 框架中，你可以定义和配置各种 Bean，包括业务逻辑组件、数据访问组件、服务等。这些 Bean 的生命周期、依赖关系等都由 Spring 容器管理。 Service 层和业务逻辑： 你可以使用 Spring 来管理业务逻辑层的组件，使其成为 Spring 容器管理的 Bean。这些业务逻辑组件通常包括服务层的实现，处理业务逻辑、事务...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/750d7523.html" title="Spring Cloud"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/SpringCloud.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-04 20:54</div><div class="info-item-2">Spring Cloud</div></div><div class="info-2"><div class="info-item-1">Spring Cloud 是一个广泛用于构建微服务架构的框架集合，涵盖了服务发现、配置管理、负载均衡、熔断器、API 网关、消息总线等多个方面。以下是一个系统的 Spring Cloud 学习路线，适合初学者循序渐进地掌握其核心内容。  1. 基础准备在学习 Spring Cloud 之前，需要打好以下基础：  Java 基础：熟悉 Java 编程语言，包括面向对象编程、集合框架、异常处理等。 Spring Boot：Spring Cloud 基于 Spring Boot 构建，需掌握 Spring Boot 的核心概念，如自动配置、依赖注入、RESTful API 开发、Spring Data JPA 等。 微服务架构：了解微服务的基本概念、优缺点，以及与传统单体应用的区别。 HTTP 和 REST：掌握 HTTP 协议和 RESTful 服务设计原则。 Maven 或 Gradle：熟悉项目构建工具，学会管理依赖和构建项目。   2. Spring Cloud 核心组件学习Spring Cloud 由多个子项目组成，每个子项目解决微服务架构中的特定问题。以下是核心组件及其推荐...</div></div></div></a><a class="pagination-related" href="/posts/fed01c2.html" title="Spring 过滤器"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/Spring%E8%BF%87%E6%BB%A4%E5%99%A8.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-03 22:37</div><div class="info-item-2">Spring 过滤器</div></div><div class="info-2"><div class="info-item-1">Filter 和 InterceptorFilter 过滤器 Servlet 容器维度的，拦截 Servlet 的请求。 通过 Filter 接口实现的  Servlet 容器： Tomcat、Jetty。遵循 Java Servlet 规范，通常包括 HTTP 服务器，处理 web 请求和响应。 Interceptor 拦截器 Spring 容器维度的，对 Spring MVC 的请求进行拦截。 通过实现 HandlerInterceptor 接口实现的，并通过 Spring 的配置进行注册。  PS：Spring 框架嵌入到 Servlet 容器中，利用 spring 容器管理应用程序中的其他组件:  Spring Beans： 在 Spring 框架中，你可以定义和配置各种 Bean，包括业务逻辑组件、数据访问组件、服务等。这些 Bean 的生命周期、依赖关系等都由 Spring 容器管理。 Service 层和业务逻辑： 你可以使用 Spring 来管理业务逻辑层的组件，使其成为 Spring 容器管理的 Bean。这些业务逻辑组件通常包括服务层的实现，处理业务逻辑、事务...</div></div></div></a><a class="pagination-related" href="/posts/60441.html" title="Spring AOP 事务失效与底层代理机制深度总结"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/AOP-PROXY.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-25 20:39</div><div class="info-item-2">Spring AOP 事务失效与底层代理机制深度总结</div></div><div class="info-2"><div class="info-item-1">Spring AOP 事务失效与底层代理机制深度总结1. 核心问题：为什么自调用导致事务失效？现象在同一个类中，方法 A 调用方法 B（this.methodB()），即使方法 B 上加了 @Transactional 注解，事务依然不生效。 根本原因Spring AOP 的默认实现基于 代理模式 (Proxy Pattern)。Spring 容器中注入的 Bean 实际上是一个 代理对象 (Proxy)，它持有你编写的 目标对象 (Target)。  生效路径：外部调用 $\rightarrow$ Proxy $\rightarrow$ 事务拦截器 (Interceptor) $\rightarrow$ Target。 失效路径：Target 内部调用 $\rightarrow$ this.methodB() $\rightarrow$ Target。  此时，this 指针指向的是目标对象本身。代码执行流直接在目标对象内部流转，完全绕过了外层的代理对象及其持有的事务拦截器。 形象比喻 Proxy (代理)：大楼门口的安检员。 Target (目标)：大楼里的员工。 外部访问：...</div></div></div></a><a class="pagination-related" href="/posts/eb9166f8.html" title="JUC并发编程"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/JUC.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-04 21:00</div><div class="info-item-2">JUC并发编程</div></div><div class="info-2"><div class="info-item-1">好的，阅读 JUC（Java Util Concurrent）源码是一项非常棒的学习任务，它能让你深入理解 Java 并发编程的精髓，以及 JVM 和操作系统层面的一些知识。JUC 包是 Java 并发编程的基石，包含了线程池、锁、原子操作、并发集合等核心组件。 下面为你列一个 JUC 源码学习的大纲，并提供一些学习建议：  JUC 源码学习大纲第一阶段：基础知识回顾与工具准备  并发基础理论： 可见性、原子性、有序性： 深入理解这三大特性及其在并发中的重要性。 JMM (Java Memory Model)： 了解 Java 内存模型如何保证并发的正确性。 Happens-Before 原则： 理解它如何定义操作之间的顺序。 锁的原理： 了解悲观锁、乐观锁，以及自旋锁等概念。 AQS (AbstractQueuedSynchronizer) 概述： 对 AQS 有一个初步的认识，它是 JUC 许多高级同步器的基石。 CAS (Compare-And-Swap) 原理： 理解其三步操作和 ABA 问题。   Lombok 与 @SneakyThrows： Lombok 在 JUC...</div></div></div></a><a class="pagination-related" href="/posts/5363d109.html" title="Java"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/JAVA8.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-04 21:06</div><div class="info-item-2">Java</div></div><div class="info-2"><div class="info-item-1">Java 8 新特性Lambda 表达式123456789101112131415private static void testLambda() &#123;    List&lt;String&gt; names = Arrays.asList(&quot;name&quot;, &quot;sex&quot;, &quot;hobby&quot;);    // with method reference -- static method    names.forEach(System.out::println);    names.forEach(name -&gt; System.out.println(name));    // with method reference -- instance method    names.sort(String::compareTo);    names.sort((a, b) -&gt; a.compareTo(b));    // with method reference -- constructor method    ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Supremes</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Supremes"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringMVC-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">SpringMVC 工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-text">引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E6%A8%A1%E5%9E%8B-%E8%A7%86%E5%9B%BE-%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%88MVC%EF%BC%89%E6%A8%A1%E5%BC%8F"><span class="toc-text">理解模型-视图-控制器（MVC）模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E8%B0%83%E5%BA%A6%E5%99%A8-DispatcherServlet"><span class="toc-text">核心调度器 DispatcherServlet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%AF%BC%E8%88%AA%EF%BC%9A%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-text">请求导航：请求处理流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84%E5%88%B0%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%9AHandlerMapping-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">将请求映射到处理器：HandlerMapping 的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%99%A8%E5%A4%84%E7%90%86"><span class="toc-text">执行业务逻辑：控制器处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E5%92%8C%E8%A7%86%E5%9B%BE%E4%BF%A1%E6%81%AF%EF%BC%9AModelAndView"><span class="toc-text">传递数据和视图信息：ModelAndView</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E8%A7%86%E5%9B%BE%EF%BC%9AViewResolver-%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-text">解析视图：ViewResolver 的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E5%93%8D%E5%BA%94%EF%BC%9A%E8%A7%86%E5%9B%BE%E7%BB%84%E4%BB%B6"><span class="toc-text">渲染响应：视图组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E8%AF%B7%E6%B1%82%EF%BC%9A%E4%BD%BF%E7%94%A8-HandlerInterceptor"><span class="toc-text">拦截请求：使用 HandlerInterceptor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-MVC-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">Spring MVC 面试题:</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/5363d109.html" title="Java"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/JAVA8.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java"/></a><div class="content"><a class="title" href="/posts/5363d109.html" title="Java">Java</a><time datetime="2025-12-04T21:06:42.000Z" title="发表于 2025-12-04 21:06 21:06:42">2025-12-04 21:06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/eb9166f8.html" title="JUC并发编程"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/JUC.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC并发编程"/></a><div class="content"><a class="title" href="/posts/eb9166f8.html" title="JUC并发编程">JUC并发编程</a><time datetime="2025-12-04T21:00:06.000Z" title="发表于 2025-12-04 21:00 21:00:06">2025-12-04 21:00</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/750d7523.html" title="Spring Cloud"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/SpringCloud.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Cloud"/></a><div class="content"><a class="title" href="/posts/750d7523.html" title="Spring Cloud">Spring Cloud</a><time datetime="2025-12-04T20:54:30.000Z" title="发表于 2025-12-04 20:54 20:54:30">2025-12-04 20:54</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2d0b435f.html" title="Spring MVC"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/SpringMVC.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring MVC"/></a><div class="content"><a class="title" href="/posts/2d0b435f.html" title="Spring MVC">Spring MVC</a><time datetime="2025-12-04T20:51:26.000Z" title="发表于 2025-12-04 20:51 20:51:26">2025-12-04 20:51</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/fed01c2.html" title="Spring 过滤器"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/Spring%E8%BF%87%E6%BB%A4%E5%99%A8.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring 过滤器"/></a><div class="content"><a class="title" href="/posts/fed01c2.html" title="Spring 过滤器">Spring 过滤器</a><time datetime="2025-12-03T22:37:18.000Z" title="发表于 2025-12-03 22:37 22:37:18">2025-12-03 22:37</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Supremes</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="/"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章标题和内容..." type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.2"></script></div></div></body></html>
<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MySQL 日志系统 | Supremes</title><meta name="author" content="Supremes"><meta name="copyright" content="Supremes"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redo Log 这张图被一条中间的虚线分为左右两部分，代表了计算机系统中两种截然不同的存储介质属性。 1. 左侧区域：IN-MEMORY (内存区域) - Volatile (易失性) 特点：  速度极快： CPU 对内存的读写速度远远高于磁盘。为了高性能，数据库必须尽可能在内存中处理数据。 易失性 (Volatile)： 这是最大的弱点。一旦断电、系统崩溃或进程被强制终止，内存中的所有数据瞬间">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL 日志系统">
<meta property="og:url" content="https://supremes.github.io/posts/356a30bc.html">
<meta property="og:site_name" content="Supremes">
<meta property="og:description" content="Redo Log 这张图被一条中间的虚线分为左右两部分，代表了计算机系统中两种截然不同的存储介质属性。 1. 左侧区域：IN-MEMORY (内存区域) - Volatile (易失性) 特点：  速度极快： CPU 对内存的读写速度远远高于磁盘。为了高性能，数据库必须尽可能在内存中处理数据。 易失性 (Volatile)： 这是最大的弱点。一旦断电、系统崩溃或进程被强制终止，内存中的所有数据瞬间">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/MySQL_Log.webp">
<meta property="article:published_time" content="2025-12-02T17:26:11.000Z">
<meta property="article:modified_time" content="2025-12-03T13:59:06.196Z">
<meta property="article:author" content="Supremes">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/MySQL_Log.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MySQL 日志系统",
  "url": "https://supremes.github.io/posts/356a30bc.html",
  "image": "https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/MySQL_Log.webp",
  "datePublished": "2025-12-02T17:26:11.000Z",
  "dateModified": "2025-12-03T13:59:06.196Z",
  "author": [
    {
      "@type": "Person",
      "name": "Supremes",
      "url": "https://supremes.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/favicon/favicon.ico"><link rel="canonical" href="https://supremes.github.io/posts/356a30bc.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":10},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL 日志系统',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">50</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Spring/"><i class="fa-fw fas fa-leaf"></i><span> Spring</span></a></li><li><a class="site-page child" href="/categories/Interview/"><i class="fa-fw fas fa-book"></i><span> 面试</span></a></li><li><a class="site-page child" href="/categories/database/"><i class="fa-fw fas fa-database"></i><span> 数据库</span></a></li><li><a class="site-page child" href="/categories/algorithm/"><i class="fa-fw fas fa-code"></i><span> 算法</span></a></li><li><a class="site-page child" href="/categories/security/"><i class="fa-fw fas fa-shield-alt"></i><span> 网络安全</span></a></li><li><a class="site-page child" href="/categories/message-queue/"><i class="fa-fw fas fa-envelope"></i><span> 消息队列</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/about_me"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/about/my_notes"><i class="fa-fw fas fa-note-sticky"></i><span> 备忘录</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/MySQL_Log.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Supremes</span></a><a class="nav-page-title" href="/"><span class="site-name">MySQL 日志系统</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Spring/"><i class="fa-fw fas fa-leaf"></i><span> Spring</span></a></li><li><a class="site-page child" href="/categories/Interview/"><i class="fa-fw fas fa-book"></i><span> 面试</span></a></li><li><a class="site-page child" href="/categories/database/"><i class="fa-fw fas fa-database"></i><span> 数据库</span></a></li><li><a class="site-page child" href="/categories/algorithm/"><i class="fa-fw fas fa-code"></i><span> 算法</span></a></li><li><a class="site-page child" href="/categories/security/"><i class="fa-fw fas fa-shield-alt"></i><span> 网络安全</span></a></li><li><a class="site-page child" href="/categories/message-queue/"><i class="fa-fw fas fa-envelope"></i><span> 消息队列</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/about_me"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/about/my_notes"><i class="fa-fw fas fa-note-sticky"></i><span> 备忘录</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">MySQL 日志系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-02T17:26:11.000Z" title="发表于 2025-12-02 17:26 17:26:11">2025-12-02 17:26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-03T13:59:06.196Z" title="更新于 2025-12-03 13:59 13:59:06">2025-12-03 13:59</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/database/">数据库</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/database/MySQL/">MySQL</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h1><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/MySQL_RedoLog.webp" alt="img"></p>
<p>这张图被一条中间的虚线分为左右两部分，代表了计算机系统中两种截然不同的存储介质属性。</p>
<h2 id="1-左侧区域：IN-MEMORY-内存区域-Volatile-易失性"><a href="#1-左侧区域：IN-MEMORY-内存区域-Volatile-易失性" class="headerlink" title="1. 左侧区域：IN-MEMORY (内存区域) - Volatile (易失性)"></a>1. 左侧区域：IN-MEMORY (内存区域) - Volatile (易失性)</h2><ul>
<li><p><strong>特点：</strong></p>
<ul>
<li><strong>速度极快：</strong> CPU 对内存的读写速度远远高于磁盘。为了高性能，数据库必须尽可能在内存中处理数据。</li>
<li><strong>易失性 (Volatile)：</strong> 这是最大的弱点。一旦断电、系统崩溃或进程被强制终止，内存中的所有数据瞬间消失。图中的气泡对话框形象地说明了这一点：“Fast access, but data lost on power failure.”（访问快，但断电丢数据）。</li>
</ul>
</li>
<li><p><strong>关键组件：</strong></p>
<ul>
<li><strong>BUFFER POOL (缓冲池)：</strong><ul>
<li>这是 InnoDB 在内存中最大的保留区域。它缓存了从磁盘读取的数据页 (Data Pages)。</li>
<li>当我们要修改数据时，不是直接去改磁盘文件，而是先在 Buffer Pool 中找到对应的数据页进行修改。</li>
<li><strong>Dirty Page (脏页)：</strong> 图中高亮的橙色方块。当一个数据页在内存中被修改了，但还没有写回到磁盘的数据文件中时，它就和磁盘上的版本不一致了，我们称之为“脏页”。</li>
</ul>
</li>
<li><strong>LOG BUFFER (日志缓冲)：</strong><ul>
<li>这是一个相对较小的内存区域，专门用来暂存即将写入磁盘的 Redo Log 记录。</li>
<li>每当 Buffer Pool 中的数据发生修改，InnoDB 就会生成一条对应的、非常紧凑的日志记录（比如：“第10号数据页偏移量500的位置，值从A改成了B”），先暂存在这里。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-右侧区域：ON-DISK-磁盘区域-Persistent-持久性"><a href="#2-右侧区域：ON-DISK-磁盘区域-Persistent-持久性" class="headerlink" title="2. 右侧区域：ON-DISK (磁盘区域) - Persistent (持久性)"></a>2. 右侧区域：ON-DISK (磁盘区域) - Persistent (持久性)</h2><ul>
<li><p><strong>特点：</strong></p>
<ul>
<li><p><strong>速度慢：</strong> 相比内存，磁盘 I&#x2F;O 是非常昂贵的操作，速度很慢。</p>
</li>
<li><p><strong>持久性 (Persistent)：</strong> 优点是数据安全。写入磁盘后，即使断电，数据也不会丢失。</p>
</li>
</ul>
</li>
<li><p><strong>关键组件：</strong></p>
<ul>
<li><p><strong>REDO LOG FILES (重做日志文件)：</strong></p>
<ul>
<li><p>这是保证数据安全的核心。它们是物理磁盘上的文件（通常命名为 <code>ib_logfile0</code>, <code>ib_logfile1</code> 等）。</p>
</li>
<li><p>特点是<strong>顺序写入 (Sequential Write)</strong>。就像写日记一样，一直往文件末尾追加内容。对于机械硬盘来说，顺序写的速度远快于随机写。</p>
</li>
</ul>
</li>
<li><p><strong>DATA FILES (数据文件)：</strong></p>
<ul>
<li><p>这是表数据最终的归宿（通常是 <code>.ibd</code> 文件）。</p>
</li>
<li><p>写入这些文件通常是<strong>随机写入 (Random Write)</strong>，因为不同的数据页分布在文件的不同位置。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="流程详解：正常事务操作-Normal-Operation"><a href="#流程详解：正常事务操作-Normal-Operation" class="headerlink" title="流程详解：正常事务操作 (Normal Operation)"></a>流程详解：正常事务操作 (Normal Operation)</h2><p>这个流程的目标是：<strong>既要利用内存的高速，又要保证数据的安全。</strong></p>
<p><strong>步骤 1. UPDATE&#x2F;INSERT Data (事务开始)</strong></p>
<ul>
<li><p>客户端发起一个更新请求。</p>
</li>
<li><p>InnoDB 首先在 <strong>Buffer Pool</strong> 中查找需要修改的数据页。如果不在，就先从磁盘读入。</p>
</li>
<li><p>在内存中直接修改该数据页。此时，该页变成了 <strong>Dirty Page (脏页)</strong>。</p>
</li>
</ul>
<p><strong>步骤 2. COMMIT Transaction (提交事务)</strong></p>
<ul>
<li><p>客户端修改完数据后，发起 <code>COMMIT</code> 命令，告诉数据库：“我完成了，请把这些修改永久保存。”</p>
</li>
<li><p>此时，关于这次修改的日志记录已经被放入了 <strong>Log Buffer</strong> 中等待。</p>
</li>
</ul>
<p><strong>步骤 3. WAL: WRITE-AHEAD LOGGING (预写式日志) —— 最关键的一步！</strong></p>
<ul>
<li><p><strong>这是跨越“易失”和“持久”边界的关键动作。</strong></p>
</li>
<li><p>在事务被认为是“提交成功”之前，InnoDB 必须遵循 WAL 原则：<strong>日志先行</strong>。</p>
</li>
<li><p>系统会将 Log Buffer 中的日志记录，强制写入到磁盘上的 <strong>Redo Log Files</strong> 中，并执行 <code>fsync()</code> 操作（确保数据真的落到物理磁盘介质上，而不是停留在操作系统的文件缓存里）。</p>
</li>
<li><p><strong>图中文字强调：</strong> “Must reach disk BEFORE transaction is confirmed.”（在确认事务之前，日志必须到达磁盘）。</p>
</li>
<li><p><em>注：一旦这一步完成，哪怕数据文件还没更新，事务也被认为是安全的了。图里虽然没画步骤4，但此时数据库会向客户端返回“Commit OK”。</em></p>
</li>
</ul>
<p><strong>步骤 5. ASYNC CHECKPOINT (异步检查点&#x2F;刷脏页)</strong></p>
<ul>
<li><p>这是一个后台的、异步的过程，<strong>不影响客户端的响应速度</strong>。</p>
</li>
<li><p>Buffer Pool 中的“脏页”不能永远待在内存里，内存有限，且不安全。</p>
</li>
<li><p>InnoDB 的后台线程会选择合适的时机（比如系统空闲时，或 Redo Log 快写满时），慢慢地将这些脏页刷新到磁盘上的 <strong>Data Files</strong> 中。我们将这个过程称为“刷脏”或 Checkpoint。</p>
</li>
<li><p>图中虚线箭头和文字 “Lazy write of data pages”（数据的延迟写入）准确地描述了这个过程。</p>
</li>
</ul>
<hr>
<h2 id="流程详解：崩溃恢复-Crash-Recovery-Process"><a href="#流程详解：崩溃恢复-Crash-Recovery-Process" class="headerlink" title="流程详解：崩溃恢复 (Crash Recovery Process)"></a>流程详解：崩溃恢复 (Crash Recovery Process)</h2><p>这个流程的目标是：<strong>当发生意外时，把还没来得及写入数据文件的修改找回来。</strong></p>
<p><strong>场景假设：</strong> 假设在上面的流程中，<strong>步骤 3 刚刚完成</strong>（Redo Log 已经落盘），但是<strong>步骤 5 还没有发生</strong>（脏页还在内存里，没写到数据文件），突然机房断电了。</p>
<p><strong>后果：</strong> 内存中的 Dirty Page 瞬间消失。磁盘上的 Data Files 里存的还是旧数据。</p>
<p><strong>恢复过程 (图的底部区域)：</strong></p>
<ol>
<li><p><strong>SYSTEM CRASH &#x2F; POWER OUTAGE (系统崩溃&#x2F;断电)</strong>。</p>
</li>
<li><p><strong>RESTART (重启)</strong>：MySQL 服务器重新启动。</p>
</li>
<li><p><strong>Read from Last Checkpoint (从上次检查点读取)</strong>：</p>
<ul>
<li><p>InnoDB 启动时会检查状态，发现上次是非正常关闭。</p>
</li>
<li><p>它会去读取磁盘上的 <strong>REDO LOG FILES</strong>。它需要找到一个“检查点 (Checkpoint)”，这个点之前的数据保证都已经写入数据文件了。</p>
</li>
</ul>
</li>
<li><p><strong>REPLAY LOGS (重放日志)</strong>：</p>
<ul>
<li><p>InnoDB 从检查点开始，往后读取所有的 Redo Log 记录。</p>
</li>
<li><p>它按照日志记录的内容，在内存的 <strong>Buffer Pool</strong> 中重新执行一遍修改操作。</p>
</li>
</ul>
</li>
<li><p><strong>Restore Dirty Pages to Memory (恢复脏页到内存)</strong>：</p>
<ul>
<li><p>通过重放日志，崩溃前那一刻内存中的 <strong>Dirty Page</strong> 就被完美还原了。</p>
</li>
<li><p>此时，数据库恢复到了崩溃前的一致状态，可以对外提供服务了。随后，后台线程会再次尝试执行步骤 5，把这些恢复出来的脏页写入数据文件。</p>
</li>
</ul>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这张图完美地展示了 MySQL InnoDB 的设计哲学：</p>
<ul>
<li><p>利用 <strong>内存 (Buffer Pool)</strong> 来保证<strong>高性能</strong>（读写都在内存）。</p>
</li>
<li><p>利用 <strong>Redo Log (WAL机制)</strong> 来保证<strong>持久性</strong>（关键时刻利用顺序写快速落盘日志）。</p>
</li>
<li><p>利用 <strong>异步刷脏 (Checkpoint)</strong> 来平衡性能和数据最终的一致性。</p>
</li>
</ul>
<h1 id="Bin-Log"><a href="#Bin-Log" class="headerlink" title="Bin Log"></a>Bin Log</h1><ul>
<li>Server 层也有自己的日志，称为 binlog（归档日志）。</li>
<li>binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/MySQL_BinLog.webp" alt="img"></li>
</ul>
<h2 id="工作流程图详解"><a href="#工作流程图详解" class="headerlink" title="工作流程图详解"></a>工作流程图详解</h2><p>这张图片直观地展示了 <strong>MySQL Binlog (Binary Log，二进制日志)</strong> 的工作原理，以及它是如何支撑 <strong>主从复制 (Replication)</strong> 的。</p>
<p>我们可以把这张图的流程拆解为三个主要部分：<strong>主库（Master）的记录</strong>、<strong>数据的传输</strong>、<strong>从库（Slave&#x2F;Replica）的重放</strong>。</p>
<p>以下是详细的步骤解释：</p>
<h3 id="1-主库端-Master-Server-：记录变更"><a href="#1-主库端-Master-Server-：记录变更" class="headerlink" title="1. 主库端 (Master Server)：记录变更"></a>1. 主库端 (Master Server)：记录变更</h3><p>这是流程的起点，对应图中左侧或上方的部分。</p>
<ul>
<li><p>写入操作 (Write Operations):</p>
<p>  当客户端应用（Client Application）向数据库发送 修改数据 的请求（如 INSERT, UPDATE, DELETE）时，这些操作首先在主库的存储引擎中执行。</p>
<ul>
<li><em>注意：<code>SELECT</code> 等读取操作不会被记录，因为它们不改变数据。</em></li>
</ul>
</li>
<li><p>写入 Binlog 文件 (Binary Log File):</p>
<p>  在数据被提交（Commit）到底层存储之前（或同时），MySQL 会将这次数据变更的详细信息顺序写入到磁盘上的 Binlog 文件 中。</p>
<ul>
<li><strong>Binlog 的内容：</strong> 它可以记录具体的 SQL 语句（Statement 格式），也可以记录行数据的变化（Row 格式），或者两者的混合（Mixed 格式）。</li>
</ul>
</li>
</ul>
<h3 id="2-复制与传输过程：三个关键线程"><a href="#2-复制与传输过程：三个关键线程" class="headerlink" title="2. 复制与传输过程：三个关键线程"></a>2. 复制与传输过程：三个关键线程</h3><p>这是连接主库和从库的核心机制，也是图中的核心逻辑。为了把数据同步过去，MySQL 使用了三个专门的线程：</p>
<h4 id="A-Binlog-Dump-Thread-主库端"><a href="#A-Binlog-Dump-Thread-主库端" class="headerlink" title="A. Binlog Dump Thread (主库端)"></a>A. Binlog Dump Thread (主库端)</h4><ul>
<li><p>当从库连接到主库并请求同步时，主库会创建一个 <strong>Binlog Dump 线程</strong>。</p>
</li>
<li><p>它的任务是读取主库的 Binlog 文件，并将内容通过网络发送给从库。</p>
</li>
</ul>
<h4 id="B-I-O-Thread-从库端"><a href="#B-I-O-Thread-从库端" class="headerlink" title="B. I&#x2F;O Thread (从库端)"></a>B. I&#x2F;O Thread (从库端)</h4><ul>
<li><p>从库启动后，会创建一个 <strong>I&#x2F;O 线程</strong>。</p>
</li>
<li><p>它的任务是“搬运工”：它连接到主库，接收 Dump 线程发来的 Binlog 数据块。</p>
</li>
<li><p><strong>关键点：</strong> I&#x2F;O 线程收到数据后，<strong>不会直接写入从库的数据库</strong>，而是将其写入到从库磁盘上的一个临时中转文件，叫做 <strong>Relay Log (中继日志)</strong>。</p>
</li>
</ul>
<h4 id="C-SQL-Thread-从库端"><a href="#C-SQL-Thread-从库端" class="headerlink" title="C. SQL Thread (从库端)"></a>C. SQL Thread (从库端)</h4><ul>
<li><p>这是从库的第二个关键线程。</p>
</li>
<li><p>它的任务是“执行者”：它实时检测 Relay Log 中有没有新内容。</p>
</li>
<li><p>一旦发现新内容，它就读取这些日志，并将其解析为具体的数据库操作，然后在从库的数据库中<strong>重新执行 (Replay)</strong> 一遍。</p>
</li>
</ul>
<h3 id="3-从库端-Replica-Server-：最终一致性"><a href="#3-从库端-Replica-Server-：最终一致性" class="headerlink" title="3. 从库端 (Replica Server)：最终一致性"></a>3. 从库端 (Replica Server)：最终一致性</h3><p>对应图中右侧或下方的部分。</p>
<ul>
<li><p>Relay Log (中继日志):</p>
<p>  这是一个缓冲地带。它的存在使得“获取日志”和“执行日志”解耦了。即使从库执行 SQL 比较慢（SQL Thread 阻塞），I&#x2F;O 线程依然可以快速地把主库的日志拉取回来存在本地，保证数据不丢失。</p>
</li>
<li><p>数据同步完成:</p>
<p>  当 SQL 线程执行完 Relay Log 中的操作后，从库的数据状态就和主库保持了一致。</p>
</li>
</ul>
<hr>
<h3 id="总结：这张图告诉了我们什么？"><a href="#总结：这张图告诉了我们什么？" class="headerlink" title="总结：这张图告诉了我们什么？"></a>总结：这张图告诉了我们什么？</h3><ol>
<li><p><strong>异步复制 (Asynchronous):</strong> 主库写完 Binlog 就可以告诉客户端“成功了”，它不需要等从库确认。从库是后来慢慢追上来的。</p>
</li>
<li><p><strong>解耦:</strong> 通过 Binlog 和 Relay Log，主库和从库的压力被隔离开了。</p>
</li>
<li><p><strong>核心用途:</strong></p>
<ul>
<li><p><strong>主从复制:</strong> 实现读写分离（主库写，从库读）或高可用热备。</p>
</li>
<li><p><strong>数据恢复:</strong> 如果数据库误删了，可以通过重放 Binlog 把数据恢复到误删前的任意时刻（Point-in-Time Recovery）。</p>
</li>
</ul>
</li>
</ol>
<p>你可以把这个过程想象成：</p>
<p>主库是演讲者（执行写操作），它把演讲内容录在磁带（Binlog）里。从库派了一个快递员（I&#x2F;O 线程）把磁带复刻一份拿回家（Relay Log），然后从库自己在家里放磁带（SQL 线程），跟着录音再做一遍动作。</p>
<p><strong>需要我为您解释 Binlog 的三种格式（Statement, Row, Mixed）的区别吗？这对性能和数据一致性有很大影响。</strong></p>
<h1 id="Undo-Log"><a href="#Undo-Log" class="headerlink" title="Undo Log"></a>Undo Log</h1><p>如果说 <strong>Redo Log</strong> 是“发生意外时的救命稻草”，<strong>Bin Log</strong> 是“传给别人的操作手册”，那么 <strong>Undo Log</strong> 就是**“后悔药”**（或者说是电脑上的 <code>Ctrl+Z</code>）。</p>
<p>它是 MySQL 保证事务 <strong>原子性 (Atomicity)</strong> 和实现 <strong>MVCC (多版本并发控制)</strong> 的核心组件。</p>
<p>以下是 Undo Log 的详细解析及其与另外两个日志的区别。</p>
<hr>
<h2 id="1-什么是-Undo-Log？"><a href="#1-什么是-Undo-Log？" class="headerlink" title="1. 什么是 Undo Log？"></a>1. 什么是 Undo Log？</h2><p>Undo Log（回滚日志）记录的是数据的<strong>逻辑变化</strong>，但它的记录方式是**“反着来的”**。</p>
<ul>
<li><p><strong>记录原理：</strong> 只要你修改数据，MySQL 就会在 Undo Log 里记录一条<strong>相反</strong>的操作，以便随时回滚。</p>
<ul>
<li><p>你执行 <code>INSERT</code>，它记录 <code>DELETE</code>。</p>
</li>
<li><p>你执行 <code>DELETE</code>，它记录 <code>INSERT</code>。</p>
</li>
<li><p>你执行 <code>UPDATE</code> 把 <code>age</code> 从 10 改为 20，它记录 <code>UPDATE age = 10</code>。</p>
</li>
</ul>
</li>
</ul>
<h4 id="它的两大核心作用："><a href="#它的两大核心作用：" class="headerlink" title="它的两大核心作用："></a><strong>它的两大核心作用：</strong></h4><ol>
<li><p><strong>事务回滚 (Rollback)：</strong></p>
<ul>
<li>当事务执行到一半，用户手动输入 <code>ROLLBACK</code>，或者程序发生错误（如唯一索引冲突），MySQL 就利用 Undo Log 将数据恢复到事务开始前的样子。</li>
</ul>
</li>
<li><p><strong>MVCC (多版本并发控制)：</strong></p>
<ul>
<li>当一个事务正在修改某行数据（还没提交），另一个事务来读取这行数据时，为了不加锁且不读到脏数据，MySQL 会利用 Undo Log 构建一个**“历史版本快照”**，让读取者看到修改之前的数据。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-Undo-Log-的工作流程图解"><a href="#2-Undo-Log-的工作流程图解" class="headerlink" title="2. Undo Log 的工作流程图解"></a>2. Undo Log 的工作流程图解</h2><p>假设我们执行一个事务：<code>UPDATE user SET age = 20 WHERE id = 1;</code> (原 age &#x3D; 10)</p>
<h4 id="Step-1-准备回滚数据"><a href="#Step-1-准备回滚数据" class="headerlink" title="Step 1: 准备回滚数据"></a><strong>Step 1: 准备回滚数据</strong></h4><p>在真正修改内存中的数据之前，InnoDB 会先生成一条 Undo Log：</p>
<blockquote>
<p>“如果要把 id&#x3D;1 的数据回滚，请执行 <code>UPDATE user SET age = 10 WHERE id = 1;</code>”</p>
</blockquote>
<h4 id="Step-2-修改内存-写-Redo-Log"><a href="#Step-2-修改内存-写-Redo-Log" class="headerlink" title="Step 2: 修改内存 &amp; 写 Redo Log"></a><strong>Step 2: 修改内存 &amp; 写 Redo Log</strong></h4><p>执行修改，内存中的 age 变为 20。同时写入 Redo Log（记录物理修改）。</p>
<h4 id="Step-3-此时如果有别的事务来查-MVCC"><a href="#Step-3-此时如果有别的事务来查-MVCC" class="headerlink" title="Step 3: 此时如果有别的事务来查 (MVCC)"></a><strong>Step 3: 此时如果有别的事务来查 (MVCC)</strong></h4><p>事务还没提交。此时事务 B 来查 id&#x3D;1。</p>
<p>InnoDB 发现这行数据被锁定了（或处于活跃事务中），它不会阻塞，而是顺着回滚指针 (Rollback Pointer) 找到 Undo Log 里的记录。</p>
<ul>
<li><p><strong>结果：</strong> 事务 B 读到了 <code>age = 10</code>。</p>
</li>
<li><p><strong>意义：</strong> 读写互不阻塞，高并发性能的关键。</p>
</li>
</ul>
<h4 id="Step-4-事务提交-Commit-或-回滚-Rollback"><a href="#Step-4-事务提交-Commit-或-回滚-Rollback" class="headerlink" title="Step 4: 事务提交 (Commit) 或 回滚 (Rollback)"></a><strong>Step 4: 事务提交 (Commit) 或 回滚 (Rollback)</strong></h4><ul>
<li><p><strong>如果提交：</strong> Undo Log 不会立即删除（因为可能还有长事务需要看旧版本），而是放入“待清理列表 (History List)”，由 Purge 线程后续清理。</p>
</li>
<li><p><strong>如果回滚：</strong> 立即执行 Undo Log 里的反向操作，将 age 变回 10。</p>
</li>
</ul>
<hr>
<h2 id="3-一个刁钻的问题：Undo-Log-本身需要持久化吗？"><a href="#3-一个刁钻的问题：Undo-Log-本身需要持久化吗？" class="headerlink" title="3. 一个刁钻的问题：Undo Log 本身需要持久化吗？"></a>3. 一个刁钻的问题：Undo Log 本身需要持久化吗？</h2><p><strong>需要。</strong></p>
<p>这听起来有点绕：Undo Log 是用来修数据的，那谁来修 Undo Log 呢？</p>
<p>答案是 Redo Log。</p>
<ul>
<li><p>Undo Log 在 MySQL 中也被视为“数据”的一种（存在于系统表空间或 undo 表空间中）。</p>
</li>
<li><p>当你写 Undo Log 时，这个写入操作本身也会产生对应的 Redo Log。</p>
</li>
<li><p><strong>场景：</strong> 假设事务执行了一半，MySQL 崩溃了。</p>
<ol>
<li><p>重启后，Redo Log 会先恢复数据，<strong>同时也恢复了 Undo Log</strong>。</p>
</li>
<li><p>数据库发现有一个事务处于“未提交”状态。</p>
</li>
<li><p>利用刚刚恢复出来的 Undo Log，对该事务进行回滚 (Rollback)。</p>
</li>
<li><p>数据库恢复一致性。</p>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p><strong>Redo Log</strong> 让你<strong>向前走</strong>（掉电了也能继续往前走完）。</p>
</li>
<li><p><strong>Undo Log</strong> 让你<strong>向后退</strong>（做错了可以退回到原点）。</p>
</li>
<li><p><strong>Bin Log</strong> 让你<strong>克隆</strong>（把你的经历完整复制给另一个库）。</p>
</li>
</ul>
<p>三者配合：</p>
<ol>
<li><p>事务开启。</p>
</li>
<li><p>写 <strong>Undo Log</strong> (为了能退回来)。</p>
</li>
<li><p>执行内存修改。</p>
</li>
<li><p>写 <strong>Redo Log</strong> (为了防断电)。</p>
</li>
<li><p>提交时写 <strong>Bin Log</strong> (为了给从库)。</p>
</li>
<li><p>事务结束。</p>
</li>
</ol>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>Redo Log (重做日志)</strong></th>
<th><strong>Bin Log (归档日志)</strong></th>
<th><strong>Undo Log (回滚日志)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>核心关键词</strong></td>
<td><strong>“恢复”</strong></td>
<td><strong>“复制”</strong></td>
<td><strong>“撤销”</strong></td>
</tr>
<tr>
<td><strong>比喻</strong></td>
<td>记账本的草稿 (防止断电忘事)</td>
<td>完整的账单明细 (给别人看)</td>
<td><strong>橡皮擦 &#x2F; Ctrl+Z</strong></td>
</tr>
<tr>
<td><strong>侧重点</strong></td>
<td>物理偏向 (页修改)</td>
<td>逻辑偏向 (SQL语义)</td>
<td><strong>逻辑反向</strong> (逆操作)</td>
</tr>
<tr>
<td><strong>主要作用</strong></td>
<td>崩溃恢复 (Crash Safe)<br><br>  <br><br>保证 <strong>D</strong> (持久性)</td>
<td>主从复制、数据恢复<br><br>  <br><br>保证数据一致性</td>
<td>事务回滚、MVCC<br><br>  <br><br>保证 <strong>A</strong> (原子性) 和 <strong>I</strong> (隔离性)</td>
</tr>
<tr>
<td><strong>写入时机</strong></td>
<td>事务进行中不断写</td>
<td>事务提交时一次性写</td>
<td>事务开始前&#x2F;修改前写</td>
</tr>
<tr>
<td><strong>释放时机</strong></td>
<td>落盘后覆盖 (循环写)</td>
<td>不删除 (追加写)</td>
<td>事务提交后，若无 MVCC 需求则标记删除 (Purge)</td>
</tr>
</tbody></table>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="为什么需要“两阶段提交”-2-PC"><a href="#为什么需要“两阶段提交”-2-PC" class="headerlink" title="为什么需要“两阶段提交” (2 PC)?"></a>为什么需要“两阶段提交” (2 PC)?</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/MySQL_2PC.webp" alt="img"></p>
<h3 id="背景问题：数据一致性"><a href="#背景问题：数据一致性" class="headerlink" title="背景问题：数据一致性"></a>背景问题：数据一致性</h3><p>如果 MySQL 没有两阶段提交，Redo Log 和 Bin Log 的写入顺序是独立的。假设我们执行一条 <code>UPDATE</code> 语句：</p>
<ol>
<li><p><strong>先写 Redo Log，再写 Bin Log：</strong></p>
<ul>
<li>如果 Redo Log 写完，Bin Log 还没写完时系统宕机。</li>
<li><em>恢复后：</em> 主库通过 Redo Log 恢复了数据（A&#x3D;1）；但 Bin Log 没记录，从库同步时数据仍是旧的（A&#x3D;0）。<strong>主从不一致。</strong></li>
</ul>
</li>
<li><p><strong>先写 Bin Log，再写 Redo Log：</strong></p>
<ul>
<li>如果 Bin Log 写完，Redo Log 没写完时系统宕机。</li>
<li><em>恢复后：</em> 主库因 Redo Log 缺失，事务回滚（A&#x3D;0）；但 Bin Log 已经有了记录，从库会同步这条更新（A&#x3D;1）。<strong>主从不一致。</strong></li>
</ul>
</li>
</ol>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p><strong>两阶段提交是为了让 Redo Log 和 Bin Log 在逻辑上保持一致</strong>。要么同时成功，要么同时失败。</p>
<hr>
<h3 id="两阶段提交流程详解"><a href="#两阶段提交流程详解" class="headerlink" title="两阶段提交流程详解"></a>两阶段提交流程详解</h3><p>假设执行语句：<code>UPDATE user SET age = age + 1 WHERE id = 1;</code></p>
<h4 id="流程图解"><a href="#流程图解" class="headerlink" title="流程图解"></a><strong>流程图解</strong></h4><p>代码段</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    sequenceDiagram
    participant Client as 客户端
    participant Executor as 执行器 (Server层)
    participant InnoDB as InnoDB 引擎
    participant DiskRedo as Redo Log (磁盘)
    participant DiskBin as Bin Log (磁盘)

    Client-&gt;&gt;Executor: 发起 Update 语句
    Executor-&gt;&gt;InnoDB: 查找 ID&#x3D;1 的行
    InnoDB--&gt;&gt;Executor: 返回行数据 (若不在内存则从磁盘读)
    
    Note over Executor: 1. 执行更新操作
    Executor-&gt;&gt;InnoDB: 写入新行数据 (内存更新)

    Note over InnoDB, DiskRedo: 2. Prepare 阶段 (准备)
    InnoDB-&gt;&gt;DiskRedo: 写入 Redo Log (状态: PREPARE)
    
    Note over Executor, DiskBin: 3. 写 Binlog 阶段
    Executor-&gt;&gt;DiskBin: 写入 Bin Log
    
    Note over InnoDB, DiskRedo: 4. Commit 阶段 (提交)
    Executor-&gt;&gt;InnoDB: 提交事务 (调用引擎接口)
    InnoDB-&gt;&gt;DiskRedo: Redo Log 标记为 (状态: COMMIT)
    
    Executor--&gt;&gt;Client: 返回成功
  </pre></div>

<h4 id="详细步骤解析"><a href="#详细步骤解析" class="headerlink" title="详细步骤解析"></a><strong>详细步骤解析</strong></h4><ol>
<li><p><strong>执行阶段：</strong></p>
<ul>
<li>InnoDB 将内存中的数据更新（此时数据在内存中是脏页）。</li>
</ul>
</li>
<li><p><strong>Prepare 阶段 (第一阶段)：</strong></p>
<ul>
<li><p>InnoDB 将本次事务的变更写入 Redo Log，并将 Redo Log 的记录状态标记为 <code>PREPARE</code>。</p>
</li>
<li><p>此时，事务并未真正完成，但数据变更已经持久化到了 Redo Log 中。</p>
</li>
</ul>
</li>
<li><p><strong>写 Bin Log 阶段：</strong></p>
<ul>
<li>MySQL Server 层将事务的逻辑操作写入 Bin Log 文件，并确保写入磁盘（依赖 <code>sync_binlog</code> 参数）。</li>
</ul>
</li>
<li><p><strong>Commit 阶段 (第二阶段)：</strong></p>
<ul>
<li><p>Server 层调用引擎的提交接口。</p>
</li>
<li><p>InnoDB 收到通知后，将 Redo Log 中刚才那条记录的状态由 <code>PREPARE</code> 修改为 <code>COMMIT</code>。</p>
</li>
<li><p>至此，事务彻底完成。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="崩溃恢复逻辑：它是如何保证一致性的？"><a href="#崩溃恢复逻辑：它是如何保证一致性的？" class="headerlink" title="崩溃恢复逻辑：它是如何保证一致性的？"></a>崩溃恢复逻辑：它是如何保证一致性的？</h3><p>如果在上述流程的任意时刻发生宕机（Crash），MySQL 重启后会检查 Redo Log 中的状态：</p>
<ul>
<li><p><strong>情况 A：Redo Log 是完整的 <code>COMMIT</code> 状态</strong></p>
<ul>
<li><p><strong>处理：</strong> 直接根据 Redo Log 提交事务，恢复数据。</p>
</li>
<li><p><strong>结果：</strong> 事务成功。</p>
</li>
</ul>
</li>
<li><p><strong>情况 B：Redo Log 是 <code>PREPARE</code> 状态，且 Bin Log 完整</strong></p>
<ul>
<li><p><em>场景：</em> 步骤 3 完成了（Bin Log 写了），但步骤 4 还没来得及改状态。</p>
</li>
<li><p><strong>处理：</strong> MySQL 扫描 Bin Log，发现该事务的 XID（事务 ID）在 Bin Log 中存在且完整。引擎将 Redo Log 状态补齐为 Commit，提交事务。</p>
</li>
<li><p><strong>结果：</strong> 事务成功（因为 Bin Log 已经有了，为了主从一致，主库必须提交）。</p>
</li>
</ul>
</li>
<li><p><strong>情况 C：Redo Log 是 <code>PREPARE</code> 状态，但 Bin Log 不完整&#x2F;缺失</strong></p>
<ul>
<li><p><em>场景：</em> 步骤 2 完成了，但在写 Bin Log 时宕机。</p>
</li>
<li><p><strong>处理：</strong> 扫描 Bin Log 发现没有对应的 XID。引擎回滚（Rollback）该事务。</p>
</li>
<li><p><strong>结果：</strong> 事务失败（主库回滚，从库也没收到 Bin Log，达成一致）。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p><strong>Redo Log</strong> 救主库（物理恢复），<strong>Bin Log</strong> 救从库（逻辑同步）。</p>
</li>
<li><p><strong>两阶段提交</strong> 就像是一个“握手协议”：</p>
<ul>
<li>先让 Redo Log 做好准备（Prepare）。</li>
<li>再写 Bin Log（关键点）。</li>
<li>最后确认 Redo Log（Commit）。</li>
</ul>
</li>
<li><p><strong>判决标准：</strong> 只要 <strong>Bin Log 写成功了</strong>，这个事务就算成功，Redo Log 即使是 Prepare 状态也会被强制提交；否则就回滚。</p>
</li>
</ul>
</article><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/MySQL_Log.webp" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/posts/65190.html" title="八股文"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/mianshi.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">八股文</div></div><div class="info-2"><div class="info-item-1">BitMap所谓的Bit-map就是用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。 我们可以用一个unsigned int类型的数组或者向量来表示位图，假设我们定义vector a，则 第i位可表示为a[i&#x2F;32]的i%32位（其中，32*N+r &#x3D; i，r为i%32，也就是i&#x2F;32的余数）。 1234567891011121314151617181920212223242526class Bitmap&#123;    private:    vector&lt;size_t&gt; v;    public:    Bitmap(size_t num) : v((num&gt;&gt;5)+1, 0) &#123;&#125;    //set 1    void set(size_t num)    &#123;        v[num&gt;&gt;5] |= (1&lt;&lt;(num &amp; 31)); // num &amp; 31 equ...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Supremes</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">50</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Supremes"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redo-Log"><span class="toc-text">Redo Log</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B7%A6%E4%BE%A7%E5%8C%BA%E5%9F%9F%EF%BC%9AIN-MEMORY-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F-Volatile-%E6%98%93%E5%A4%B1%E6%80%A7"><span class="toc-text">1. 左侧区域：IN-MEMORY (内存区域) - Volatile (易失性)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8F%B3%E4%BE%A7%E5%8C%BA%E5%9F%9F%EF%BC%9AON-DISK-%E7%A3%81%E7%9B%98%E5%8C%BA%E5%9F%9F-Persistent-%E6%8C%81%E4%B9%85%E6%80%A7"><span class="toc-text">2. 右侧区域：ON-DISK (磁盘区域) - Persistent (持久性)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%AD%A3%E5%B8%B8%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C-Normal-Operation"><span class="toc-text">流程详解：正常事务操作 (Normal Operation)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D-Crash-Recovery-Process"><span class="toc-text">流程详解：崩溃恢复 (Crash Recovery Process)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Bin-Log"><span class="toc-text">Bin Log</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%A6%E8%A7%A3"><span class="toc-text">工作流程图详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BB%E5%BA%93%E7%AB%AF-Master-Server-%EF%BC%9A%E8%AE%B0%E5%BD%95%E5%8F%98%E6%9B%B4"><span class="toc-text">1. 主库端 (Master Server)：记录变更</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A4%8D%E5%88%B6%E4%B8%8E%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B%EF%BC%9A%E4%B8%89%E4%B8%AA%E5%85%B3%E9%94%AE%E7%BA%BF%E7%A8%8B"><span class="toc-text">2. 复制与传输过程：三个关键线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-Binlog-Dump-Thread-%E4%B8%BB%E5%BA%93%E7%AB%AF"><span class="toc-text">A. Binlog Dump Thread (主库端)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-I-O-Thread-%E4%BB%8E%E5%BA%93%E7%AB%AF"><span class="toc-text">B. I&#x2F;O Thread (从库端)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-SQL-Thread-%E4%BB%8E%E5%BA%93%E7%AB%AF"><span class="toc-text">C. SQL Thread (从库端)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%8E%E5%BA%93%E7%AB%AF-Replica-Server-%EF%BC%9A%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">3. 从库端 (Replica Server)：最终一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E8%BF%99%E5%BC%A0%E5%9B%BE%E5%91%8A%E8%AF%89%E4%BA%86%E6%88%91%E4%BB%AC%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">总结：这张图告诉了我们什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Undo-Log"><span class="toc-text">Undo Log</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF-Undo-Log%EF%BC%9F"><span class="toc-text">1. 什么是 Undo Log？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%83%E7%9A%84%E4%B8%A4%E5%A4%A7%E6%A0%B8%E5%BF%83%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-text">它的两大核心作用：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Undo-Log-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%A7%A3"><span class="toc-text">2. Undo Log 的工作流程图解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Step-1-%E5%87%86%E5%A4%87%E5%9B%9E%E6%BB%9A%E6%95%B0%E6%8D%AE"><span class="toc-text">Step 1: 准备回滚数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step-2-%E4%BF%AE%E6%94%B9%E5%86%85%E5%AD%98-%E5%86%99-Redo-Log"><span class="toc-text">Step 2: 修改内存 &amp; 写 Redo Log</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step-3-%E6%AD%A4%E6%97%B6%E5%A6%82%E6%9E%9C%E6%9C%89%E5%88%AB%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%9D%A5%E6%9F%A5-MVCC"><span class="toc-text">Step 3: 此时如果有别的事务来查 (MVCC)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step-4-%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4-Commit-%E6%88%96-%E5%9B%9E%E6%BB%9A-Rollback"><span class="toc-text">Step 4: 事务提交 (Commit) 或 回滚 (Rollback)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%B8%80%E4%B8%AA%E5%88%81%E9%92%BB%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9AUndo-Log-%E6%9C%AC%E8%BA%AB%E9%9C%80%E8%A6%81%E6%8C%81%E4%B9%85%E5%8C%96%E5%90%97%EF%BC%9F"><span class="toc-text">3. 一个刁钻的问题：Undo Log 本身需要持久化吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-text">区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-text">问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E2%80%9C%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E2%80%9D-2-PC"><span class="toc-text">为什么需要“两阶段提交” (2 PC)?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E6%99%AF%E9%97%AE%E9%A2%98%EF%BC%9A%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">背景问题：数据一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E7%9A%84"><span class="toc-text">目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3"><span class="toc-text">两阶段提交流程详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%A7%A3"><span class="toc-text">流程图解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4%E8%A7%A3%E6%9E%90"><span class="toc-text">详细步骤解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D%E9%80%BB%E8%BE%91%EF%BC%9A%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="toc-text">崩溃恢复逻辑：它是如何保证一致性的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/356a30bc.html" title="MySQL 日志系统"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/MySQL_Log.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL 日志系统"/></a><div class="content"><a class="title" href="/posts/356a30bc.html" title="MySQL 日志系统">MySQL 日志系统</a><time datetime="2025-12-02T17:26:11.000Z" title="发表于 2025-12-02 17:26 17:26:11">2025-12-02 17:26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/65190.html" title="八股文"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/mianshi.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="八股文"/></a><div class="content"><a class="title" href="/posts/65190.html" title="八股文">八股文</a><time datetime="2025-11-29T09:00:27.000Z" title="发表于 2025-11-29 09:00 09:00:27">2025-11-29 09:00</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/16018.html" title="Redis 学习笔记"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/Redis.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis 学习笔记"/></a><div class="content"><a class="title" href="/posts/16018.html" title="Redis 学习笔记">Redis 学习笔记</a><time datetime="2025-11-29T08:56:10.000Z" title="发表于 2025-11-29 08:56 08:56:10">2025-11-29 08:56</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4947.html" title="TODO"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/TODO.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TODO"/></a><div class="content"><a class="title" href="/posts/4947.html" title="TODO">TODO</a><time datetime="2025-11-29T08:50:05.000Z" title="发表于 2025-11-29 08:50 08:50:05">2025-11-29 08:50</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8508.html" title="MySQL 学习笔记"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/MySQL_learning_note.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL 学习笔记"/></a><div class="content"><a class="title" href="/posts/8508.html" title="MySQL 学习笔记">MySQL 学习笔记</a><time datetime="2025-11-29T08:45:05.000Z" title="发表于 2025-11-29 08:45 08:45:05">2025-11-29 08:45</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Supremes</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="/"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章标题和内容..." type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.2"></script></div></div></body></html>
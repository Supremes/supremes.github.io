<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java | Supremes</title><meta name="author" content="Supremes"><meta name="copyright" content="Supremes"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java 8 新特性Lambda 表达式123456789101112131415private static void testLambda() &#123;    List&lt;String&gt; names &#x3D; Arrays.asList(&quot;name&quot;, &quot;sex&quot;, &quot;hobby&quot;);    &#x2F;&#x2F; with method re">
<meta property="og:type" content="article">
<meta property="og:title" content="Java">
<meta property="og:url" content="https://supremes.github.io/posts/5363d109.html">
<meta property="og:site_name" content="Supremes">
<meta property="og:description" content="Java 8 新特性Lambda 表达式123456789101112131415private static void testLambda() &#123;    List&lt;String&gt; names &#x3D; Arrays.asList(&quot;name&quot;, &quot;sex&quot;, &quot;hobby&quot;);    &#x2F;&#x2F; with method re">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/JAVA8.webp">
<meta property="article:published_time" content="2025-12-04T21:06:42.000Z">
<meta property="article:modified_time" content="2025-12-06T10:42:00.000Z">
<meta property="article:author" content="Supremes">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/JAVA8.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java",
  "url": "https://supremes.github.io/posts/5363d109.html",
  "image": "https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/JAVA8.webp",
  "datePublished": "2025-12-04T21:06:42.000Z",
  "dateModified": "2025-12-06T10:42:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "Supremes",
      "url": "https://supremes.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/favicon/favicon.ico"><link rel="canonical" href="https://supremes.github.io/posts/5363d109.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":10},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">52</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Spring/"><i class="fa-fw fas fa-leaf"></i><span> Spring</span></a></li><li><a class="site-page child" href="/tags/Interview/"><i class="fa-fw fas fa-book"></i><span> 面试</span></a></li><li><a class="site-page child" href="/categories/database/"><i class="fa-fw fas fa-database"></i><span> 数据库</span></a></li><li><a class="site-page child" href="/categories/algorithm/"><i class="fa-fw fas fa-code"></i><span> 算法</span></a></li><li><a class="site-page child" href="/categories/security/"><i class="fa-fw fas fa-shield-alt"></i><span> 网络安全</span></a></li><li><a class="site-page child" href="/categories/message-queue/"><i class="fa-fw fas fa-envelope"></i><span> 消息队列</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/about_me"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/about/my_notes"><i class="fa-fw fas fa-note-sticky"></i><span> 备忘录</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/JAVA8.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Supremes</span></a><a class="nav-page-title" href="/"><span class="site-name">Java</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Spring/"><i class="fa-fw fas fa-leaf"></i><span> Spring</span></a></li><li><a class="site-page child" href="/tags/Interview/"><i class="fa-fw fas fa-book"></i><span> 面试</span></a></li><li><a class="site-page child" href="/categories/database/"><i class="fa-fw fas fa-database"></i><span> 数据库</span></a></li><li><a class="site-page child" href="/categories/algorithm/"><i class="fa-fw fas fa-code"></i><span> 算法</span></a></li><li><a class="site-page child" href="/categories/security/"><i class="fa-fw fas fa-shield-alt"></i><span> 网络安全</span></a></li><li><a class="site-page child" href="/categories/message-queue/"><i class="fa-fw fas fa-envelope"></i><span> 消息队列</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/about_me"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/about/my_notes"><i class="fa-fw fas fa-note-sticky"></i><span> 备忘录</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-04T21:06:42.000Z" title="发表于 2025-12-04 21:06 21:06:42">2025-12-04 21:06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-06T10:42:00.000Z" title="更新于 2025-12-06 10:42 10:42:00">2025-12-06 10:42</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Java-8-新特性"><a href="#Java-8-新特性" class="headerlink" title="Java 8 新特性"></a>Java 8 新特性</h1><h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testLambda</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;sex&quot;</span>, <span class="string">&quot;hobby&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with method reference -- static method</span></span><br><span class="line">    names.forEach(System.out::println);</span><br><span class="line">    names.forEach(name -&gt; System.out.println(name));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with method reference -- instance method</span></span><br><span class="line">    names.sort(String::compareTo);</span><br><span class="line">    names.sort((a, b) -&gt; a.compareTo(b));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with method reference -- constructor method</span></span><br><span class="line">    Supplier&lt;Map&lt;String, String&gt;&gt; mm = () -&gt; <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Supplier&lt;Map&lt;String, String&gt;&gt; supplier = HashMap::<span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><p>Lamda 的基本语法有三步构成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数列表) -&gt; &#123;方法体&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数列表：<code>可省略类型</code>，编译器会自动推断</li>
<li>右侧：Lamda 体，若只有一行代码，可以省略 <code>花括号{}和 return 关键字</code></li>
</ul>
<h3 id="函数式接口-Functional-Interface"><a href="#函数式接口-Functional-Interface" class="headerlink" title="函数式接口 - Functional Interface"></a>函数式接口 - Functional Interface</h3><p>Lambda 表达式不能凭空存在，它必须依附于<strong>函数式接口</strong>。</p>
<blockquote>
<ul>
<li>Lambda 表达式<strong>必须</strong>依托于一个<strong>确定的接口</strong>（JDK 自带的如 <code>Runnable</code>, <code>Predicate</code> 或者你自定义的接口）。</li>
<li>这个接口充当了 Lambda 的“身份证明”。没有这个接口，Java 编译器就不知道如何存储和调用这段代码。</li>
</ul>
</blockquote>
<ul>
<li><strong>定义</strong>：只包含<strong>一个抽象方法</strong>的接口。</li>
<li><strong>注解</strong>：通常使用 <code>@FunctionalInterface</code> 标记（非强制，但推荐）。</li>
<li><strong>常见接口</strong>：<code>Runnable</code>, <code>Comparator</code>, 以及 Java 8 新增的 <code>java.util.function</code> 包下的 <code>Predicate</code>, <code>Consumer</code>, <code>Function</code>, <code>Supplier</code>。</li>
</ul>
<h4 id="四种系统预定义函数式接口-示例代码"><a href="#四种系统预定义函数式接口-示例代码" class="headerlink" title="四种系统预定义函数式接口 - 示例代码"></a>四种系统预定义函数式接口 - <a target="_blank" rel="noopener" href="https://github.com/Supremes/blog_demo_application/blob/master/src/main/java/org/dododo/StreamDemo.java">示例代码</a></h4><h5 id="1-Consumer-消费者"><a href="#1-Consumer-消费者" class="headerlink" title="1. Consumer (消费者)"></a>1. Consumer (消费者)</h5><blockquote>
<p><strong>口诀：只吃不吐（有去无回）</strong></p>
</blockquote>
<ul>
<li><strong>作用</strong>：接收一个参数，进行处理，<strong>不返回任何值</strong>。</li>
<li><strong>抽象方法</strong>：<code>void accept(T t)</code></li>
<li><strong>适用场景</strong>：打印日志、写入数据库、发送消息等“副作用”操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：接收一个 String，把它打印出来（没有返回值）</span></span><br><span class="line">Consumer&lt;String&gt; printer = s -&gt; System.out.println(<span class="string">&quot;Processing: &quot;</span> + s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用：</span></span><br><span class="line">printer.accept(<span class="string">&quot;Hello World&quot;</span>); </span><br><span class="line"><span class="comment">// 输出: Processing: Hello World</span></span><br></pre></td></tr></table></figure>
<h5 id="2-Supplier-供给者"><a href="#2-Supplier-供给者" class="headerlink" title="2. Supplier (供给者)"></a>2. Supplier (供给者)</h5><blockquote>
<p><strong>口诀：无中生有（只吐不吃）</strong></p>
</blockquote>
<ul>
<li><strong>作用</strong>：不接收任何参数，<strong>返回一个结果</strong>。</li>
<li><strong>抽象方法</strong>：<code>T get()</code></li>
<li><strong>适用场景</strong>：生成随机数、获取当前时间、懒加载对象、工厂模式。</li>
</ul>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：不接受参数，返回一个随机整数</span></span><br><span class="line">Supplier&lt;Integer&gt; randomizer = () -&gt; (<span class="type">int</span>)(Math.random() * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用：</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> randomizer.get();</span><br><span class="line">System.out.println(num);</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-Function-函数-转换者"><a href="#3-Function-函数-转换者" class="headerlink" title="3. Function (函数&#x2F;转换者)"></a>3. Function (函数&#x2F;转换者)</h5><blockquote>
<p><strong>口诀：有去有回（加工处理）</strong></p>
</blockquote>
<ul>
<li><strong>作用</strong>：接收一个参数，经过处理后，<strong>返回一个结果</strong>。这是最经典的数学函数概念 $y &#x3D; f(x)$。</li>
<li><strong>抽象方法</strong>：<code>R apply(T t)</code> (T 是输入类型，R 是输出类型)</li>
<li><strong>适用场景</strong>：类型转换（String 转 Integer）、对象提取（User 对象转 UserID）、数据处理。</li>
</ul>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：接收一个 String，返回它的长度 Integer</span></span><br><span class="line"><span class="comment">// Function&lt;输入类型, 输出类型&gt;</span></span><br><span class="line">Function&lt;String, Integer&gt; lengthMapper = s -&gt; s.length();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用：</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> lengthMapper.apply(<span class="string">&quot;Java8&quot;</span>);</span><br><span class="line">System.out.println(len); <span class="comment">// 输出: 5</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-Predicate-断言-裁判"><a href="#4-Predicate-断言-裁判" class="headerlink" title="4. Predicate (断言&#x2F;裁判)"></a>4. Predicate (断言&#x2F;裁判)</h5><blockquote>
<p><strong>口诀：非黑即白（真假判断）</strong></p>
</blockquote>
<ul>
<li><strong>作用</strong>：接收一个参数，<strong>返回一个布尔值 (boolean)</strong>。</li>
<li><strong>抽象方法</strong>：<code>boolean test(T t)</code></li>
<li><strong>适用场景</strong>：数据过滤（filter）、条件判断、权限检查。</li>
</ul>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：接收一个 String，判断它的长度是否大于 5</span></span><br><span class="line">Predicate&lt;String&gt; isLongText = s -&gt; s.length() &gt; <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用：</span></span><br><span class="line">System.out.println(isLongText.test(<span class="string">&quot;Java&quot;</span>));   <span class="comment">// false</span></span><br><span class="line">System.out.println(isLongText.test(<span class="string">&quot;Java8_Lambda&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="总结对比表-Cheat-Sheet"><a href="#总结对比表-Cheat-Sheet" class="headerlink" title="总结对比表 (Cheat Sheet)"></a>总结对比表 (Cheat Sheet)</h5><p>针对 <code>Consumer</code>, <code>Function</code>, <code>Predicate</code> 提供了 “Bi” (Binary，二元) 版本：</p>
<ol>
<li><strong>BiConsumer&lt;T, U&gt;</strong>：接收两个参数，无返回值。<ul>
<li><em>比如：把 Key 和 Value 放入 Map。</em></li>
</ul>
</li>
<li><strong>BiFunction&lt;T, U, R&gt;</strong>：接收两个参数 (T, U)，返回一个结果 (R)。<ul>
<li><em>比如：两个整数相加 <code>(a, b) -&gt; a + b</code>。</em></li>
</ul>
</li>
<li><strong>BiPredicate&lt;T, U&gt;</strong>：接收两个参数，返回 boolean。<ul>
<li><em>比如：判断两个字符串是否相等。</em><br><em>(注：Supplier 不需要 Bi 版本，因为它本身就不接受参数)</em></li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th><strong>接口名</strong></th>
<th><strong>输入参数</strong></th>
<th><strong>返回值</strong></th>
<th><strong>方法名</strong></th>
<th><strong>核心逻辑</strong></th>
<th><strong>典型应用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Consumer<T></strong></td>
<td>T</td>
<td>void</td>
<td><code>accept(t)</code></td>
<td><strong>消费</strong>数据</td>
<td><code>forEach</code> 打印、保存</td>
</tr>
<tr>
<td><strong>Supplier<T></strong></td>
<td>无</td>
<td>T</td>
<td><code>get()</code></td>
<td><strong>提供</strong>数据</td>
<td><code>generate</code> 生成、工厂方法</td>
</tr>
<tr>
<td><strong>Function&lt;T, R&gt;</strong></td>
<td>T</td>
<td>R</td>
<td><code>apply(t)</code></td>
<td><strong>转换</strong>数据</td>
<td><code>map</code> 转换、提取字段</td>
</tr>
<tr>
<td><strong>Predicate<T></strong></td>
<td>T</td>
<td>boolean</td>
<td><code>test(t)</code></td>
<td><strong>判断</strong>数据</td>
<td><code>filter</code> 过滤、验证</td>
</tr>
</tbody></table>
<h2 id="Method-Reference-方法引用"><a href="#Method-Reference-方法引用" class="headerlink" title="Method Reference - 方法引用"></a>Method Reference - 方法引用</h2><blockquote>
<p> 方法引用是 Lambda 表达式的<strong>语法糖</strong>（Syntactic Sugar）。如果你的 Lambda 表达式仅仅是<strong>调用一个已经存在的方法</strong>，那么你可以直接使用方法引用来替代 Lambda。</p>
</blockquote>
<h4 id="语法格式-1"><a href="#语法格式-1" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名或对象名::方法名</span><br></pre></td></tr></table></figure>

<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lamba</span></span><br><span class="line">Function&lt;String, Integer&gt; func = input -&gt; Integer.parseInt(input)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法引用</span></span><br><span class="line">Function&lt;String, Integer&gt; ref = Integer::parseInt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Lambda</strong> 是为了让我们可以把函数当作参数传递，摆脱繁琐的匿名内部类。</li>
<li><strong>方法引用</strong> 是在 Lambda 的基础上，如果逻辑只是“调用一个已有的方法”，则进一步简化代码。</li>
</ul>
<h2 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h2><p><code>Supplier</code> 接口的应用场景通常涉及需要延迟计算、动态生成值、或者在需要提供某种默认值的情况。以下是一些可能的应用场景：</p>
<ol>
<li><p><strong>延迟计算：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Double&gt; randomSupplier = Math::random;</span><br><span class="line"><span class="comment">// 这里并不会立即生成随机数，而是在调用get()时才生成</span></span><br><span class="line"><span class="type">double</span> <span class="variable">randomValue</span> <span class="operator">=</span> randomSupplier.get();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>提供默认值：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;String&gt; defaultStringSupplier = () -&gt; <span class="string">&quot;Default Value&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> getValueFromSomeSource(); <span class="comment">// 某个方法获取值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (value != <span class="literal">null</span>) ? value : defaultStringSupplier.get();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>动态生成对象：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;List&lt;String&gt;&gt; listSupplier = ArrayList::<span class="keyword">new</span>;</span><br><span class="line">List&lt;String&gt; list = listSupplier.get();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>懒加载：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LazyInitializedObject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Supplier&lt;ExpensiveObject&gt; expensiveObjectSupplier = </span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            <span class="type">ExpensiveObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExpensiveObject</span>();</span><br><span class="line">            <span class="comment">// 进行一些初始化或者其他操作</span></span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ExpensiveObject <span class="title function_">getExpensiveObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> expensiveObjectSupplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些例子都展示了如何使用 <code>Supplier</code> 接口来提供一种方法，使得某些值或操作的计算被推迟，直到真正需要这些值的时候再进行计算。这种延迟计算的特性可以提高性能，尤其是在处理昂贵或者资源密集型的操作时。</p>
<h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><p>Stream API 引入了一种新的抽象，用于对集合进行流式操作。它提供了一种声明性的方式来操作数据，支持类似 SQL 的查询语言，使得代码更为清晰和简洁。Stream 操作可以分为中间操作和终端操作。</p>
<p>中间操作可以是链式的，形成一条流水线，例如过滤、映射、排序等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; filteredNames = names.stream()</span><br><span class="line">                                  .filter(name -&gt; name.startsWith(<span class="string">&quot;A&quot;</span>))</span><br><span class="line">                                  .map(String::toUpperCase)</span><br><span class="line">                                  .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>终端操作会触发流水线的执行，例如收集、计数、聚合等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> names.stream().count();</span><br></pre></td></tr></table></figure>

<p>Stream API 使得我们能够以一种更函数式的方式来处理数据，从而提高代码的可读性和可维护性。</p>
<p>Lambda 表达式和 Stream API 通常一起使用，以实现更简洁、高效的集合操作。它们是 Java 向函数式编程的转变迈出的重要一步，为开发者提供了更多灵活性和表达力。</p>
<h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><ol>
<li><p><strong>默认方法（Default Methods）：</strong></p>
<ul>
<li>接口中可以包含默认方法，允许在接口中提供具体实现，而不影响实现该接口的现有类。这为接口的演进提供了更大的灵活性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Default implementation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>函数式接口：</strong></p>
<ul>
<li>函数式接口是只包含一个抽象方法的接口。Java 8 通过 <code>@FunctionalInterface</code> 注解来支持函数式接口的定义，以便更好地支持 Lambda 表达式。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyFunctionalInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>新的日期和时间 API：</strong></p>
<ul>
<li><code>java.time</code> 包提供了全新的日期和时间 API，支持更方便的日期和时间操作，解决了旧的 <code>java.util.Date</code> 和 <code>java.util.Calendar</code> 类的问题。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.now();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>CompletableFuture：</strong></p>
<ul>
<li><code>CompletableFuture</code> 是一个支持异步编程的工具，可以轻松处理异步操作和构建异步应用程序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">                                                   .thenApply(s -&gt; s + <span class="string">&quot; World&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方法引用（Method References）：</strong></p>
<ul>
<li>方法引用是一种简化 Lambda 表达式的语法，它提供了一种直接引用已有方法（静态方法、实例方法或构造方法）的方式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些特性使得 Java 8 在代码编写、集合操作、并发编程等方面变得更加强大和灵活。学习这些特性可以提高代码的效率、可读性，并使代码更具现代化。</p>
<h2 id="Java-17-新特性"><a href="#Java-17-新特性" class="headerlink" title="Java 17 新特性"></a>Java 17 新特性</h2><h3 id="1-文本块-Text-Blocks"><a href="#1-文本块-Text-Blocks" class="headerlink" title="1. 文本块 (Text Blocks)"></a>1. 文本块 (Text Blocks)</h3><blockquote>
<p><strong>解决痛点</strong>：在 Java 代码中拼接 JSON、SQL 或 HTML 字符串简直是噩梦（需要大量的 <code>+</code> 号和转义字符 <code>\&quot;</code>）。</p>
</blockquote>
<ul>
<li><strong>Java 13&#x2F;15 引入</strong></li>
<li>使用三个双引号 <code>&quot;&quot;&quot;</code> 包裹。</li>
</ul>
<p><strong>Java 8 写法：</strong></p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String json = &quot;&#123;\n&quot; +</span><br><span class="line">              &quot;  \&quot;name\&quot;: \&quot;Java\&quot;,\n&quot; +</span><br><span class="line">              &quot;  \&quot;age\&quot;: 17\n&quot; +</span><br><span class="line">              &quot;&#125;&quot;;</span><br></pre></td></tr></table></figure>

<p><strong>Java 17 写法：</strong></p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String json = &quot;&quot;&quot;</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;name&quot;: &quot;Java&quot;,</span><br><span class="line">                &quot;age&quot;: 17</span><br><span class="line">              &#125;</span><br><span class="line">              &quot;&quot;&quot;;</span><br><span class="line">// 所见即所得，自动处理缩进，无需手动转义引号</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-Record-类-Records"><a href="#2-Record-类-Records" class="headerlink" title="2. Record 类 (Records)"></a>2. Record 类 (Records)</h3><blockquote>
<p><strong>解决痛点</strong>：为了写一个简单的 DTO (数据传输对象)，需要写构造器、Getter、<code>equals()</code>、<code>hashCode()</code>、<code>toString()</code>，或者依赖 Lombok。</p>
</blockquote>
<ul>
<li><strong>Java 14&#x2F;16 引入</strong></li>
<li><strong>Record</strong> 是一种特殊的类，它是<strong>不可变 (Immutable)</strong> 的，专门用于承载数据。</li>
</ul>
<p><strong>Java 8 写法 (需要 Lombok 或手动写一大堆)：</strong></p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Point &#123;</span><br><span class="line">    private final int x;</span><br><span class="line">    private final int y;</span><br><span class="line"></span><br><span class="line">    public Point(int x, int y) &#123; </span><br><span class="line">        this.x = x; </span><br><span class="line">        this.y = y; </span><br><span class="line">    &#125;</span><br><span class="line">    // 还要写 getter, equals, hashCode, toString...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Java 17 写法：</strong></p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 一行代码搞定！</span><br><span class="line">// 自动生成：构造器、x() 和 y() 访问方法（注意不叫 getX）、equals、hashCode、toString</span><br><span class="line">public record Point(int x, int y) &#123;&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>Lombok @Data</strong></th>
<th><strong>Java 17 Record</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>本质</strong></td>
<td>代码生成工具 (Annotation Processor)</td>
<td>Java 语言特性 (Class 的变体)</td>
</tr>
<tr>
<td><strong>可变性</strong></td>
<td><strong>Mutable</strong> (有 Setters)</td>
<td><strong>Immutable</strong> (无 Setters, 全 final)</td>
</tr>
<tr>
<td><strong>继承</strong></td>
<td>可以继承&#x2F;被继承</td>
<td><strong>不可继承</strong> (隐式 final)</td>
</tr>
<tr>
<td><strong>访问器命名</strong></td>
<td><code>getName()</code></td>
<td><code>name()</code></td>
</tr>
<tr>
<td><strong>无参构造器</strong></td>
<td>默认有 (或通过 <code>@NoArgsConstructor</code>)</td>
<td><strong>默认无</strong> (只有全参构造器)</td>
</tr>
<tr>
<td><strong>框架支持</strong></td>
<td>100% 支持 (JavaBean 规范)</td>
<td>需要较新框架支持 (Jackson 2.12+, Spring 5.3+)</td>
</tr>
<tr>
<td><strong>最佳用途</strong></td>
<td><strong>JPA Entity (实体类)</strong></td>
<td><strong>DTO, VO, Config, Map Key</strong></td>
</tr>
</tbody></table>
<hr>
<h3 id="3-Switch-表达式-Switch-Expressions"><a href="#3-Switch-表达式-Switch-Expressions" class="headerlink" title="3. Switch 表达式 (Switch Expressions)"></a>3. Switch 表达式 (Switch Expressions)</h3><blockquote>
<p><strong>解决痛点</strong>：旧的 switch 语法繁琐，容易漏写 <code>break</code> 导致 bug，且不能直接作为返回值赋值给变量。</p>
</blockquote>
<ul>
<li><strong>Java 12&#x2F;14 引入</strong></li>
<li>支持 <code>-&gt;</code> 箭头语法，无需 <code>break</code>。</li>
</ul>
<p><strong>Java 8 写法：</strong></p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String day = &quot;MONDAY&quot;;</span><br><span class="line">int num;</span><br><span class="line">switch (day) &#123;</span><br><span class="line">    case &quot;MONDAY&quot;:</span><br><span class="line">    case &quot;FRIDAY&quot;:</span><br><span class="line">    case &quot;SUNDAY&quot;:</span><br><span class="line">        num = 6;</span><br><span class="line">        break;</span><br><span class="line">    case &quot;TUESDAY&quot;:</span><br><span class="line">        num = 7;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        num = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Java 17 写法：</strong></p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 直接返回值，逻辑清晰，无 break</span><br><span class="line">int num = switch (day) &#123;</span><br><span class="line">    case &quot;MONDAY&quot;, &quot;FRIDAY&quot;, &quot;SUNDAY&quot; -&gt; 6;</span><br><span class="line">    case &quot;TUESDAY&quot; -&gt; 7;</span><br><span class="line">    default -&gt; 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-instanceof-模式匹配-Pattern-Matching-for-instanceof"><a href="#4-instanceof-模式匹配-Pattern-Matching-for-instanceof" class="headerlink" title="4. instanceof 模式匹配 (Pattern Matching for instanceof)"></a>4. instanceof 模式匹配 (Pattern Matching for instanceof)</h3><blockquote>
<p><strong>解决痛点</strong>：每次判断完 <code>instanceof</code>，还得强制类型转换一次，非常啰嗦。</p>
</blockquote>
<ul>
<li><strong>Java 14&#x2F;16 引入</strong></li>
</ul>
<p><strong>Java 8 写法：</strong></p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = &quot;Hello&quot;;</span><br><span class="line">if (obj instanceof String) &#123;</span><br><span class="line">    String s = (String) obj; // 必须强转</span><br><span class="line">    System.out.println(s.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Java 17 写法：</strong></p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = &quot;Hello&quot;;</span><br><span class="line">// 如果是 String，直接转为变量 s，大括号内直接用</span><br><span class="line">if (obj instanceof String s) &#123;</span><br><span class="line">    System.out.println(s.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="其他重要更新-一句话带过"><a href="#其他重要更新-一句话带过" class="headerlink" title="其他重要更新 (一句话带过)"></a>其他重要更新 (一句话带过)</h3><ol>
<li><p><strong>var 关键字 (Java 10)</strong>：局部变量类型推断。</p>
<ul>
<li><code>var list = new ArrayList&lt;String&gt;();</code> （编译器自动推断 list 是 ArrayList 类型）。</li>
</ul>
</li>
<li><p><strong>密封类 Sealed Classes (Java 15&#x2F;17)</strong>：</p>
<ul>
<li>允许你控制<strong>谁可以继承我</strong>。</li>
<li><code>public sealed class Shape permits Circle, Square {}</code></li>
<li>这对于编写严谨的领域模型或框架非常有用。</li>
</ul>
</li>
<li><p><strong>更有用的 NullPointerException (Java 14)</strong>：</p>
<ul>
<li>以前只报 NPE，不告诉你是哪个对象空了。</li>
<li>现在会提示：<code>Cannot invoke &quot;String.length()&quot; because &quot;name&quot; is null</code>。</li>
</ul>
</li>
<li><p><strong>Stream.toList() (Java 16)</strong>：</p>
<ul>
<li>以前：<code>.collect(Collectors.toList())</code></li>
<li>现在：<code>.toList()</code> (注意：这个返回的是不可变 List)。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结：为什么要升-Java-17？"><a href="#总结：为什么要升-Java-17？" class="headerlink" title="总结：为什么要升 Java 17？"></a>总结：为什么要升 Java 17？</h3><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>影响</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Record</strong></td>
<td><strong>干掉 DTO 样板代码</strong>，甚至可能不再需要 Lombok 的 <code>@Data</code>。</td>
</tr>
<tr>
<td><strong>Text Blocks</strong></td>
<td><strong>SQL&#x2F;JSON 拼接神器</strong>，代码可读性提升 10 倍。</td>
</tr>
<tr>
<td><strong>Switch 表达式</strong></td>
<td>逻辑更紧凑，减少 Bug。</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>G1 垃圾回收器优化，以及 <strong>ZGC</strong> (低延迟 GC) 的成熟，应用吞吐量更高。</td>
</tr>
<tr>
<td><strong>Spring Boot 3</strong></td>
<td><strong>强制要求</strong> Java 17+。</td>
</tr>
</tbody></table>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Interview/">面试</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/JAVA8.webp" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/3c3cdb74.html" title="Git 学习笔记"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/GIT.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Git 学习笔记</div></div><div class="info-2"><div class="info-item-1">git rm --cache &lt;filename&gt;  让 git 停止跟踪某个文件，但是不删除本地的文件  常用语某些“亡羊补牢”的场景，把不该提交的配置文件提到到了 Git，现在需要从仓库中删除，但本地还需要使用，通常配合 .gitignore 使用。 .gitignore只对 未被追踪 untracked 的文件有效，一旦文件之前被 commit 过，git 便会无视该文件的配置，因此需要配合上述 git rm --cahce 使用。 git restore &lt;filename&gt;旧版命令：git checkout -- &lt;文件名&gt; 放弃 工作区 的修改，用 暂存区 覆盖 工作区。  如果 工作区 没有改动，便会直接撤销工作区的改动 如果 工作区 有改动，便会覆盖  git restore --staged &lt;filename&gt;旧命令: &#96;git reset HEAD &#96;&#96; 将文件从 暂存区 切换到 工作区 , 即在执行完 git add 命令后，用来撤回。 git stash</div></div></div></a><a class="pagination-related" href="/posts/eb9166f8.html" title="JUC并发编程"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/JUC.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">JUC并发编程</div></div><div class="info-2"><div class="info-item-1">好的，阅读 JUC（Java Util Concurrent）源码是一项非常棒的学习任务，它能让你深入理解 Java 并发编程的精髓，以及 JVM 和操作系统层面的一些知识。JUC 包是 Java 并发编程的基石，包含了线程池、锁、原子操作、并发集合等核心组件。 下面为你列一个 JUC 源码学习的大纲，并提供一些学习建议：  JUC 源码学习大纲第一阶段：基础知识回顾与工具准备  并发基础理论： 可见性、原子性、有序性： 深入理解这三大特性及其在并发中的重要性。 JMM (Java Memory Model)： 了解 Java 内存模型如何保证并发的正确性。 Happens-Before 原则： 理解它如何定义操作之间的顺序。 锁的原理： 了解悲观锁、乐观锁，以及自旋锁等概念。 AQS (AbstractQueuedSynchronizer) 概述： 对 AQS 有一个初步的认识，它是 JUC 许多高级同步器的基石。 CAS (Compare-And-Swap) 原理： 理解其三步操作和 ABA 问题。   Lombok 与 @SneakyThrows： Lombok 在 JUC...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/750d7523.html" title="Spring Cloud"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/SpringCloud.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-04 20:54</div><div class="info-item-2">Spring Cloud</div></div><div class="info-2"><div class="info-item-1">Spring Cloud 是一个广泛用于构建微服务架构的框架集合，涵盖了服务发现、配置管理、负载均衡、熔断器、API 网关、消息总线等多个方面。以下是一个系统的 Spring Cloud 学习路线，适合初学者循序渐进地掌握其核心内容。  1. 基础准备在学习 Spring Cloud 之前，需要打好以下基础：  Java 基础：熟悉 Java 编程语言，包括面向对象编程、集合框架、异常处理等。 Spring Boot：Spring Cloud 基于 Spring Boot 构建，需掌握 Spring Boot 的核心概念，如自动配置、依赖注入、RESTful API 开发、Spring Data JPA 等。 微服务架构：了解微服务的基本概念、优缺点，以及与传统单体应用的区别。 HTTP 和 REST：掌握 HTTP 协议和 RESTful 服务设计原则。 Maven 或 Gradle：熟悉项目构建工具，学会管理依赖和构建项目。   2. Spring Cloud 核心组件学习Spring Cloud 由多个子项目组成，每个子项目解决微服务架构中的特定问题。以下是核心组件及其推荐...</div></div></div></a><a class="pagination-related" href="/posts/2d0b435f.html" title="Spring MVC"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/SpringMVC.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-04 20:51</div><div class="info-item-2">Spring MVC</div></div><div class="info-2"><div class="info-item-1">SpringMVC 工作原理引言Spring MVC 框架作为 Java Web 应用程序开发中广泛采用的框架，以其分层和松耦合的架构而闻名。这种架构清晰地分离了表示层、持久层和控制层，使得开发人员能够独立地处理各个模块，并将其组合成专业的 Web 应用程序。遵循 MVC 标准开发的 Web 应用程序更易于扩展、更新和管理，因为松耦合的分层结构使得在特定层进行修改变得更加便捷 1。本报告旨在深入探讨 Spring MVC 框架内 HTTP 请求的完整生命周期，从客户端发起请求到最终响应返回，详细阐述其内部的工作原理。 理解模型-视图-控制器（MVC）模式模型-视图-控制器（MVC）是一种广泛应用于软件工程中的架构模式，旨在分离应用程序的不同关注点，从而提高代码的可维护性和可重用性 3。在 MVC 模式中，应用程序被划分为三个核心组件：  模型（Model）： 模型负责封装应用程序的数据和业务逻辑 2。它是应用程序的核心，管理着数据的存储、检索和处理 4。模型独立于用户界面，当模型中的数据发生变化时，它会通知视图进行更新 4。 视图（View）： 视图负责呈现模型中的数据，并将其转...</div></div></div></a><a class="pagination-related" href="/posts/fed01c2.html" title="Spring 过滤器"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/Spring%E8%BF%87%E6%BB%A4%E5%99%A8.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-03 22:37</div><div class="info-item-2">Spring 过滤器</div></div><div class="info-2"><div class="info-item-1">Filter 和 InterceptorFilter 过滤器 Servlet 容器维度的，拦截 Servlet 的请求。 通过 Filter 接口实现的  Servlet 容器： Tomcat、Jetty。遵循 Java Servlet 规范，通常包括 HTTP 服务器，处理 web 请求和响应。 Interceptor 拦截器 Spring 容器维度的，对 Spring MVC 的请求进行拦截。 通过实现 HandlerInterceptor 接口实现的，并通过 Spring 的配置进行注册。  PS：Spring 框架嵌入到 Servlet 容器中，利用 spring 容器管理应用程序中的其他组件:  Spring Beans： 在 Spring 框架中，你可以定义和配置各种 Bean，包括业务逻辑组件、数据访问组件、服务等。这些 Bean 的生命周期、依赖关系等都由 Spring 容器管理。 Service 层和业务逻辑： 你可以使用 Spring 来管理业务逻辑层的组件，使其成为 Spring 容器管理的 Bean。这些业务逻辑组件通常包括服务层的实现，处理业务逻辑、事务...</div></div></div></a><a class="pagination-related" href="/posts/60441.html" title="Spring AOP 事务失效与底层代理机制深度总结"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/AOP-PROXY.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-25 20:39</div><div class="info-item-2">Spring AOP 事务失效与底层代理机制深度总结</div></div><div class="info-2"><div class="info-item-1">Spring AOP 事务失效与底层代理机制深度总结1. 核心问题：为什么自调用导致事务失效？现象在同一个类中，方法 A 调用方法 B（this.methodB()），即使方法 B 上加了 @Transactional 注解，事务依然不生效。 根本原因Spring AOP 的默认实现基于 代理模式 (Proxy Pattern)。Spring 容器中注入的 Bean 实际上是一个 代理对象 (Proxy)，它持有你编写的 目标对象 (Target)。  生效路径：外部调用 $\rightarrow$ Proxy $\rightarrow$ 事务拦截器 (Interceptor) $\rightarrow$ Target。 失效路径：Target 内部调用 $\rightarrow$ this.methodB() $\rightarrow$ Target。  此时，this 指针指向的是目标对象本身。代码执行流直接在目标对象内部流转，完全绕过了外层的代理对象及其持有的事务拦截器。 形象比喻 Proxy (代理)：大楼门口的安检员。 Target (目标)：大楼里的员工。 外部访问：...</div></div></div></a><a class="pagination-related" href="/posts/eb9166f8.html" title="JUC并发编程"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/JUC.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-04 21:00</div><div class="info-item-2">JUC并发编程</div></div><div class="info-2"><div class="info-item-1">好的，阅读 JUC（Java Util Concurrent）源码是一项非常棒的学习任务，它能让你深入理解 Java 并发编程的精髓，以及 JVM 和操作系统层面的一些知识。JUC 包是 Java 并发编程的基石，包含了线程池、锁、原子操作、并发集合等核心组件。 下面为你列一个 JUC 源码学习的大纲，并提供一些学习建议：  JUC 源码学习大纲第一阶段：基础知识回顾与工具准备  并发基础理论： 可见性、原子性、有序性： 深入理解这三大特性及其在并发中的重要性。 JMM (Java Memory Model)： 了解 Java 内存模型如何保证并发的正确性。 Happens-Before 原则： 理解它如何定义操作之间的顺序。 锁的原理： 了解悲观锁、乐观锁，以及自旋锁等概念。 AQS (AbstractQueuedSynchronizer) 概述： 对 AQS 有一个初步的认识，它是 JUC 许多高级同步器的基石。 CAS (Compare-And-Swap) 原理： 理解其三步操作和 ABA 问题。   Lombok 与 @SneakyThrows： Lombok 在 JUC...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Supremes</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">52</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Supremes"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-8-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">Java 8 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">Lambda 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-text">语法格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3-Functional-Interface"><span class="toc-text">函数式接口 - Functional Interface</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E7%B3%BB%E7%BB%9F%E9%A2%84%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-text">四种系统预定义函数式接口 - 示例代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Consumer-%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-text">1. Consumer (消费者)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Supplier-%E4%BE%9B%E7%BB%99%E8%80%85"><span class="toc-text">2. Supplier (供给者)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Function-%E5%87%BD%E6%95%B0-%E8%BD%AC%E6%8D%A2%E8%80%85"><span class="toc-text">3. Function (函数&#x2F;转换者)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-Predicate-%E6%96%AD%E8%A8%80-%E8%A3%81%E5%88%A4"><span class="toc-text">4. Predicate (断言&#x2F;裁判)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94%E8%A1%A8-Cheat-Sheet"><span class="toc-text">总结对比表 (Cheat Sheet)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Method-Reference-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">Method Reference - 方法引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F-1"><span class="toc-text">语法格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Supplier"><span class="toc-text">Supplier</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stream-API"><span class="toc-text">Stream API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Others"><span class="toc-text">Others</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-17-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">Java 17 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%96%87%E6%9C%AC%E5%9D%97-Text-Blocks"><span class="toc-text">1. 文本块 (Text Blocks)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Record-%E7%B1%BB-Records"><span class="toc-text">2. Record 类 (Records)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Switch-%E8%A1%A8%E8%BE%BE%E5%BC%8F-Switch-Expressions"><span class="toc-text">3. Switch 表达式 (Switch Expressions)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-instanceof-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D-Pattern-Matching-for-instanceof"><span class="toc-text">4. instanceof 模式匹配 (Pattern Matching for instanceof)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E6%9B%B4%E6%96%B0-%E4%B8%80%E5%8F%A5%E8%AF%9D%E5%B8%A6%E8%BF%87"><span class="toc-text">其他重要更新 (一句话带过)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8D%87-Java-17%EF%BC%9F"><span class="toc-text">总结：为什么要升 Java 17？</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/3c3cdb74.html" title="Git 学习笔记"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/GIT.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 学习笔记"/></a><div class="content"><a class="title" href="/posts/3c3cdb74.html" title="Git 学习笔记">Git 学习笔记</a><time datetime="2025-12-06T10:47:14.000Z" title="发表于 2025-12-06 10:47 10:47:14">2025-12-06 10:47</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5363d109.html" title="Java"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/JAVA8.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java"/></a><div class="content"><a class="title" href="/posts/5363d109.html" title="Java">Java</a><time datetime="2025-12-04T21:06:42.000Z" title="发表于 2025-12-04 21:06 21:06:42">2025-12-04 21:06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/eb9166f8.html" title="JUC并发编程"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/JUC.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC并发编程"/></a><div class="content"><a class="title" href="/posts/eb9166f8.html" title="JUC并发编程">JUC并发编程</a><time datetime="2025-12-04T21:00:06.000Z" title="发表于 2025-12-04 21:00 21:00:06">2025-12-04 21:00</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/750d7523.html" title="Spring Cloud"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/SpringCloud.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Cloud"/></a><div class="content"><a class="title" href="/posts/750d7523.html" title="Spring Cloud">Spring Cloud</a><time datetime="2025-12-04T20:54:30.000Z" title="发表于 2025-12-04 20:54 20:54:30">2025-12-04 20:54</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2d0b435f.html" title="Spring MVC"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/SpringMVC.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring MVC"/></a><div class="content"><a class="title" href="/posts/2d0b435f.html" title="Spring MVC">Spring MVC</a><time datetime="2025-12-04T20:51:26.000Z" title="发表于 2025-12-04 20:51 20:51:26">2025-12-04 20:51</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Supremes</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="/"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章标题和内容..." type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.2"></script></div></div></body></html>
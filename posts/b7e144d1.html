<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>算法 | Supremes</title><meta name="author" content="Supremes"><meta name="copyright" content="Supremes"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="刷题方案作为一个以 Java 后台开发 为职业目标的初学者，你的刷题策略不能仅仅是“解出题目”，更需要体现出你对 Java 语言特性的理解以及良好的工程素养。 以下是为你定制的最佳刷题方案和语言建议：  一、 核心问题：选什么语言？结论：毫无疑问，必须用 Java。 虽然 Python 代码更短，C++ 运行更快，但对于面试 Java 后台 岗位，使用 Java 刷题有巨大的战略优势：  证明熟练">
<meta property="og:type" content="article">
<meta property="og:title" content="算法">
<meta property="og:url" content="https://supremes.github.io/posts/b7e144d1.html">
<meta property="og:site_name" content="Supremes">
<meta property="og:description" content="刷题方案作为一个以 Java 后台开发 为职业目标的初学者，你的刷题策略不能仅仅是“解出题目”，更需要体现出你对 Java 语言特性的理解以及良好的工程素养。 以下是为你定制的最佳刷题方案和语言建议：  一、 核心问题：选什么语言？结论：毫无疑问，必须用 Java。 虽然 Python 代码更短，C++ 运行更快，但对于面试 Java 后台 岗位，使用 Java 刷题有巨大的战略优势：  证明熟练">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/algorithm_cover.webp">
<meta property="article:published_time" content="2025-12-03T22:26:09.000Z">
<meta property="article:modified_time" content="2025-12-03T22:46:00.000Z">
<meta property="article:author" content="Supremes">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/algorithm_cover.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "算法",
  "url": "https://supremes.github.io/posts/b7e144d1.html",
  "image": "https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/algorithm_cover.webp",
  "datePublished": "2025-12-03T22:26:09.000Z",
  "dateModified": "2025-12-03T22:46:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "Supremes",
      "url": "https://supremes.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/favicon/favicon.ico"><link rel="canonical" href="https://supremes.github.io/posts/b7e144d1.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":10},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Spring/"><i class="fa-fw fas fa-leaf"></i><span> Spring</span></a></li><li><a class="site-page child" href="/tags/Interview/"><i class="fa-fw fas fa-book"></i><span> 面试</span></a></li><li><a class="site-page child" href="/categories/database/"><i class="fa-fw fas fa-database"></i><span> 数据库</span></a></li><li><a class="site-page child" href="/categories/algorithm/"><i class="fa-fw fas fa-code"></i><span> 算法</span></a></li><li><a class="site-page child" href="/categories/security/"><i class="fa-fw fas fa-shield-alt"></i><span> 网络安全</span></a></li><li><a class="site-page child" href="/categories/message-queue/"><i class="fa-fw fas fa-envelope"></i><span> 消息队列</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/about_me"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/about/my_notes"><i class="fa-fw fas fa-note-sticky"></i><span> 备忘录</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/algorithm_cover.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Supremes</span></a><a class="nav-page-title" href="/"><span class="site-name">算法</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Spring/"><i class="fa-fw fas fa-leaf"></i><span> Spring</span></a></li><li><a class="site-page child" href="/tags/Interview/"><i class="fa-fw fas fa-book"></i><span> 面试</span></a></li><li><a class="site-page child" href="/categories/database/"><i class="fa-fw fas fa-database"></i><span> 数据库</span></a></li><li><a class="site-page child" href="/categories/algorithm/"><i class="fa-fw fas fa-code"></i><span> 算法</span></a></li><li><a class="site-page child" href="/categories/security/"><i class="fa-fw fas fa-shield-alt"></i><span> 网络安全</span></a></li><li><a class="site-page child" href="/categories/message-queue/"><i class="fa-fw fas fa-envelope"></i><span> 消息队列</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/about_me"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/about/my_notes"><i class="fa-fw fas fa-note-sticky"></i><span> 备忘录</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-03T22:26:09.000Z" title="发表于 2025-12-03 22:26 22:26:09">2025-12-03 22:26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-03T22:46:00.000Z" title="更新于 2025-12-03 22:46 22:46:00">2025-12-03 22:46</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/algorithm/">算法</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/algorithm/Interview/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="刷题方案"><a href="#刷题方案" class="headerlink" title="刷题方案"></a>刷题方案</h2><p>作为一个以 <strong>Java 后台开发</strong> 为职业目标的初学者，你的刷题策略不能仅仅是“解出题目”，更需要体现出你对 Java 语言特性的理解以及良好的工程素养。</p>
<p>以下是为你定制的最佳刷题方案和语言建议：</p>
<hr>
<h3 id="一、-核心问题：选什么语言？"><a href="#一、-核心问题：选什么语言？" class="headerlink" title="一、 核心问题：选什么语言？"></a>一、 核心问题：选什么语言？</h3><p><strong>结论：毫无疑问，必须用 Java。</strong></p>
<p>虽然 Python 代码更短，C++ 运行更快，但对于面试 <strong>Java 后台</strong> 岗位，使用 Java 刷题有巨大的战略优势：</p>
<ol>
<li><strong>证明熟练度：</strong> 面试官会考察你对 Java API 的熟悉程度（例如 <code>ArrayList</code> vs <code>LinkedList</code>，<code>HashMap</code> 的使用，<code>PriorityQueue</code> 的自定义排序等）。</li>
<li><strong>避免认知割裂：</strong> 你的项目是 Java 写的，八股文背的是 JVM 和 JUC，如果算法用 Python 写，面试时需要在两种思维模式间切换，容易出错。</li>
<li><strong>源码追问：</strong> 面试官经常会在你写完算法后，指着你用到的某个类问底层实现（比如：“你这里用了 <code>HashMap</code>，能讲讲它的扩容机制吗？”）。如果你用 Java 写，这种过渡非常自然。</li>
</ol>
<hr>
<h3 id="二、-最佳刷题路线图-分阶段执行"><a href="#二、-最佳刷题路线图-分阶段执行" class="headerlink" title="二、 最佳刷题路线图 (分阶段执行)"></a>二、 最佳刷题路线图 (分阶段执行)</h3><p>不要一上来就从 LeetCode 第 1 题开始做，那是效率最低的方法。建议按照 <strong>“知识点分类 + 高频题优先”</strong> 的策略。</p>
<h4 id="第一阶段：夯实地基-2-3-周"><a href="#第一阶段：夯实地基-2-3-周" class="headerlink" title="第一阶段：夯实地基 (2-3 周)"></a>第一阶段：夯实地基 (2-3 周)</h4><p>目标： 熟悉 Java 常用集合类的 API，掌握基本数据结构。</p>
<p>重点： 数组 (Array)、链表 (Linked List)、哈希表 (HashMap)。</p>
<ul>
<li><strong>必做动作：</strong> 不要在 IDE (IntelliJ IDEA) 里写代码，尝试在网页编辑器里写，习惯没有代码补全的环境。</li>
<li><strong>Java 关键点：</strong><ul>
<li>熟练掌握 <code>String</code> 和 <code>StringBuilder</code> 的转换。</li>
<li>熟练掌握 <code>List</code> 转 <code>Array</code>，<code>Array</code> 转 <code>List</code>。</li>
<li>理解 <code>==</code> 和 <code>.equals()</code> 在处理对象时的区别。</li>
</ul>
</li>
</ul>
<h4 id="第二阶段：专题突破-1-2-个月"><a href="#第二阶段：专题突破-1-2-个月" class="headerlink" title="第二阶段：专题突破 (1-2 个月)"></a>第二阶段：专题突破 (1-2 个月)</h4><p>目标： 掌握面试中最常见的算法模式（Pattern）。</p>
<p>策略： 按标签刷题。不要今天做一道数组，明天做一道动态规划。</p>
<p>推荐顺序及经典题（括号内为 LeetCode 题号）：</p>
<ol>
<li><p><strong>双指针 (Two Pointers):</strong> 解决数组、链表问题。</p>
<ul>
<li><em>例题：</em> 两数之和 (1), 移动零 (283), 环形链表 (141)。</li>
</ul>
</li>
<li><p><strong>二分查找 (Binary Search):</strong> 简单但细节多。</p>
<ul>
<li><em>例题：</em> 二分查找 (704), 搜索插入位置 (35)。</li>
</ul>
</li>
<li><p><strong>树与递归 (Tree &amp; DFS&#x2F;BFS):</strong> <strong>重中之重</strong>，后台开发处理层级数据最常用。</p>
<ul>
<li>*例题：*二叉树的最大深度 (104), 翻转二叉树 (226), 层序遍历 (102)。</li>
</ul>
</li>
<li><p><strong>哈希表 (Hash Table):</strong> 空间换时间的核心。</p>
<ul>
<li><em>例题：</em> 有效的字母异位词 (242), 多数元素 (169)。</li>
</ul>
</li>
</ol>
<h4 id="第三阶段：高频冲刺-面试前-1-个月"><a href="#第三阶段：高频冲刺-面试前-1-个月" class="headerlink" title="第三阶段：高频冲刺 (面试前 1 个月)"></a>第三阶段：高频冲刺 (面试前 1 个月)</h4><p>目标： 针对国内大厂面试风格进行突击。</p>
<p>工具： CodeTop (企业题库)。</p>
<ul>
<li>国内面试不像国外那么随机，热题重复率极高。</li>
<li>去 CodeTop 查看“字节跳动”、“阿里”、“美团”等公司最近半年的高频题。</li>
<li><strong>重点攻克：</strong> 前 100 高频题，必须烂熟于心（能手写 bug-free）。</li>
</ul>
<hr>
<h3 id="三、-避坑指南-刷题心法"><a href="#三、-避坑指南-刷题心法" class="headerlink" title="三、 避坑指南 &amp; 刷题心法"></a>三、 避坑指南 &amp; 刷题心法</h3><h4 id="1-“五分钟法则”"><a href="#1-“五分钟法则”" class="headerlink" title="1. “五分钟法则”"></a>1. “五分钟法则”</h4><p>如果一道题你 <strong>5 分钟</strong> 没有任何思路，<strong>直接看题解</strong>。</p>
<ul>
<li>初学者最忌讳在一道题上死磕 2 小时，这会极大地打击自信心，且效率极低。你的目的是“学习模式”，而不是“发明算法”。</li>
</ul>
<h4 id="2-理解-记忆-不要死记代码"><a href="#2-理解-记忆-不要死记代码" class="headerlink" title="2. 理解 &gt; 记忆 (不要死记代码)"></a>2. 理解 &gt; 记忆 (不要死记代码)</h4><ul>
<li><strong>错误做法：</strong> 背诵代码的每一行。</li>
<li><strong>正确做法：</strong> 记住解题的**“骨架”**。例如，写 BFS (广度优先搜索) 时，脑子里应该立刻浮现出 <code>Queue</code> 和 <code>while(!queue.isEmpty())</code> 的结构。</li>
</ul>
<h4 id="3-利用-Java-特性“取巧”"><a href="#3-利用-Java-特性“取巧”" class="headerlink" title="3. 利用 Java 特性“取巧”"></a>3. 利用 Java 特性“取巧”</h4><p>面试时，合理利用 Java 标准库可以节省大量时间：</p>
<ul>
<li><strong>排序：</strong> <code>Arrays.sort()</code> 或 <code>Collections.sort()</code>。</li>
<li><strong>栈：</strong> 不要用 <code>Stack</code> 类（它是遗留类，性能差），要用 <code>Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();</code>。</li>
<li><strong>大顶堆&#x2F;小顶堆：</strong> <code>PriorityQueue</code>，例如 <code>new PriorityQueue&lt;&gt;((a, b) -&gt; b - a)</code> 实现大顶堆。</li>
</ul>
<h4 id="4-坚持“三遍刷题法”"><a href="#4-坚持“三遍刷题法”" class="headerlink" title="4. 坚持“三遍刷题法”"></a>4. 坚持“三遍刷题法”</h4><ul>
<li>**第一遍：**看题解，理解思路，照着敲出来。</li>
<li><strong>第二遍：</strong>（次日）不看题解，凭记忆和理解独立写出来。</li>
<li><strong>第三遍：</strong>（一周后）复习，如果还能写出来，说明真正掌握了。</li>
</ul>
<hr>
<h3 id="四、-Java-后台面试必会的“数据结构映射”"><a href="#四、-Java-后台面试必会的“数据结构映射”" class="headerlink" title="四、 Java 后台面试必会的“数据结构映射”"></a>四、 Java 后台面试必会的“数据结构映射”</h3><p>在 Java 后台面试中，算法题往往对应着实际场景，请务必建立以下联系：</p>
<table>
<thead>
<tr>
<th><strong>算法&#x2F;数据结构</strong></th>
<th><strong>Java 实现类</strong></th>
<th><strong>后台开发实际场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>动态数组</strong></td>
<td><code>ArrayList</code></td>
<td>绝大多数列表数据的存储</td>
</tr>
<tr>
<td><strong>链表</strong></td>
<td><code>LinkedList</code></td>
<td>频繁增删的场景 (如 LRU 缓存设计)</td>
</tr>
<tr>
<td><strong>哈希映射</strong></td>
<td><code>HashMap</code> &#x2F; <code>ConcurrentHashMap</code></td>
<td>缓存、快速查找、Spring Bean 容器</td>
</tr>
<tr>
<td><strong>树 (Tree)</strong></td>
<td><code>TreeMap</code> (红黑树)</td>
<td>数据库索引 (B+树)、有序数据存储</td>
</tr>
<tr>
<td><strong>堆 (Heap)</strong></td>
<td><code>PriorityQueue</code></td>
<td>任务调度系统、延时队列</td>
</tr>
</tbody></table>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>作为 Java 后台初学者，你的战略应该是：</p>
<ol>
<li><strong>锁定 Java 语言</strong>。</li>
<li><strong>前期</strong>按<strong>标签</strong>刷（数组 -&gt; 链表 -&gt; 树 -&gt; 搜索）。</li>
<li><strong>后期</strong>按<strong>CodeTop 高频榜</strong>刷。</li>
<li>遇到难题<strong>不要死磕</strong>，看懂答案并<strong>重复练习</strong>。</li>
</ol>
<h2 id="Java-刷题常用-API-速查表"><a href="#Java-刷题常用-API-速查表" class="headerlink" title="Java 刷题常用 API 速查表"></a>Java 刷题常用 API 速查表</h2><p>这份 <strong>“Java 刷题常用 API 速查表”</strong> 是专为 LeetCode 算法题定制的。</p>
<p>在实际的 Java 后台开发中，我们可能会用到复杂的 Stream 流或第三方工具库（如 Guava&#x2F;Apache Commons），但在<strong>刷题和机试</strong>中，尽量只使用 JDK 原生提供的、最基础、最高效的方法。</p>
<p>以下是按<strong>数据结构</strong>分类的核心 API 讲解：</p>
<hr>
<h3 id="1-数组与字符串-Array-String"><a href="#1-数组与字符串-Array-String" class="headerlink" title="1. 数组与字符串 (Array &amp; String)"></a>1. 数组与字符串 (Array &amp; String)</h3><p>这是最基础的部分，注意 Java 中 String 是<strong>不可变</strong>的，频繁修改必须用 <code>StringBuilder</code>。</p>
<h4 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 (Array)"></a>数组 (Array)</h4><p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 声明与初始化</span><br><span class="line">int[] arr = new int[10];           // 默认初始化为0</span><br><span class="line">int[] nums = &#123;1, 2, 3&#125;;            // 直接赋值</span><br><span class="line">int len = arr.length;              // 注意：没有括号()</span><br><span class="line"></span><br><span class="line">// 排序 (Dual-Pivot Quicksort)</span><br><span class="line">Arrays.sort(arr);                  // O(NlogN)</span><br><span class="line"></span><br><span class="line">// 填充</span><br><span class="line">Arrays.fill(arr, -1);              // 将数组全部初始化为 -1</span><br><span class="line"></span><br><span class="line">// 转列表 (面试常考)</span><br><span class="line">// 注意：如果是 int[] 这种基本类型数组，Arrays.asList() 会出问题，建议手动循环或用流</span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">for (int num : arr) list.add(num); </span><br></pre></td></tr></table></figure>

<h4 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串 (String)"></a>字符串 (String)</h4><p><em>面试坑点：不要在循环里用 <code>+</code> 拼接字符串，性能极差。</em></p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;Hello World&quot;;</span><br><span class="line"></span><br><span class="line">// 获取信息</span><br><span class="line">char c = s.charAt(2);              // 获取第2个字符</span><br><span class="line">int len = s.length();              // 注意：这里有括号()</span><br><span class="line">int idx = s.indexOf(&quot;World&quot;);      // 查找子串位置，找不到返回 -1</span><br><span class="line"></span><br><span class="line">// 转换</span><br><span class="line">char[] chars = s.toCharArray();    // 转成字符数组（很常用，因为String不能直接改）</span><br><span class="line">String sub = s.substring(1, 4);    // 截取索引 1 到 3 的子串 (左闭右开 [1, 4))</span><br><span class="line">String[] parts = s.split(&quot; &quot;);     // 按空格分割</span><br><span class="line"></span><br><span class="line">// StringBuilder (修改字符串必用)</span><br><span class="line">StringBuilder sb = new StringBuilder();</span><br><span class="line">sb.append(&quot;a&quot;);</span><br><span class="line">sb.append(10);</span><br><span class="line">sb.reverse();                      // 反转字符串 (解决回文题神器)</span><br><span class="line">String res = sb.toString();        // 变回 String</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-动态列表-ArrayList"><a href="#2-动态列表-ArrayList" class="headerlink" title="2. 动态列表 (ArrayList)"></a>2. 动态列表 (ArrayList)</h3><p>比数组更灵活，面试中 90% 的情况用它代替数组。</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 推荐使用接口 List 接收</span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); </span><br><span class="line"></span><br><span class="line">// 增删改查</span><br><span class="line">list.add(10);                      // 加到末尾</span><br><span class="line">list.add(0, 5);                    // 插到开头 (效率低，O(N))</span><br><span class="line">int val = list.get(2);             // 获取索引2的元素</span><br><span class="line">list.set(2, 99);                   // 修改索引2的值为99</span><br><span class="line">list.remove(list.size() - 1);      // 删除最后一个元素</span><br><span class="line"></span><br><span class="line">// 常用工具</span><br><span class="line">int size = list.size();</span><br><span class="line">boolean hasVal = list.contains(10); // O(N) 线性查找</span><br><span class="line">Collections.sort(list);            // 排序 (TimSort)</span><br><span class="line">Collections.reverse(list);         // 反转</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-哈希表-HashMap-HashSet"><a href="#3-哈希表-HashMap-HashSet" class="headerlink" title="3. 哈希表 (HashMap &#x2F; HashSet)"></a>3. 哈希表 (HashMap &#x2F; HashSet)</h3><p><strong>刷题神器</strong>，用来降低时间复杂度（通常将 O(N^2) 降为 O(N)）。</p>
<h4 id="HashMap-键值对"><a href="#HashMap-键值对" class="headerlink" title="HashMap (键值对)"></a>HashMap (键值对)</h4><p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 基础操作</span><br><span class="line">map.put(&quot;apple&quot;, 1);</span><br><span class="line">int val = map.get(&quot;apple&quot;);</span><br><span class="line">boolean hasKey = map.containsKey(&quot;apple&quot;); // O(1)</span><br><span class="line"></span><br><span class="line">// ★ 高频技巧：统计频率 (Word Count)</span><br><span class="line">// 如果 key 存在则 +1，不存在则设为 0 再 +1</span><br><span class="line">map.put(key, map.getOrDefault(key, 0) + 1);</span><br><span class="line"></span><br><span class="line">// 遍历 (面试尽量用 entrySet，效率最高)</span><br><span class="line">for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    String k = entry.getKey();</span><br><span class="line">    Integer v = entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HashSet-去重集合"><a href="#HashSet-去重集合" class="headerlink" title="HashSet (去重集合)"></a>HashSet (去重集合)</h4><p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">set.add(1);</span><br><span class="line">boolean exists = set.contains(1);  // O(1)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-栈与队列-Stack-Queue"><a href="#4-栈与队列-Stack-Queue" class="headerlink" title="4. 栈与队列 (Stack &amp; Queue)"></a>4. 栈与队列 (Stack &amp; Queue)</h3><p><strong>重要修正：</strong> 永远不要用 <code>Stack</code> 类（它是 Java 1.0 的遗留类，带锁，性能差）。<strong>请统一使用 <code>Deque</code> (双端队列) 接口。</strong></p>
<h4 id="栈-Last-In-First-Out"><a href="#栈-Last-In-First-Out" class="headerlink" title="栈 (Last-In-First-Out)"></a>栈 (Last-In-First-Out)</h4><p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 使用 ArrayDeque 实现栈</span><br><span class="line">Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">stack.push(1);      // 压栈 (等同于 addFirst)</span><br><span class="line">int top = stack.pop();    // 弹栈 (等同于 removeFirst)，栈空会抛异常</span><br><span class="line">int peek = stack.peek();  //以此查看栈顶元素但不删除</span><br><span class="line">boolean isEmpty = stack.isEmpty();</span><br></pre></td></tr></table></figure>

<h4 id="队列-First-In-First-Out"><a href="#队列-First-In-First-Out" class="headerlink" title="队列 (First-In-First-Out)"></a>队列 (First-In-First-Out)</h4><p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 使用 ArrayDeque 或 LinkedList 实现队列</span><br><span class="line">Queue&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;(); </span><br><span class="line">// 或者 Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); (如果需要中间插入)</span><br><span class="line"></span><br><span class="line">queue.offer(1);     // 入队 (推荐用 offer 而不是 add，满了返回 false 不抛异常)</span><br><span class="line">int head = queue.poll();  // 出队 (推荐用 poll 而不是 remove，空了返回 null)</span><br><span class="line">int peek = queue.peek();  // 查看队头</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-优先队列-PriorityQueue-Heap"><a href="#5-优先队列-PriorityQueue-Heap" class="headerlink" title="5. 优先队列 (PriorityQueue &#x2F; Heap)"></a>5. 优先队列 (PriorityQueue &#x2F; Heap)</h3><p>用于解决 <strong>Top K 问题</strong> 或 <strong>第 K 大&#x2F;小元素</strong>。底层是二叉堆。</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 默认是：小顶堆 (Min Heap)，队头是最小值</span><br><span class="line">PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// ★ 面试必背：大顶堆 (Max Heap) 写法</span><br><span class="line">// 使用 Lambda 表达式自定义比较器：(b - a) 表示降序</span><br><span class="line">PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line"></span><br><span class="line">// 操作</span><br><span class="line">maxHeap.offer(10);</span><br><span class="line">maxHeap.offer(5);</span><br><span class="line">int max = maxHeap.poll(); // 弹出 10</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-数学与数字处理"><a href="#6-数学与数字处理" class="headerlink" title="6. 数学与数字处理"></a>6. 数学与数字处理</h3><p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 比较大小</span><br><span class="line">Math.max(a, b);</span><br><span class="line">Math.min(a, b);</span><br><span class="line"></span><br><span class="line">// 绝对值</span><br><span class="line">Math.abs(-10);</span><br><span class="line"></span><br><span class="line">// ★ 边界值 (防止溢出常用)</span><br><span class="line">int maxInt = Integer.MAX_VALUE; // 2^31 - 1</span><br><span class="line">int minInt = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">// 字符转数字</span><br><span class="line">int digit = &#x27;5&#x27; - &#x27;0&#x27;; // 结果是整数 5</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="7-刷题-面试中的注意事项"><a href="#7-刷题-面试中的注意事项" class="headerlink" title="7. 刷题&#x2F;面试中的注意事项"></a>7. 刷题&#x2F;面试中的注意事项</h3><ol>
<li><p>自动拆装箱 (Autoboxing) 的坑：</p>
<p> 在 Integer 和 int 之间比较时，特别小心 null。</p>
<p> Java</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer a = null;</span><br><span class="line">// if (a == 1) ... // 抛出 NullPointerException</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象比较：</p>
<p> 比较对象（包括 String, Integer 等包装类）的值是否相等，永远用 .equals()，不要用 &#x3D;&#x3D;。</p>
<p> 例外：LeetCode 中 Integer 缓存池 (-128 到 127) 虽用 &#x3D;&#x3D; 有效，但面试写 &#x3D;&#x3D; 会被认为基础不牢。</p>
</li>
<li><p>大数处理：</p>
<p> 如果题目涉及超过 long 范围的数字（如大数相加），需使用 BigInteger 或直接用字符串模拟。</p>
</li>
</ol>
<hr>
<h3 id="总结-你的下一步"><a href="#总结-你的下一步" class="headerlink" title="总结 &amp; 你的下一步"></a>总结 &amp; 你的下一步</h3><p>建议你把这篇内容<strong>收藏</strong>或<strong>复制到你的笔记软件</strong>里。</p>
<p>下一步实战建议：</p>
<p>为了让你快速上手，你想让我给你出一道最经典的 Java 入门算法题（比如“有效的括号”），并用上面提到的 Deque 栈结构写一个标准范例给你看吗？这样你能直接看到这些 API 是如何组合使用的。</p>
</article><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/algorithm_cover.webp" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/fed01c2.html" title="Spring 过滤器"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/Spring%E8%BF%87%E6%BB%A4%E5%99%A8.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Spring 过滤器</div></div><div class="info-2"><div class="info-item-1">Filter 和 InterceptorFilter 过滤器 Servlet 容器维度的，拦截 Servlet 的请求。 通过 Filter 接口实现的  Servlet 容器： Tomcat、Jetty。遵循 Java Servlet 规范，通常包括 HTTP 服务器，处理 web 请求和响应。 Interceptor 拦截器 Spring 容器维度的，对 Spring MVC 的请求进行拦截。 通过实现 HandlerInterceptor 接口实现的，并通过 Spring 的配置进行注册。  PS：Spring 框架嵌入到 Servlet 容器中，利用 spring 容器管理应用程序中的其他组件:  Spring Beans： 在 Spring 框架中，你可以定义和配置各种 Bean，包括业务逻辑组件、数据访问组件、服务等。这些 Bean 的生命周期、依赖关系等都由 Spring 容器管理。 Service 层和业务逻辑： 你可以使用 Spring 来管理业务逻辑层的组件，使其成为 Spring 容器管理的 Bean。这些业务逻辑组件通常包括服务层的实现，处理业务逻辑、事务...</div></div></div></a><a class="pagination-related" href="/posts/356a30bc.html" title="MySQL 日志系统"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/MySQL_Log.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">MySQL 日志系统</div></div><div class="info-2"><div class="info-item-1">Redo Log 这张图被一条中间的虚线分为左右两部分，代表了计算机系统中两种截然不同的存储介质属性。 1. 左侧区域：IN-MEMORY (内存区域) - Volatile (易失性) 特点：  速度极快： CPU 对内存的读写速度远远高于磁盘。为了高性能，数据库必须尽可能在内存中处理数据。 易失性 (Volatile)： 这是最大的弱点。一旦断电、系统崩溃或进程被强制终止，内存中的所有数据瞬间消失。图中的气泡对话框形象地说明了这一点：“Fast access, but data lost on power failure.”（访问快，但断电丢数据）。   关键组件：  BUFFER POOL (缓冲池)： 这是 InnoDB 在内存中最大的保留区域。它缓存了从磁盘读取的数据页 (Data Pages)。 当我们要修改数据时，不是直接去改磁盘文件，而是先在 Buffer Pool 中找到对应的数据页进行修改。 Dirty Page (脏页)： 图中高亮的橙色方块。当一个数据页在内存中被修改了，但还没有写回到磁盘的数据文件中时，它就和磁盘上的版本不一致了，我们称之为“脏页”。  ...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Supremes</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Supremes"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%B7%E9%A2%98%E6%96%B9%E6%A1%88"><span class="toc-text">刷题方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81-%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98%EF%BC%9A%E9%80%89%E4%BB%80%E4%B9%88%E8%AF%AD%E8%A8%80%EF%BC%9F"><span class="toc-text">一、 核心问题：选什么语言？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-%E6%9C%80%E4%BD%B3%E5%88%B7%E9%A2%98%E8%B7%AF%E7%BA%BF%E5%9B%BE-%E5%88%86%E9%98%B6%E6%AE%B5%E6%89%A7%E8%A1%8C"><span class="toc-text">二、 最佳刷题路线图 (分阶段执行)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%A4%AF%E5%AE%9E%E5%9C%B0%E5%9F%BA-2-3-%E5%91%A8"><span class="toc-text">第一阶段：夯实地基 (2-3 周)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%EF%BC%9A%E4%B8%93%E9%A2%98%E7%AA%81%E7%A0%B4-1-2-%E4%B8%AA%E6%9C%88"><span class="toc-text">第二阶段：专题突破 (1-2 个月)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%EF%BC%9A%E9%AB%98%E9%A2%91%E5%86%B2%E5%88%BA-%E9%9D%A2%E8%AF%95%E5%89%8D-1-%E4%B8%AA%E6%9C%88"><span class="toc-text">第三阶段：高频冲刺 (面试前 1 个月)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81-%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97-%E5%88%B7%E9%A2%98%E5%BF%83%E6%B3%95"><span class="toc-text">三、 避坑指南 &amp; 刷题心法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E2%80%9C%E4%BA%94%E5%88%86%E9%92%9F%E6%B3%95%E5%88%99%E2%80%9D"><span class="toc-text">1. “五分钟法则”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%90%86%E8%A7%A3-%E8%AE%B0%E5%BF%86-%E4%B8%8D%E8%A6%81%E6%AD%BB%E8%AE%B0%E4%BB%A3%E7%A0%81"><span class="toc-text">2. 理解 &gt; 记忆 (不要死记代码)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%A9%E7%94%A8-Java-%E7%89%B9%E6%80%A7%E2%80%9C%E5%8F%96%E5%B7%A7%E2%80%9D"><span class="toc-text">3. 利用 Java 特性“取巧”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%9D%9A%E6%8C%81%E2%80%9C%E4%B8%89%E9%81%8D%E5%88%B7%E9%A2%98%E6%B3%95%E2%80%9D"><span class="toc-text">4. 坚持“三遍刷题法”</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81-Java-%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%BF%85%E4%BC%9A%E7%9A%84%E2%80%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%A0%E5%B0%84%E2%80%9D"><span class="toc-text">四、 Java 后台面试必会的“数据结构映射”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8-API-%E9%80%9F%E6%9F%A5%E8%A1%A8"><span class="toc-text">Java 刷题常用 API 速查表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2-Array-String"><span class="toc-text">1. 数组与字符串 (Array &amp; String)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-Array"><span class="toc-text">数组 (Array)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-String"><span class="toc-text">字符串 (String)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8A%A8%E6%80%81%E5%88%97%E8%A1%A8-ArrayList"><span class="toc-text">2. 动态列表 (ArrayList)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%93%88%E5%B8%8C%E8%A1%A8-HashMap-HashSet"><span class="toc-text">3. 哈希表 (HashMap &#x2F; HashSet)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="toc-text">HashMap (键值对)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet-%E5%8E%BB%E9%87%8D%E9%9B%86%E5%90%88"><span class="toc-text">HashSet (去重集合)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97-Stack-Queue"><span class="toc-text">4. 栈与队列 (Stack &amp; Queue)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88-Last-In-First-Out"><span class="toc-text">栈 (Last-In-First-Out)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97-First-In-First-Out"><span class="toc-text">队列 (First-In-First-Out)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-PriorityQueue-Heap"><span class="toc-text">5. 优先队列 (PriorityQueue &#x2F; Heap)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%95%B0%E5%AD%A6%E4%B8%8E%E6%95%B0%E5%AD%97%E5%A4%84%E7%90%86"><span class="toc-text">6. 数学与数字处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%88%B7%E9%A2%98-%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">7. 刷题&#x2F;面试中的注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-%E4%BD%A0%E7%9A%84%E4%B8%8B%E4%B8%80%E6%AD%A5"><span class="toc-text">总结 &amp; 你的下一步</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/5363d109.html" title="Java"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/JAVA8.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java"/></a><div class="content"><a class="title" href="/posts/5363d109.html" title="Java">Java</a><time datetime="2025-12-04T21:06:42.000Z" title="发表于 2025-12-04 21:06 21:06:42">2025-12-04 21:06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/eb9166f8.html" title="JUC并发编程"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/JUC.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC并发编程"/></a><div class="content"><a class="title" href="/posts/eb9166f8.html" title="JUC并发编程">JUC并发编程</a><time datetime="2025-12-04T21:00:06.000Z" title="发表于 2025-12-04 21:00 21:00:06">2025-12-04 21:00</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/750d7523.html" title="Spring Cloud"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/SpringCloud.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Cloud"/></a><div class="content"><a class="title" href="/posts/750d7523.html" title="Spring Cloud">Spring Cloud</a><time datetime="2025-12-04T20:54:30.000Z" title="发表于 2025-12-04 20:54 20:54:30">2025-12-04 20:54</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2d0b435f.html" title="Spring MVC"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/SpringMVC.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring MVC"/></a><div class="content"><a class="title" href="/posts/2d0b435f.html" title="Spring MVC">Spring MVC</a><time datetime="2025-12-04T20:51:26.000Z" title="发表于 2025-12-04 20:51 20:51:26">2025-12-04 20:51</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/fed01c2.html" title="Spring 过滤器"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/Spring%E8%BF%87%E6%BB%A4%E5%99%A8.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring 过滤器"/></a><div class="content"><a class="title" href="/posts/fed01c2.html" title="Spring 过滤器">Spring 过滤器</a><time datetime="2025-12-03T22:37:18.000Z" title="发表于 2025-12-03 22:37 22:37:18">2025-12-03 22:37</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Supremes</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="/"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章标题和内容..." type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.2"></script></div></div></body></html>
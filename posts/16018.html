<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis 学习笔记 | Supremes</title><meta name="author" content="Supremes"><meta name="copyright" content="Supremes"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基础数据结构SDS12345struct sdshdr &#123;    int len; &#x2F;&#x2F; buf中已使用的字节数    int free; &#x2F;&#x2F; buf中未使用的字节数    char buf[];&#125;  链表 包含头尾节点，head tail，以及链表长度计数器len 无环 多态：链表节点使用void*来保存节点值，可以支持各种不同类型的值  字典属于k-v结构的映射表。  字">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 学习笔记">
<meta property="og:url" content="https://supremes.github.io/posts/16018.html">
<meta property="og:site_name" content="Supremes">
<meta property="og:description" content="基础数据结构SDS12345struct sdshdr &#123;    int len; &#x2F;&#x2F; buf中已使用的字节数    int free; &#x2F;&#x2F; buf中未使用的字节数    char buf[];&#125;  链表 包含头尾节点，head tail，以及链表长度计数器len 无环 多态：链表节点使用void*来保存节点值，可以支持各种不同类型的值  字典属于k-v结构的映射表。  字">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/Redis.webp">
<meta property="article:published_time" content="2025-11-29T08:56:10.000Z">
<meta property="article:modified_time" content="2025-12-04T13:11:56.942Z">
<meta property="article:author" content="Supremes">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/Redis.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Redis 学习笔记",
  "url": "https://supremes.github.io/posts/16018.html",
  "image": "https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/Redis.webp",
  "datePublished": "2025-11-29T08:56:10.000Z",
  "dateModified": "2025-12-04T13:11:56.942Z",
  "author": [
    {
      "@type": "Person",
      "name": "Supremes",
      "url": "https://supremes.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/favicon/favicon.ico"><link rel="canonical" href="https://supremes.github.io/posts/16018.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":10},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis 学习笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Spring/"><i class="fa-fw fas fa-leaf"></i><span> Spring</span></a></li><li><a class="site-page child" href="/categories/Interview/"><i class="fa-fw fas fa-book"></i><span> 面试</span></a></li><li><a class="site-page child" href="/categories/database/"><i class="fa-fw fas fa-database"></i><span> 数据库</span></a></li><li><a class="site-page child" href="/categories/algorithm/"><i class="fa-fw fas fa-code"></i><span> 算法</span></a></li><li><a class="site-page child" href="/categories/security/"><i class="fa-fw fas fa-shield-alt"></i><span> 网络安全</span></a></li><li><a class="site-page child" href="/categories/message-queue/"><i class="fa-fw fas fa-envelope"></i><span> 消息队列</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/about_me"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/about/my_notes"><i class="fa-fw fas fa-note-sticky"></i><span> 备忘录</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/Redis.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Supremes</span></a><a class="nav-page-title" href="/"><span class="site-name">Redis 学习笔记</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Spring/"><i class="fa-fw fas fa-leaf"></i><span> Spring</span></a></li><li><a class="site-page child" href="/categories/Interview/"><i class="fa-fw fas fa-book"></i><span> 面试</span></a></li><li><a class="site-page child" href="/categories/database/"><i class="fa-fw fas fa-database"></i><span> 数据库</span></a></li><li><a class="site-page child" href="/categories/algorithm/"><i class="fa-fw fas fa-code"></i><span> 算法</span></a></li><li><a class="site-page child" href="/categories/security/"><i class="fa-fw fas fa-shield-alt"></i><span> 网络安全</span></a></li><li><a class="site-page child" href="/categories/message-queue/"><i class="fa-fw fas fa-envelope"></i><span> 消息队列</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/about_me"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/about/my_notes"><i class="fa-fw fas fa-note-sticky"></i><span> 备忘录</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Redis 学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-11-29T08:56:10.000Z" title="发表于 2025-11-29 08:56 08:56:10">2025-11-29 08:56</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-04T13:11:56.942Z" title="更新于 2025-12-04 13:11 13:11:56">2025-12-04 13:11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/database/">数据库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h2><h3 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">    int len; // buf中已使用的字节数</span><br><span class="line">    int free; // buf中未使用的字节数</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ol>
<li>包含头尾节点，head tail，以及链表长度计数器len</li>
<li>无环</li>
<li>多态：链表节点使用void*来保存节点值，可以支持各种不同类型的值</li>
</ol>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>属于k-v结构的映射表。</p>
<ol>
<li>字典由两个哈希表构成，当字典处于redhash状态，ht[1]才有数据，当rehash完成之后，数据会全部复制到ht[0]</li>
<li>哈希表使用链地址法来解决冲突</li>
<li>采用渐进式rehash，并不是一次性，集中式完成，而是分多次、渐进式完成。rehash会与增删改等操作一起进行：</li>
</ol>
<h3 id="渐进式hash总结："><a href="#渐进式hash总结：" class="headerlink" title="渐进式hash总结："></a><strong>渐进式hash总结：</strong></h3><p>在扩容和收缩的时候，如果哈希字典中有很多元素，一次性将这些键全部rehash到ht[1]的话，可能会导致服务器在一段时间内停止服务。所以，采用渐进式rehash的方式，详细步骤如下：</p>
<ol>
<li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表</li>
<li>将rehashindex的值设置为0，表示rehash工作正式开始</li>
<li>在rehash期间，每次对字典执行增删改查操作是，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashindex索引上的所有键值对rehash到ht[1]，当rehash工作完成以后，rehashindex的值+1</li>
<li>随着字典操作的不断执行，最终会在某一时间段上ht[0]的所有键值对都会被rehash到ht[1]，这时将rehashindex的值设置为-1，表示rehash操作结束</li>
</ol>
<p><strong>渐进式rehash采用的是一种分而治之的方式，将rehash的操作分摊在每一个的访问中，避免集中式rehash而带来的庞大计算量。</strong></p>
<p><strong>需要注意的是在渐进式rehash的过程，如果有增删改查操作时，如果<strong><strong>index</strong></strong>大于**<strong>rehashindex</strong></strong>，访问<strong><strong>ht[0]</strong></strong>，否则访问**<strong>ht[1]。</strong></p>
<h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><ul>
<li>是一种有序的数据结构，在每个节点中维持多个指向其他的节点指针，通过维持索引层，从而达到快速访问的目的。</li>
<li>一定程度来讲，跳表是简化版的红黑树，平均复杂度为logn，差别是空间复杂度会</li>
</ul>
<p>应用：有序集合、集群节点中用作内部数据结构</p>
<h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><p>整数集合是集合键（set）的实现之一，当集合都是整数，且数目不多时，会使用整数集合作为底层的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset &#123;</span><br><span class="line">    uint32_t encoding;	// 表明了整数集合的类型，如int16 int32 int64</span><br><span class="line">    uint32_t length;</span><br><span class="line">    int8_t contents[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：当新增元素超过元素的可表示范围，会将已存储元素进行升级（比如原来是uint32，但是新增元素是uint64,，会把已存储元素都升级为uint64）。优势：</p>
<ol>
<li>提供灵活性</li>
<li>节约内存</li>
</ol>
<h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>按照元素占用大小进行设计的数据结构，每个节点会有一个length字段，通过其可以计算出下一个节点的位置。不同于数组，这么做可以节省内存</p>
<p>应用：列表和哈希，都是其数据量少，且数据占用较小的时候，会使用该数据结构，不然就是链表和字典了。</p>
<h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><p>Redis是key-value数据库，key的类型只能是String，但是value的数据类型就比较丰富了，主要包括五种：</p>
<h3 id="String："><a href="#String：" class="headerlink" title="String："></a>String：</h3><ol>
<li>string类型是二进制安全的</li>
<li>一个键最大能存储512MB的数据，底层是简单动态字符串（SDS）：内部有个函数checkStringLength会对字符串进行校验，默认就是512MB，可以在配置文件中修改这个值</li>
</ol>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>是一个键值(key&#x3D;&gt;value)对集合。 Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。底层使用压缩列表和字典</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>底层使用压缩列表和链表实现</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>底层使整数集合和字典实现，key不允许重复</p>
<h3 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h3><p>有序集合，不允许重复。相对于set，支持按照score排序，key不允许重复，但是score允许重复，底层实现使用到了压缩列表和跳表</p>
<h2 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h2><p>在redis集群内部，采用slot槽位的逻辑管理方式， 集群内部共有16384(2的14次方)个Slot，集群内每个Redis Instance负责其中一部分的Slot的读写。一个Key到底属于哪个Slot，由分片算法：</p>
<p>crc16(key) % 16384</p>
<p>决定。也正是通过此分片算法，将不同的key以相对均匀的方式分配到不同的slot上。</p>
<h2 id="watch：当执行多键值事务操作时，Redis不仅要求这些键值需要落在同一个Redis实例上，还要求落在同一个slot上。"><a href="#watch：当执行多键值事务操作时，Redis不仅要求这些键值需要落在同一个Redis实例上，还要求落在同一个slot上。" class="headerlink" title="watch：当执行多键值事务操作时，Redis不仅要求这些键值需要落在同一个Redis实例上，还要求落在同一个slot上。"></a>watch：当执行多键值事务操作时，Redis不仅要求这些键值需要落在同一个Redis实例上，还要求落在同一个slot上。</h2><p>官方介绍MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令，事务可以一次执行多个命令，但是必须满足2个条件：</p>
<p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。<br>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。执行和是否成功是2个概念，并不是一个失败报错等，其他就失败。redis对事务是部分支持。如果最开始语法等就有提交错误，就相当于java的编译器都过不了，那么肯定全部不执行。如果在执行过程中报错，已经全部执行了，但是谁报错找谁，其他正常执行放行。各取所需！这里的事务并不是要么全部成功，要么全部失败，全部执行和全部成功（或者都失败）是2个概念。</p>
<h2 id="hashtag"><a href="#hashtag" class="headerlink" title="hashtag"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kismetv/p/9853040.html#t54">hashtag</a></h2><p>Hash Tag原理是：当一个key包含 {} 的时候，不对整个key做hash，而仅对 {}包括的字符串做hash。</p>
<p>Hash Tag可以让不同的key拥有相同的hash值，从而分配在同一个槽里；这样针对不同key的批量操作(mget&#x2F;mset等)，以及事务、Lua脚本等都可以支持。不过Hash Tag可能会带来数据分配不均的问题，这时需要：(1)调整不同节点中槽的数量，使数据分布尽量均匀；(2)避免对热点数据使用Hash Tag，导致请求分布不均。</p>
<h2 id="bigkey"><a href="#bigkey" class="headerlink" title="bigkey"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/huxianbo0807/article/details/102912172">bigkey</a></h2><ul>
<li>涉及到bigkey的操作，网卡会成为瓶颈</li>
<li>若需要删除bigkey，直接del，被操作的实例可能会直接卡死</li>
<li>业务上对bigkey取余，将数据分散，避免生成bigkey</li>
</ul>
<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><ol>
<li>一台redis服务的数据，复制到多台redis服务器。前者称为主节点，后者为从节点</li>
<li>数据的复制是单向的，只能从主节点复制到从节点</li>
</ol>
<ul>
<li>作用：</li>
</ul>
<ol>
<li>数据冗余：实现了数据的热备份，是持久化之外的数据冗余方式</li>
<li>故障恢复：主节点失效，丛节点提供服务</li>
<li>负载均衡：实现读写分离，主节点写，丛节点读</li>
<li>高可用的基础：主从复制是哨兵和集群模式能够实施的基础</li>
</ol>
<ul>
<li>数据同步：</li>
</ul>
<ol>
<li><strong>主从节点连接建立</strong>后，便开始数据同步。</li>
<li>根据<strong>主从节点当前状态</strong>，分为全量和部分复制</li>
<li>具体执行方式：从节点朝主节点发送psync命令，开始同步</li>
</ol>
<ul>
<li>命令传播：<br>  主从数据同步完成后，主节点将自己执行的写命令发送给丛节点（该过程是异步的），保证数据的一致性。</li>
</ul>
<h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><ol>
<li>能够自动完成故障发现和转移，从而实现高可用</li>
<li>由一组哨兵节点和一组（或多组）主从复制节点组成</li>
</ol>
<ul>
<li>心跳机制</li>
<li>故障转移</li>
</ul>
<ol>
<li>每个 Sentinel 都会定时进行心跳检查，当发现主节点出现心跳检测超时的情况时，此时认为该主节点已经不可用，这种判定称为<strong>主观下线</strong>。</li>
<li>哨兵节点开始投票，当<strong>超过半数</strong>认为该主节点故障，会将其下线：基于raft算法，选取一个哨兵节点来执行该过程</li>
</ol>
<ul>
<li>选取一个从节点作为主节点，将其他从节点和该节点绑定</li>
<li>原来的主节点更新为从节点，对其监控，等恢复后，命令其去复制新的主节点</li>
</ul>
<h3 id="cluster集群"><a href="#cluster集群" class="headerlink" title="cluster集群"></a>cluster集群</h3><ol>
<li>由多个主从复制的结构组成</li>
<li>每个主从复制的结构看做一个节点</li>
</ol>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>优势：</p>
<ol>
<li>RDB 是一个非常紧凑（compact）的二进制文件，体积小，因此在传输速度上比较快，因此适合灾难恢复。</li>
<li>数据恢复速度比aof快</li>
</ol>
<p>劣势：</p>
<ol>
<li>rdb出现故障丢的数据会比aof多。你通常会每隔5分钟或者更久做一次完整的保存,万一在 Redis 意外宕机,你可能会丢失几分钟的数据。</li>
<li>rdb需要fork子进程来保存数据到硬盘，当数据集比较大时， fork比较耗时，从而导致redis主线程在一些毫秒级别内无法响应客户端</li>
</ol>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>优势：</p>
<ol>
<li>数据更完整，秒级丢失（无 fsync、每秒 fsync 、每次写的时候 fsync ）</li>
<li>兼容性高，是基于redis通讯协议而形成的命令追加方式，无论何种版本的redis都兼容，</li>
<li>aof文件是明文的，可阅读性较好。</li>
</ol>
<p>劣势：</p>
<ol>
<li>数据文件大，即使有重写机制（合并命令、删减无用命令），但是同样量级还是比rdb占用大</li>
<li>数据恢复慢</li>
<li>aof更吃性能（需要频繁同步命令，虽然会先写到内存中，再同步到磁盘里）</li>
</ol>
<h3 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h3><p>混合持久化结合了RDB持久化 和 AOF 持久化的优点, 由于绝大部分都是RDB格式，加载速度快，同时结合AOF，增量的数据以AOF方式保存了，数据更少的丢失。</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="redis分布式锁"><a href="#redis分布式锁" class="headerlink" title="redis分布式锁"></a>redis分布式锁</h3><p>redis实现分布式锁常见的有以很多，官方推荐下面的这种实现（也是我们目前的方式）</p>
<p>set命令加锁，lua脚本释放锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value NX PX milliseconds</span><br></pre></td></tr></table></figure>

<ul>
<li>key: 资源的key,标识一种资源。</li>
<li>value: 此值必须在所有进程和所有获取锁的请求中都是唯一的。</li>
<li>NX: 该命令仅在key不存在时才设置。</li>
<li>PX <em>milliseconds</em>: 过期时间,单位为毫秒。</li>
</ul>
<p>这里的value,设置为唯一值，主要是为了释放锁，自己只能释放自己加的锁。注意在某些场景下，也可以不释放锁，因为本身设置了有效期。</p>
<p>释放锁一般是通过执行下面的lua脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then</span><br><span class="line">    return redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h4 id="存在的问题："><a href="#存在的问题：" class="headerlink" title="存在的问题："></a>存在的问题：</h4><p>对于Redis主节点与从节点之间的数据复制是异步复制的，当客户端发送写请求给master节点的时候，客户端会返回OK（这个时候A已经获得锁），然后同步到各个slave节点中。如果此时master还没来得及同步给slave节点时发生宕机，那么master内存中的数据会丢失（这样可能会导致B也能获得锁）。</p>
<h4 id="redlock"><a href="#redlock" class="headerlink" title="redlock:"></a>redlock:</h4><p>它的基本思路就是为锁准备多个独立的节点，在锁过期时间内只要超过半数获取到锁，就算成功，避免redis主从切换的时候，数据丢失。</p>
<ul>
<li>问题：</li>
</ul>
<ol>
<li>宕机重启后，两个客户端拿到同一把锁</li>
</ol>
<p>假设5个节点是A, B, C, D, E，客户端1在A, B, C上面拿到锁，D, E没有拿到锁，客户端1拿锁成功。 此时，C挂了重启，C上面锁的数据丢失（假设机器断电，数据还没来得及刷盘）。客户端2去取锁，从C, D, E 3个节点拿到锁，A, B没有拿到（还被客户端1持有），客户端2也超过多数派，也会拿到锁</p>
<p>解决方案：延迟重启，等待ttl之后再重启。</p>
<ol start="2">
<li>时钟跳跃：是指系统时间发生了跳跃</li>
</ol>
<p>时钟跳跃可能延迟重启机制失效，时钟跳跃可能导致机器挂了立马重启，从而出现上面的问题。时钟跳跃可能导致客户端拿到锁之后立马失效，跟服务器挂掉类似。基于自动过期机制，依然没有解决长时间的gc pause等问题带来的锁自动失效，从而带来的安全性问题</p>
<h3 id="zookeeper分布式锁"><a href="#zookeeper分布式锁" class="headerlink" title="zookeeper分布式锁"></a>zookeeper分布式锁</h3><ul>
<li><p>使用 ZK 的临时节点和有序节点，每个线程获取锁就是在 ZK 创建一个临时有序的节点，比如在 &#x2F;lock&#x2F; 目录下</p>
</li>
<li><p>创建节点成功后，获取 &#x2F;lock 目录下的所有临时节点，再判断当前线程创建的节点是否是所有的节点的序号最小的节点</p>
</li>
<li><p>如果当前线程创建的节点是所有节点序号最小的节点，则认为获取锁成功</p>
</li>
<li><p>如果当前线程创建的节点不是所有节点序号最小的节点，则对节点序号的前一个节点添加一个事件监听。</p>
</li>
</ul>
<h3 id="redis-zk对比"><a href="#redis-zk对比" class="headerlink" title="redis zk对比"></a>redis zk对比</h3><ul>
<li>Zookeeper的分布式锁是客户端基于创建临时节点实现的，对于排他锁，每个客户端都尝试创建临时节点，但是只有一个客户端能成功创建，创建成功则相当于获取了锁。对于共享锁，则会按照一定的顺序队列创建带序号的临时节点并尝试获取锁（可以有多个客户端获取共享锁）。Redis的分布式锁则是通过创建一个从未创建过的key并设置其过期时间实现的，创建成功则获得了锁，并且客户端会在一定时间内循环获取锁，比较消耗服务器性能。</li>
<li>Zookeeper释放锁时，要么正常执行完业务逻辑后，事务主动释放，要么是检测到与客户端的会话失效后释放。Redis释放锁时，要么正常执行完业务逻辑后，事务主动释放，要么是键超时后释放锁。</li>
<li>对于Redis的主从结构中出现的主服务器宕机情况（单点故障），客户端A已经获取到锁了，但是主服务器还没来得及将键复制到从服务器，并且从服务器晋升为了主服务器，这时客户端B也可以获取锁，锁互斥效果就失效了。可以使用RedLock解决，但是不建议，可以使用Zookeeper。</li>
<li>Redis性能更高。</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/Redis.webp" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/65190.html" title="八股文"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/mianshi.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">八股文</div></div><div class="info-2"><div class="info-item-1">BitMap所谓的Bit-map就是用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。 我们可以用一个unsigned int类型的数组或者向量来表示位图，假设我们定义vector a，则 第i位可表示为a[i&#x2F;32]的i%32位（其中，32*N+r &#x3D; i，r为i%32，也就是i&#x2F;32的余数）。 1234567891011121314151617181920212223242526class Bitmap&#123;    private:    vector&lt;size_t&gt; v;    public:    Bitmap(size_t num) : v((num&gt;&gt;5)+1, 0) &#123;&#125;    //set 1    void set(size_t num)    &#123;        v[num&gt;&gt;5] |= (1&lt;&lt;(num &amp; 31)); // num &amp; 31 equ...</div></div></div></a><a class="pagination-related" href="/posts/4947.html" title="TODO"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/TODO.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">TODO</div></div><div class="info-2"><div class="info-item-1">Pending IssuesFixed  多级目录时，通过目录定位会出问题 目录名一致，但是层级关系不一致，不会被视为同一目录，建议不要这样设置    Obsidian 双链转 hexo 链接 引用hexo-filter-titlebased-link 库，添加配置项解决该问题    Mermaid 代码块渲染失败，需要引用 JS 语法 引用hexo-filter-mermaid-diagrams 库，但是间歇性还是会渲染不出来，推荐还是使用标签插件 (Tag Plugin) 语法    12&#123;% mermaid %&#125;&#123;% endmermaid %&#125;    本地测试经常性报 fontawesome failure  使用隐私模式访问，大概率没问题      图片多大太大，导致加载缓慢的问题。参考: https://gemini.google.com/share/320865e42713   配置图床(github repo: blog-images)，并使用CDN - cdn.jsdelivr.net  加速访问  压缩图片大小     首...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Supremes</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Supremes"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">基础数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SDS"><span class="toc-text">SDS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text">链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E5%85%B8"><span class="toc-text">字典</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%90%E8%BF%9B%E5%BC%8Fhash%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">渐进式hash总结：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E8%A1%A8"><span class="toc-text">跳跃表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88"><span class="toc-text">整数集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8"><span class="toc-text">压缩列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">基础数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String%EF%BC%9A"><span class="toc-text">String：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash"><span class="toc-text">Hash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-text">List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-text">Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sorted-Set"><span class="toc-text">Sorted Set</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#slot"><span class="toc-text">slot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#watch%EF%BC%9A%E5%BD%93%E6%89%A7%E8%A1%8C%E5%A4%9A%E9%94%AE%E5%80%BC%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C%E6%97%B6%EF%BC%8CRedis%E4%B8%8D%E4%BB%85%E8%A6%81%E6%B1%82%E8%BF%99%E4%BA%9B%E9%94%AE%E5%80%BC%E9%9C%80%E8%A6%81%E8%90%BD%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AARedis%E5%AE%9E%E4%BE%8B%E4%B8%8A%EF%BC%8C%E8%BF%98%E8%A6%81%E6%B1%82%E8%90%BD%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AAslot%E4%B8%8A%E3%80%82"><span class="toc-text">watch：当执行多键值事务操作时，Redis不仅要求这些键值需要落在同一个Redis实例上，还要求落在同一个slot上。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashtag"><span class="toc-text">hashtag</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bigkey"><span class="toc-text">bigkey</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-text">高可用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-text">主从复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%A8%E5%85%B5"><span class="toc-text">哨兵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cluster%E9%9B%86%E7%BE%A4"><span class="toc-text">cluster集群</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB"><span class="toc-text">RDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF"><span class="toc-text">AOF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">混合持久化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-text">redis分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">存在的问题：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redlock"><span class="toc-text">redlock:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-text">zookeeper分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-zk%E5%AF%B9%E6%AF%94"><span class="toc-text">redis zk对比</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/5363d109.html" title="Java8"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/JAVA8.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java8"/></a><div class="content"><a class="title" href="/posts/5363d109.html" title="Java8">Java8</a><time datetime="2025-12-04T21:06:42.000Z" title="发表于 2025-12-04 21:06 21:06:42">2025-12-04 21:06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/eb9166f8.html" title="JUC并发编程"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/JUC.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC并发编程"/></a><div class="content"><a class="title" href="/posts/eb9166f8.html" title="JUC并发编程">JUC并发编程</a><time datetime="2025-12-04T21:00:06.000Z" title="发表于 2025-12-04 21:00 21:00:06">2025-12-04 21:00</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/750d7523.html" title="Spring Cloud"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/SpringCloud.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Cloud"/></a><div class="content"><a class="title" href="/posts/750d7523.html" title="Spring Cloud">Spring Cloud</a><time datetime="2025-12-04T20:54:30.000Z" title="发表于 2025-12-04 20:54 20:54:30">2025-12-04 20:54</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2d0b435f.html" title="Spring MVC"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/SpringMVC.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring MVC"/></a><div class="content"><a class="title" href="/posts/2d0b435f.html" title="Spring MVC">Spring MVC</a><time datetime="2025-12-04T20:51:26.000Z" title="发表于 2025-12-04 20:51 20:51:26">2025-12-04 20:51</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/fed01c2.html" title="Spring 过滤器"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/Spring%E8%BF%87%E6%BB%A4%E5%99%A8.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring 过滤器"/></a><div class="content"><a class="title" href="/posts/fed01c2.html" title="Spring 过滤器">Spring 过滤器</a><time datetime="2025-12-03T22:37:18.000Z" title="发表于 2025-12-03 22:37 22:37:18">2025-12-03 22:37</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Supremes</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="/"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章标题和内容..." type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.2"></script></div></div></body></html>
<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Spring AOP 事务失效与底层代理机制深度总结 | Supremes</title><meta name="author" content="Supremes"><meta name="copyright" content="Supremes"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Spring AOP 事务失效与底层代理机制深度总结1. 核心问题：为什么自调用导致事务失效？现象在同一个类中，方法 A 调用方法 B（this.methodB()），即使方法 B 上加了 @Transactional 注解，事务依然不生效。 根本原因Spring AOP 的默认实现基于 代理模式 (Proxy Pattern)。Spring 容器中注入的 Bean 实际上是一个 代理对象 (Pr">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring AOP 事务失效与底层代理机制深度总结">
<meta property="og:url" content="https://supremes.github.io/posts/60441.html">
<meta property="og:site_name" content="Supremes">
<meta property="og:description" content="Spring AOP 事务失效与底层代理机制深度总结1. 核心问题：为什么自调用导致事务失效？现象在同一个类中，方法 A 调用方法 B（this.methodB()），即使方法 B 上加了 @Transactional 注解，事务依然不生效。 根本原因Spring AOP 的默认实现基于 代理模式 (Proxy Pattern)。Spring 容器中注入的 Bean 实际上是一个 代理对象 (Pr">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/AOP-PROXY.webp">
<meta property="article:published_time" content="2025-11-25T20:39:20.000Z">
<meta property="article:modified_time" content="2025-11-25T20:39:20.000Z">
<meta property="article:author" content="Supremes">
<meta property="article:tag" content="AOP">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/AOP-PROXY.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Spring AOP 事务失效与底层代理机制深度总结",
  "url": "https://supremes.github.io/posts/60441.html",
  "image": "https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/AOP-PROXY.webp",
  "datePublished": "2025-11-25T20:39:20.000Z",
  "dateModified": "2025-11-25T20:39:20.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "Supremes",
      "url": "https://supremes.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/favicon/favicon.ico"><link rel="canonical" href="https://supremes.github.io/posts/60441.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":10},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring AOP 事务失效与底层代理机制深度总结',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">52</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Spring/"><i class="fa-fw fas fa-leaf"></i><span> Spring</span></a></li><li><a class="site-page child" href="/tags/Interview/"><i class="fa-fw fas fa-book"></i><span> 面试</span></a></li><li><a class="site-page child" href="/categories/database/"><i class="fa-fw fas fa-database"></i><span> 数据库</span></a></li><li><a class="site-page child" href="/categories/algorithm/"><i class="fa-fw fas fa-code"></i><span> 算法</span></a></li><li><a class="site-page child" href="/categories/security/"><i class="fa-fw fas fa-shield-alt"></i><span> 网络安全</span></a></li><li><a class="site-page child" href="/categories/message-queue/"><i class="fa-fw fas fa-envelope"></i><span> 消息队列</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/about_me"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/about/my_notes"><i class="fa-fw fas fa-note-sticky"></i><span> 备忘录</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/AOP-PROXY.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Supremes</span></a><a class="nav-page-title" href="/"><span class="site-name">Spring AOP 事务失效与底层代理机制深度总结</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Spring/"><i class="fa-fw fas fa-leaf"></i><span> Spring</span></a></li><li><a class="site-page child" href="/tags/Interview/"><i class="fa-fw fas fa-book"></i><span> 面试</span></a></li><li><a class="site-page child" href="/categories/database/"><i class="fa-fw fas fa-database"></i><span> 数据库</span></a></li><li><a class="site-page child" href="/categories/algorithm/"><i class="fa-fw fas fa-code"></i><span> 算法</span></a></li><li><a class="site-page child" href="/categories/security/"><i class="fa-fw fas fa-shield-alt"></i><span> 网络安全</span></a></li><li><a class="site-page child" href="/categories/message-queue/"><i class="fa-fw fas fa-envelope"></i><span> 消息队列</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/about_me"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/about/my_notes"><i class="fa-fw fas fa-note-sticky"></i><span> 备忘录</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Spring AOP 事务失效与底层代理机制深度总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-11-25T20:39:20.000Z" title="发表于 2025-11-25 20:39 20:39:20">2025-11-25 20:39</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-25T20:39:20.000Z" title="更新于 2025-11-25 20:39 20:39:20">2025-11-25 20:39</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Spring/">Spring</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Spring-AOP-事务失效与底层代理机制深度总结"><a href="#Spring-AOP-事务失效与底层代理机制深度总结" class="headerlink" title="Spring AOP 事务失效与底层代理机制深度总结"></a>Spring AOP 事务失效与底层代理机制深度总结</h1><h2 id="1-核心问题：为什么自调用导致事务失效？"><a href="#1-核心问题：为什么自调用导致事务失效？" class="headerlink" title="1. 核心问题：为什么自调用导致事务失效？"></a>1. 核心问题：为什么自调用导致事务失效？</h2><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>在同一个类中，方法 A 调用方法 B（<code>this.methodB()</code>），即使方法 B 上加了 <code>@Transactional</code> 注解，事务依然不生效。</p>
<h3 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h3><p>Spring AOP 的默认实现基于 <strong>代理模式 (Proxy Pattern)</strong>。Spring 容器中注入的 Bean 实际上是一个 <strong>代理对象 (Proxy)</strong>，它持有你编写的 <strong>目标对象 (Target)</strong>。</p>
<ul>
<li><strong>生效路径</strong>：外部调用 $\rightarrow$ Proxy $\rightarrow$ 事务拦截器 (Interceptor) $\rightarrow$ Target。</li>
<li><strong>失效路径</strong>：Target 内部调用 $\rightarrow$ <code>this.methodB()</code> $\rightarrow$ Target。</li>
</ul>
<p>此时，<code>this</code> 指针指向的是<strong>目标对象本身</strong>。代码执行流直接在目标对象内部流转，完全<strong>绕过</strong>了外层的代理对象及其持有的事务拦截器。</p>
<h3 id="形象比喻"><a href="#形象比喻" class="headerlink" title="形象比喻"></a>形象比喻</h3><ul>
<li><strong>Proxy (代理)</strong>：大楼门口的<strong>安检员</strong>。</li>
<li><strong>Target (目标)</strong>：大楼里的<strong>员工</strong>。</li>
<li><strong>外部访问</strong>：访客找员工，必须经过安检（事务生效）。</li>
<li><strong>内部自调用</strong>：员工之间互找，直接在楼里见面，不需要跑出去再过一次安检（事务失效）。</li>
</ul>
<hr>
<h2 id="2-解决方案-按架构师推荐度排序"><a href="#2-解决方案-按架构师推荐度排序" class="headerlink" title="2. 解决方案 (按架构师推荐度排序)"></a>2. 解决方案 (按架构师推荐度排序)</h2><table>
<thead>
<tr>
<th><strong>方案</strong></th>
<th><strong>具体做法</strong></th>
<th><strong>评价</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1. 架构重构 (Refactoring)</strong></td>
<td>将需要事务的方法提取到<strong>独立的 Service</strong> 中，通过 Bean 注入调用。</td>
<td>⭐⭐⭐⭐⭐ (强烈推荐)</td>
<td>符合单一职责原则 (SRP)，代码结构最清晰。</td>
</tr>
<tr>
<td><strong>2. 自我注入 (Self-Injection)</strong></td>
<td>在类中注入自身 (<code>@Lazy</code> 解决循环依赖)，调用 <code>self.methodB()</code>。</td>
<td>⭐⭐⭐ (可用)</td>
<td>业务逻辑紧密耦合，不适合拆分文件时。</td>
</tr>
<tr>
<td><strong>3. AopContext</strong></td>
<td>使用 <code>AopContext.currentProxy()</code> 强转获取当前代理对象。</td>
<td>⭐ (不推荐)</td>
<td>代码侵入性强，与 Spring API 强耦合。</td>
</tr>
<tr>
<td><strong>4. AspectJ</strong></td>
<td>放弃代理模式，使用字节码织入 (Weaving)。</td>
<td>N&#x2F;A (特殊需求)</td>
<td>追求极致性能或必须在 private&#x2F;自调用中生效时。</td>
</tr>
</tbody></table>
<hr>
<h2 id="3-深度辨析：JDK-动态代理-vs-CGLIB"><a href="#3-深度辨析：JDK-动态代理-vs-CGLIB" class="headerlink" title="3. 深度辨析：JDK 动态代理 vs CGLIB"></a>3. 深度辨析：JDK 动态代理 vs CGLIB</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/articles/SpringAOP.webp" alt="SpringAOP"></p>
<h3 id="常见误区"><a href="#常见误区" class="headerlink" title="常见误区"></a>常见误区</h3><blockquote>
<p><strong>误区</strong>：”JDK Proxy 会导致自调用失效，换成 CGLIB 就能解决了。”</p>
<p><strong>真相</strong>：<strong>错误的。</strong> 无论是 JDK Proxy 还是 CGLIB，只要是基于<strong>代理模式</strong>，自调用都会失效。因为它们底层架构都是 <code>Proxy</code> 持有 <code>Target</code>。</p>
</blockquote>
<h3 id="技术对比表"><a href="#技术对比表" class="headerlink" title="技术对比表"></a>技术对比表</h3><table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>JDK 动态代理</strong></th>
<th><strong>CGLIB (Code Generation Library)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>实现机制</strong></td>
<td>基于 <strong>接口 (Interface)</strong></td>
<td>基于 <strong>继承 (Subclass)</strong></td>
</tr>
<tr>
<td><strong>类关系</strong></td>
<td>代理类与目标类是 <strong>兄弟关系</strong></td>
<td>代理类是目标类的 <strong>子类</strong></td>
</tr>
<tr>
<td><strong>核心限制</strong></td>
<td>目标类 <strong>必须实现接口</strong></td>
<td>目标类或方法 <strong>不能是 Final</strong></td>
</tr>
<tr>
<td><strong>调用方式</strong></td>
<td><strong>反射</strong> (<code>Method.invoke</code>)</td>
<td><strong>FastClass 索引</strong> (直接调用)</td>
</tr>
<tr>
<td><strong>自调用支持</strong></td>
<td>❌ 不支持</td>
<td>❌ 不支持</td>
</tr>
<tr>
<td><strong>Spring 默认</strong></td>
<td>旧版本 (有接口时默认)</td>
<td><strong>Spring Boot 2.0+ 默认</strong></td>
</tr>
</tbody></table>
<hr>
<h2 id="4-性能黑科技：CGLIB-的-FastClass-机制"><a href="#4-性能黑科技：CGLIB-的-FastClass-机制" class="headerlink" title="4. 性能黑科技：CGLIB 的 FastClass 机制"></a>4. 性能黑科技：CGLIB 的 FastClass 机制</h2><p>CGLIB 在运行时之所以高效，是因为它通过 <strong>FastClass</strong> 机制规避了 Java 反射 API 的开销。</p>
<h3 id="FastClass-原理"><a href="#FastClass-原理" class="headerlink" title="FastClass 原理"></a>FastClass 原理</h3><p>CGLIB 在生成代理类时，会利用 ASM 字节码技术额外生成一个 <code>FastClass</code>。它相当于把”反射查找”变成了”硬编码的索引跳转”。</p>
<p><strong>伪代码逻辑：</strong></p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// FastClass 就像一个巨大的 switch-case，建立了 方法签名 -&gt; 索引 的映射</span><br><span class="line">public Object invoke(int index, Object target, Object[] args) &#123;</span><br><span class="line">    MyService service = (MyService) target;</span><br><span class="line">    // 直接调用，没有反射的 invoke() 开销</span><br><span class="line">    switch (index) &#123;</span><br><span class="line">        case 1: return service.login(); </span><br><span class="line">        case 2: return service.logout();</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-FastClass"><a href="#总结-FastClass" class="headerlink" title="总结 FastClass"></a>总结 FastClass</h3><ul>
<li><strong>本质</strong>：<strong>空间换时间</strong>。通过生成更多的字节码类，建立索引。</li>
<li><strong>优势</strong>：<strong>运行时 (Runtime)</strong> 调用速度极快，接近原生 Java 方法调用，不仅省去了反射的安全检查，还能享受 JVM 的内联优化。</li>
<li><strong>劣势</strong>：<strong>启动时间</strong>稍慢（需要生成和加载字节码）。</li>
</ul>
<hr>
<h2 id="5-架构师建议-“The-Spring-Way”"><a href="#5-架构师建议-“The-Spring-Way”" class="headerlink" title="5. 架构师建议 (“The Spring Way”)"></a>5. 架构师建议 (“The Spring Way”)</h2><ol>
<li><strong>首选重构</strong>：遇到自调用失效，首先反思类的职责是否过重。将事务逻辑拆分到不同 Service 是最优雅的解法。</li>
<li><strong>拥抱 CGLIB</strong>：在 Spring Boot 2.x&#x2F;3.x 时代，默认使用 CGLIB 是最佳实践（稳定、高效、无需接口），除非你有特殊的 JDK 原生洁癖。</li>
<li><strong>避坑 Final</strong>：使用 Spring 管理的 Bean（尤其是涉及 AOP&#x2F;事务的），<strong>严禁</strong>将类或方法设为 <code>final</code>，否则 CGLIB 无法生成子类代理，会导致启动报错或 AOP 失效。</li>
<li><strong>理解原理</strong>：不要盲目背诵“CGLIB 比 JDK 快”，要理解它是通过“启动时的复杂”换取了“运行时的简单”。</li>
</ol>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Interview/">面试</a><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/AOP/">AOP</a><a class="post-meta__tags" href="/tags/Spring/">Spring</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/AOP-PROXY.webp" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/posts/1562.html" title="Kafka 深度学习笔记"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/KafkaNotes封面.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Kafka 深度学习笔记</div></div><div class="info-2"><div class="info-item-1">📖 简介Apache Kafka 是一个分布式流处理平台,最初由 LinkedIn 开发。早期版本使用 Scala 编写并运行在 JVM 上,后续版本逐渐迁移至 Java 实现。 🔑 核心概念副本机制 Leader Replica（主副本）  负责处理所有客户端的读写请求 维护消息的写入顺序和偏移量等元数据   Follower Replica（从副本）  从 Leader 同步最新数据 提供数据冗余和高可用保障 不对外提供读写服务    持久化机制Kafka 使用高效的日志存储机制来持久化消息：  顺序 I&#x2F;O 追加写入  消息以追加方式顺序写入日志文件 充分利用磁盘顺序读写的高性能特性   Log Segment 分段管理  将日志按照 Log Segment 进行分段 定时清理过期的 Segment 来释放磁盘空间     📚 核心术语   术语 英文 说明    消息 Record Kafka 处理的主要对象   主题 Topic 承载消息的逻辑容器，用于区分不同的业务   分区 Partition 一个有序不变的消息序列，每个主题可以有多个分区   消息...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/750d7523.html" title="Spring Cloud"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/SpringCloud.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-04 20:54</div><div class="info-item-2">Spring Cloud</div></div><div class="info-2"><div class="info-item-1">Spring Cloud 是一个广泛用于构建微服务架构的框架集合，涵盖了服务发现、配置管理、负载均衡、熔断器、API 网关、消息总线等多个方面。以下是一个系统的 Spring Cloud 学习路线，适合初学者循序渐进地掌握其核心内容。  1. 基础准备在学习 Spring Cloud 之前，需要打好以下基础：  Java 基础：熟悉 Java 编程语言，包括面向对象编程、集合框架、异常处理等。 Spring Boot：Spring Cloud 基于 Spring Boot 构建，需掌握 Spring Boot 的核心概念，如自动配置、依赖注入、RESTful API 开发、Spring Data JPA 等。 微服务架构：了解微服务的基本概念、优缺点，以及与传统单体应用的区别。 HTTP 和 REST：掌握 HTTP 协议和 RESTful 服务设计原则。 Maven 或 Gradle：熟悉项目构建工具，学会管理依赖和构建项目。   2. Spring Cloud 核心组件学习Spring Cloud 由多个子项目组成，每个子项目解决微服务架构中的特定问题。以下是核心组件及其推荐...</div></div></div></a><a class="pagination-related" href="/posts/2d0b435f.html" title="Spring MVC"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/SpringMVC.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-04 20:51</div><div class="info-item-2">Spring MVC</div></div><div class="info-2"><div class="info-item-1">SpringMVC 工作原理引言Spring MVC 框架作为 Java Web 应用程序开发中广泛采用的框架，以其分层和松耦合的架构而闻名。这种架构清晰地分离了表示层、持久层和控制层，使得开发人员能够独立地处理各个模块，并将其组合成专业的 Web 应用程序。遵循 MVC 标准开发的 Web 应用程序更易于扩展、更新和管理，因为松耦合的分层结构使得在特定层进行修改变得更加便捷 1。本报告旨在深入探讨 Spring MVC 框架内 HTTP 请求的完整生命周期，从客户端发起请求到最终响应返回，详细阐述其内部的工作原理。 理解模型-视图-控制器（MVC）模式模型-视图-控制器（MVC）是一种广泛应用于软件工程中的架构模式，旨在分离应用程序的不同关注点，从而提高代码的可维护性和可重用性 3。在 MVC 模式中，应用程序被划分为三个核心组件：  模型（Model）： 模型负责封装应用程序的数据和业务逻辑 2。它是应用程序的核心，管理着数据的存储、检索和处理 4。模型独立于用户界面，当模型中的数据发生变化时，它会通知视图进行更新 4。 视图（View）： 视图负责呈现模型中的数据，并将其转...</div></div></div></a><a class="pagination-related" href="/posts/fed01c2.html" title="Spring 过滤器"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/Spring%E8%BF%87%E6%BB%A4%E5%99%A8.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-03 22:37</div><div class="info-item-2">Spring 过滤器</div></div><div class="info-2"><div class="info-item-1">Filter 和 InterceptorFilter 过滤器 Servlet 容器维度的，拦截 Servlet 的请求。 通过 Filter 接口实现的  Servlet 容器： Tomcat、Jetty。遵循 Java Servlet 规范，通常包括 HTTP 服务器，处理 web 请求和响应。 Interceptor 拦截器 Spring 容器维度的，对 Spring MVC 的请求进行拦截。 通过实现 HandlerInterceptor 接口实现的，并通过 Spring 的配置进行注册。  PS：Spring 框架嵌入到 Servlet 容器中，利用 spring 容器管理应用程序中的其他组件:  Spring Beans： 在 Spring 框架中，你可以定义和配置各种 Bean，包括业务逻辑组件、数据访问组件、服务等。这些 Bean 的生命周期、依赖关系等都由 Spring 容器管理。 Service 层和业务逻辑： 你可以使用 Spring 来管理业务逻辑层的组件，使其成为 Spring 容器管理的 Bean。这些业务逻辑组件通常包括服务层的实现，处理业务逻辑、事务...</div></div></div></a><a class="pagination-related" href="/posts/eb9166f8.html" title="JUC并发编程"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/JUC.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-04 21:00</div><div class="info-item-2">JUC并发编程</div></div><div class="info-2"><div class="info-item-1">好的，阅读 JUC（Java Util Concurrent）源码是一项非常棒的学习任务，它能让你深入理解 Java 并发编程的精髓，以及 JVM 和操作系统层面的一些知识。JUC 包是 Java 并发编程的基石，包含了线程池、锁、原子操作、并发集合等核心组件。 下面为你列一个 JUC 源码学习的大纲，并提供一些学习建议：  JUC 源码学习大纲第一阶段：基础知识回顾与工具准备  并发基础理论： 可见性、原子性、有序性： 深入理解这三大特性及其在并发中的重要性。 JMM (Java Memory Model)： 了解 Java 内存模型如何保证并发的正确性。 Happens-Before 原则： 理解它如何定义操作之间的顺序。 锁的原理： 了解悲观锁、乐观锁，以及自旋锁等概念。 AQS (AbstractQueuedSynchronizer) 概述： 对 AQS 有一个初步的认识，它是 JUC 许多高级同步器的基石。 CAS (Compare-And-Swap) 原理： 理解其三步操作和 ABA 问题。   Lombok 与 @SneakyThrows： Lombok 在 JUC...</div></div></div></a><a class="pagination-related" href="/posts/5363d109.html" title="Java"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/JAVA8.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-04 21:06</div><div class="info-item-2">Java</div></div><div class="info-2"><div class="info-item-1">Java 8 新特性Lambda 表达式123456789101112131415private static void testLambda() &#123;    List&lt;String&gt; names = Arrays.asList(&quot;name&quot;, &quot;sex&quot;, &quot;hobby&quot;);    // with method reference -- static method    names.forEach(System.out::println);    names.forEach(name -&gt; System.out.println(name));    // with method reference -- instance method    names.sort(String::compareTo);    names.sort((a, b) -&gt; a.compareTo(b));    // with method reference -- constructor method    ...</div></div></div></a><a class="pagination-related" href="/posts/22172.html" title="Hibernate ORM 框架详解"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/hibernate.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-28 14:00</div><div class="info-item-2">Hibernate ORM 框架详解</div></div><div class="info-2"><div class="info-item-1">HibernateHibernate 是一个用于 Java 环境的开源对象关系映射（ORM）框架，XML 映射文件是 Hibernate 配置实体类和数据库表之间映射关系的重要方式。以下是 Hibernate XML 映射文件中常见标签的介绍： 环境配置在 Spring 框架中使用 Hibernate 作为 ORM 框架时，需要导入以下相关库（依赖项）。以下是基于 Maven 或 Gradle 的依赖配置，具体依赖取决于你使用的 Spring 版本、Hibernate 版本以及是否使用 JPA。 1. 核心 DependenciesHibernate CoreHibernate 的核心库，提供基本的 ORM 功能。  Maven:12345&lt;dependency&gt;    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;    &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;    &lt;version&gt;5.6.15.Final&lt;/version&gt; &lt;...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Supremes</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">52</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Supremes"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-AOP-%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E4%B8%8E%E5%BA%95%E5%B1%82%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E6%80%BB%E7%BB%93"><span class="toc-text">Spring AOP 事务失效与底层代理机制深度总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%87%AA%E8%B0%83%E7%94%A8%E5%AF%BC%E8%87%B4%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="toc-text">1. 核心问题：为什么自调用导致事务失效？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E8%B1%A1"><span class="toc-text">现象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%9C%AC%E5%8E%9F%E5%9B%A0"><span class="toc-text">根本原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%A2%E8%B1%A1%E6%AF%94%E5%96%BB"><span class="toc-text">形象比喻</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E6%8C%89%E6%9E%B6%E6%9E%84%E5%B8%88%E6%8E%A8%E8%8D%90%E5%BA%A6%E6%8E%92%E5%BA%8F"><span class="toc-text">2. 解决方案 (按架构师推荐度排序)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B7%B1%E5%BA%A6%E8%BE%A8%E6%9E%90%EF%BC%9AJDK-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-vs-CGLIB"><span class="toc-text">3. 深度辨析：JDK 动态代理 vs CGLIB</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA"><span class="toc-text">常见误区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="toc-text">技术对比表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%80%A7%E8%83%BD%E9%BB%91%E7%A7%91%E6%8A%80%EF%BC%9ACGLIB-%E7%9A%84-FastClass-%E6%9C%BA%E5%88%B6"><span class="toc-text">4. 性能黑科技：CGLIB 的 FastClass 机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FastClass-%E5%8E%9F%E7%90%86"><span class="toc-text">FastClass 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-FastClass"><span class="toc-text">总结 FastClass</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%9E%B6%E6%9E%84%E5%B8%88%E5%BB%BA%E8%AE%AE-%E2%80%9CThe-Spring-Way%E2%80%9D"><span class="toc-text">5. 架构师建议 (“The Spring Way”)</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/3c3cdb74.html" title="Git 学习笔记"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/GIT.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 学习笔记"/></a><div class="content"><a class="title" href="/posts/3c3cdb74.html" title="Git 学习笔记">Git 学习笔记</a><time datetime="2025-12-06T10:47:14.000Z" title="发表于 2025-12-06 10:47 10:47:14">2025-12-06 10:47</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5363d109.html" title="Java"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/JAVA8.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java"/></a><div class="content"><a class="title" href="/posts/5363d109.html" title="Java">Java</a><time datetime="2025-12-04T21:06:42.000Z" title="发表于 2025-12-04 21:06 21:06:42">2025-12-04 21:06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/eb9166f8.html" title="JUC并发编程"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/JUC.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC并发编程"/></a><div class="content"><a class="title" href="/posts/eb9166f8.html" title="JUC并发编程">JUC并发编程</a><time datetime="2025-12-04T21:00:06.000Z" title="发表于 2025-12-04 21:00 21:00:06">2025-12-04 21:00</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/750d7523.html" title="Spring Cloud"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/SpringCloud.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Cloud"/></a><div class="content"><a class="title" href="/posts/750d7523.html" title="Spring Cloud">Spring Cloud</a><time datetime="2025-12-04T20:54:30.000Z" title="发表于 2025-12-04 20:54 20:54:30">2025-12-04 20:54</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2d0b435f.html" title="Spring MVC"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Supremes/blog-images@master/imgs/covers/SpringMVC.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring MVC"/></a><div class="content"><a class="title" href="/posts/2d0b435f.html" title="Spring MVC">Spring MVC</a><time datetime="2025-12-04T20:51:26.000Z" title="发表于 2025-12-04 20:51 20:51:26">2025-12-04 20:51</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Supremes</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="/"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章标题和内容..." type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.2"></script></div></div></body></html>